diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/ChangeLog.arm ports/ChangeLog.arm
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/ChangeLog.arm	2006-03-02 16:23:41.000000000 +0100
+++ ports/ChangeLog.arm	2006-07-24 17:43:02.000000000 +0200
@@ -1,3 +1,77 @@
+2006-07-24  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/arm/sigaction.c: If WRAPPER_INCLUDE is
+	defined, include the named file.
+
+2006-07-05  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/arm/sys/ucontext.h: Include
+	<bits/sigcontext.h>.
+	(NGREG, mcontext_t, struct ucontext): Update to match the kernel.
+
+2006-07-05  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/arm/dl-machine.h (elf_machine_dynamic): Correct GOT access to
+	load the _DYNAMIC slot.
+
+2006-06-08  Mark Shinwell  <shinwell@codesourcery.com>
+
+        * sysdeps/arm/nptl/pthreaddef.h (CURRENT_STACK_FRAME): Add -12.
+
+2006-06-08  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/arm/bits/fcntl.h: Reformat.
+	(SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT):
+	Define.
+
+2006-05-30  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/arm/initfini.c: New file.
+
+2006-05-30  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/arm/dl-machine.h (elf_machine_dynamic): Rewrite to load
+	_GLOBAL_OFFSET_TABLE_ explicitly.
+
+2006-05-30  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/arm/kernel-features.h: Add conditionals
+	for __ASSUME_TRUNCATE64_SYSCALL, __ASSUME_MMAP2_SYSCALL,
+	__ASSUME_STAT64_SYSCALL, __ASSUME_FCNTL64, and
+	__ASSUME_VFORK_SYSCALL.
+
+2006-05-05  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/arm/bits/mman.h: Update error message
+	for consistency with other ports.
+	(MADV_REMOVE, MADV_DONTFORK, MADV_DOFORK): Define.
+
+2006-05-05  Lior Balkohen  <balkohen@gmail.com>
+
+	* sysdeps/unix/sysv/linux/arm/bits/fcntl.h: Remove
+	LINUX_FADV_ASYNC_WRITE and LINUX_FADV_WRITE_WAIT.
+	Define SYNC_FILE_RANGE_WAIT_BEFORE, SYNC_FILE_RANGE_WRITE
+	and SYNC_FILE_RANGE_WAIT_AFTER.
+	Declare sync_file_range, vmsplice, splice and tee.
+
+2006-03-27  Lior Balkohen  <balkohen@gmail.com>
+
+	* sysdeps/unix/sysv/linux/arm/bits/fcntl.h: Define
+	LINUX_FADV_ASYNC_WRITE and LINUX_FADV_WRITE_WAIT.
+
+2006-03-21  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/arm/eabi/socket.S: Delete.
+	* sysdeps/unix/sysv/linux/arm/eabi/syscalls.list,
+	sysdeps/unix/sysv/linux/arm/kernel-features.h,
+	sysdeps/unix/sysv/linux/arm/eabi/umount.c: New files.
+	* sysdeps/unix/sysv/linux/arm/eabi/linuxthreads/sysdep-cancel.h
+	(DOCARGS_6, UNDOCARGS_6, RESTORE_LR_6): Define.
+	* sysdeps/unix/sysv/linux/arm/eabi/nptl/sysdep-cancel.h
+	(DOCARGS_6, UNDOCARGS_6, RESTORE_LR_6): Define.
+	* sysdeps/unix/sysv/linux/arm/eabi/sysdep.h: Undefine
+	__NR_stime and __NR_alarm.
+
 2006-03-02  Daniel Jacobowitz  <dan@codesourcery.com>
 
 	* sysdeps/unix/sysv/linux/arm/linuxthreads/sysdep-cancel.h
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/ChangeLog.hppa ports/ChangeLog.hppa
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/ChangeLog.hppa	2006-02-28 23:20:13.000000000 +0100
+++ ports/ChangeLog.hppa	2006-07-19 00:46:12.000000000 +0200
@@ -1,3 +1,182 @@
+2006-07-18  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/nptl/pthread_spin_lock.c (pthread_spin_lock): Swap
+	newval and oldval.
+	* sysdeps/hppa/nptl/pthread_spin_trylock.c (pthread_spin_trylock):
+	Likewise.
+
+2006-07-16  Jeff Bailey  <jbailey@ubuntu.com>
+
+	* sysdeps/hppa/tst-audit.h: New file.
+
+2006-07-16  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/tls-macros.h: Cleanup formatting.
+
+2006-07-15  Jeff Bailey  <jbailey@ubuntu.com>
+
+	* sysdeps/hppa/nptl/tls.h (TLS_INIT_TP): Return NULL.
+
+2006-07-13  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/xstat.c: New file.
+	* sysdeps/unix/sysv/linux/hppa/lxstat.c: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/fxstat.c: Likewise. 
+	* sysdeps/unix/sysv/linux/hppa/fxstatat.c: Likewise.
+
+2006-07-13  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/nptl/Makefile: New file
+	* sysdeps/hppa/nptl/jmpbuf-unwind.h: Likewise
+	* sysdeps/hppa/nptl/pthread_spin_lock.c: Likewise
+	* sysdeps/hppa/nptl/pthread_spin_trylock.c: Likewise
+	* sysdeps/hppa/nptl/pthread_spin_unlock.c: Likewise
+	* sysdeps/hppa/nptl/pthreaddef.h: Likewise
+	* sysdeps/hppa/nptl/tcb-offsets.sym: Likewise
+	* sysdeps/hppa/nptl/tls.h: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/bits: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/createthread.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/fork.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/internaltypes.h: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/libc-lowlevellock.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.h: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/pt-initfini.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/pt-vfork.S: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/pthread_once.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/sysdep-cancel.h: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/unwind-forcedunwind.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/unwind-resume.c: Likewise
+
+2006-06-08  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/Versions: new errlist compat entry 
+	for up to 256 errnos
+
+2006-06-08  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/hppa1.1/Implies: Remove ieee754/ldbl-128. 
+	* sysdeps/unix/sysv/linux/hppa/kernel-features.h
+	[__LINUX_KERNEL_VERSION >= 0x020609]: Define __ASSUME_LWS_CAS.
+	* sysdeps/unix/sysv/linux/hppa/bits/atomic.h: New file.
+
+2006-06-08  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/bits/fcntl.h: Reformat
+	(SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT):
+	Define.
+
+2006-05-24  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/clone.S: .LerrorRest
+	is a label.
+
+2006-05-24  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/ldsodefs.h: New file.
+	* sysdeps/unix/sysv/linux/hppa/bits/mman.h:
+	Only define MADV_* macros when __USE_BSD is present.
+	(MADV_REMOVE, MADV_DONTFORK, MADV_DOFORK): Define.
+
+2006-05-15  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/clone.S: Accept extra arguments
+	required for NPTL.
+	* sysdeps/unix/sysv/linux/hppa/sysdep.c: Use var args for 6 arg
+	syscall.
+	* sysdeps/unix/sysv/linux/hppa/sysdep.h: Move DOARGS and UNDOARGS
+	into PSEUDO_*'s.
+	(ENTRY_LEAF): Define.
+	(PSEUDO_NOERRNO, PSEUDO_ERRVAL): Use ENTRY_LEAF.
+	(DO_CALL): Create frame.
+
+2006-05-15  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/dl-machine.h: Include tls.h
+	(elf_machine_fixup_plt): Returns fdesc.
+	(elf_machine_profile_fixup_plt): Remove.
+	(elf_machine_plt_value): Returns fdesc.
+	(elf_machine_runtime_setup): Check that dl_profile != NULL.
+	(ARCH_LA_PLTENT, ARCH_LA_PLTEXIT): Define.
+	(RTLD_START): Use iitlbp with sr0.
+	(elf_machine_type_class): Include TLS relocs.
+	(reassemble_21, reassemble_14): Define.
+	(elf_machine_rela): Add DIR21L, DIR14R, PLABEL21L, PLABEL14R,
+	TLS_DTPMOD32, TLS_TPREL32, TLS_DTPOFF32 support.
+	(TRAMPOLINE_TEMPLATE): Move to ...
+	* sysdeps/hppa/dl-trampoline.S: ... here.
+	* sysdeps/hppa/abort-instr.h: Use iitlbp with sr0.
+	* sysdeps/hppa/dl-lookupcfg.h: Inlcude dl-fptr.h.
+	(DL_FIXUP_VALUE_TYPE, DL_FIXUP_MAKE_VALUE, DL_FIXUP_VALUE_CODE_ADDR,
+	DL_FIXUP_VALUE_ADD, DL_FIXUP_ADDR_VALUE): Define.
+	* sysdeps/hppa/sysdep.h: Use "!" as a separator. Cleanup comments.
+	* sysdeps/hppa/bits/link.h (La_hppa_regs, La_hppa_retval): Define.
+	Define prototypes for la_hppa_gnu_pltenter and la_hppa_gnu_pltexit.
+
+2006-04-27  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/bits/fcntl.h: Include uio.h, and
+	define vmsplice.
+
+2006-04-21  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/dl-tls.h: New file
+	* sysdeps/hppa/libc-tls.c: Likewise.
+	* sysdeps/hppa/tls-macros.h: Likewise.
+	* sysdeps/hppa/elf/configure: Likewise.
+	* sysdeps/hppa/elf/configure.in: Likewise.
+
+2006-04-20  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/fpu/fclrexcpt.c (feclearexcept): Use union to
+	align parameters. Specify memory clobbers.
+	* sysdeps/hppa/fpu/fedisblxcpt.c (fedisableexcept): Likewise.
+	* sysdeps/hppa/fpu/feenablxcpt.c (feenableexcept): Likewise.
+	* sysdeps/hppa/fpu/fegetenv.c (fegetenv): Do not save exception
+	register. Use memcpy to align buffer.
+	* sysdeps/hppa/fpu/fegetexcept.c (fegetexcept): Store and reload
+	fr0. Use union to align parameters.
+	* sysdeps/hppa/fpu/fegetround.c (fegetround): Likewise.
+	* sysdeps/hppa/fpu/feholdexcpt.c (feholdexcept): Do not save
+	exception registers. Define libm_hidden_def.
+	* sysdeps/hppa/fpu/fesetenv.c (fesetenv): Do not save exception
+	registers.
+	* sysdeps/hppa/fpu/fesetround.c (fesetround): Use union to
+	align parameters, speficy memory clobbers. Define libm_hidde_def
+	* sysdeps/hppa/fpu/feupdateenv.c (feupdateenv): Use union to align
+	parameters. Use memcpy to align buffer.
+	* sysdeps/hppa/fpu/fgetexcptflg.c (fegetexceptflag): Likewise.
+	* sysdeps/hppa/fpu/fsetexcptflg.c (fesetexceptflag): Likewise.
+	* sysdeps/hppa/fpu/ftestexcept.c (fetestexcept): Likewise.
+	* sysdeps/hppa/fpu/libm-test-ulps: Update.
+	* sysdeps/hppa/fpu/bits/fenv.h: Add ABI comments.
+
+2006-04-19  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/bits/mman.h [__USE_GNU]: 
+	Define MMAP_FIXED.
+	* sysdeps/unix/sysv/linux/hppa/bits/fcntl.h [__USE_GNU]: 
+	Define SYNC_FILE_RANGE_WAIT_BEFORE, SYNC_FILE_RANGE_WRITE,
+	SYNC_FILE_RANGE_WAIT_AFTER, sync_file_range, splice, tee.
+
+2006-04-19  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/kernel-features.h: New file.
+
+2006-04-19  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/linuxthreads/pspinlock.c: New file.
+	* sysdeps/hppa/linuxthreads/pt-machine.h: Likewise.
+	* sysdeps/hppa/linuxthreads/tls.h: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h:
+	Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h:
+	Likewise.
+
 2006-02-28  Roland McGrath  <roland@redhat.com>
 
 	* sysdeps/hppa/shlib-versions: New file.
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/ChangeLog.mips ports/ChangeLog.mips
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/ChangeLog.mips	2006-03-03 02:16:30.000000000 +0100
+++ ports/ChangeLog.mips	2006-07-24 17:51:49.000000000 +0200
@@ -1,3 +1,115 @@
+2006-07-24  Joseph Myers  <joseph@codesourcery.com>
+
+	* sysdeps/mips/mips64/n32/libm-test-ulps,
+	sysdeps/mips/mips64/n64/libm-test-ulps: New.
+
+2006-07-24  Joseph Myers  <joseph@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/sigaction.c: If WRAPPER_INCLUDE is
+	defined, include the named file.
+
+2006-06-08  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/bits/fcntl.h: Reformat.
+	(SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT):
+	Define.
+
+2006-06-02  Joseph Myers  <joseph@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/bits/resource.h (RLIM_INFINITY,
+	RLIM64_INFINITY): Define appropriately for N64.  Use unsigned
+	types.
+
+2006-06-02  Joseph Myers  <joseph@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/kernel_stat.h (struct kernel_stat):
+	Don't use struct timespec.
+	* sysdeps/unix/sysv/linux/mips/xstatconv.c (__xstat_conv,
+	__xstat64_conv): Copy individual timespec fields.
+
+2006-06-02  Richard Sandiford  <richard@codesourcery.com>
+
+	* sysdeps/mips/Makefile (ASFLAGS-.os): Define.
+
+2006-06-02  Joseph Myers  <joseph@codesourcery.com>
+
+	* sysdeps/mips/fpu/feholdexcpt.c: Add libm_hidden_def.
+	* sysdeps/mips/fpu/fesetround.c: Likewise.
+
+2006-05-10  Richard Sandiford  <richard@codesourcery.com>
+	    Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/register-dump.h (register_dump): Don't
+	dump sc_cause, sc_status or sc_badvaddr.
+	* sysdeps/unix/sysv/linux/mips/bits/sigcontext.h: Rewrite.  Update
+	structure definitions after DSP kernel changes.
+	* sysdeps/unix/sysv/linux/mips/sys/ucontext.h (mcontext_t): Update
+	after the same DSP changes.
+
+2006-05-08  Richard Sandiford  <richard@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/bits/stat.h (struct stat): Add
+	st_atim, st_mtim and st_ctim interface.
+	(struct stat64): Likewise.
+	* sysdeps/unix/sysv/linux/mips/kernel_stat.h (struct kernel_stat):
+	Replace st_atime and its padding field with st_atim.  Likewise
+	st_mtime/st_mtim and st_ctime/st_ctim.
+	* sysdeps/unix/sysv/linux/mips/xstatconv.c (__xstat_conv): Update
+	after above changes.
+	(__xstat64_conv): Likewise.
+
+2006-05-08  Richard Sandiford  <richard@codesourcery.com>
+
+	* sysdeps/mips/ldsodefs.h: New file.
+	* sysdeps/mips/tst-audit.h: New file.
+
+2006-05-05  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/bits/mman.h: Formatting changes
+	for consistency with other ports.
+	(MADV_REMOVE): Correct value.
+	(MADV_DONTFORK, MADV_DOFORK, POSIX_MADV_NORMAL,
+	POSIX_MADV_RANDOM, POSIX_MADV_SEQUENTIAL, POSIX_MADV_WILLNEED,
+	POSIX_MADV_DONTNEED): Define.
+
+2006-05-05  Lior Balkohen  <balkohen@gmail.com>
+
+	* sysdeps/unix/sysv/linux/mips/bits/fcntl.h: Remove
+	LINUX_FADV_ASYNC_WRITE and LINUX_FADV_WRITE_WAIT.
+	Define SYNC_FILE_RANGE_WAIT_BEFORE, SYNC_FILE_RANGE_WRITE
+	and SYNC_FILE_RANGE_WAIT_AFTER.
+	Declare sync_file_range, vmsplice, splice and tee.
+
+2006-03-27  Lior Balkohen  <balkohen@gmail.com>
+
+	* sysdeps/unix/sysv/linux/mips/bits/fcntl.h: Define
+	LINUX_FADV_ASYNC_WRITE and LINUX_FADV_WRITE_WAIT.  Add readahead
+	prototype.
+
+2006-03-27  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/bits/poll.h (POLLREMOVE, POLLRDHUP):
+	Define.
+
+2006-03-27  Denis Barbier  <barbier@linuxfr.org>
+
+	* sysdeps/unix/sysv/linux/mips/bits/resource.h (RLIMIT_RTPRIO): Fix
+	typo.
+
+2006-03-11  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/nptl/fork.c: Correct path to
+	i386/fork.c.
+
+2006-03-11  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* sysdeps/unix/sysv/linux/mips/configure.in: Set libc_cv_slibdir,
+	libc_cv_localedir, libdir, arch_minimum_kernel, and
+	libc_cv_gcc_unwind_find_fde.
+	* sysdeps/unix/sysv/linux/mips/mips64/configure.in: New file.
+	* sysdeps/unix/sysv/linux/mips/configure: Regenerated.
+	* sysdeps/unix/sysv/linux/mips/mips64/configure: Generated.
+
 2006-03-02  Lior Balkohen  <balkohen@gmail.com>
 
 	* sysdeps/unix/sysv/linux/mips/nptl/bits/pthreadtypes.h
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/arm/dl-machine.h ports/sysdeps/arm/dl-machine.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/arm/dl-machine.h	2005-11-16 19:08:52.000000000 +0100
+++ ports/sysdeps/arm/dl-machine.h	2006-07-05 18:46:20.000000000 +0200
@@ -46,13 +46,19 @@
 
 
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
-   first element of the GOT.  This must be inlined in a function which
-   uses global data.  */
+   first element of the GOT.  We used to use the PIC register to do this
+   without a constant pool reference, but GCC 4.2 will use a pseudo-register
+   for the PIC base, so it may not be in r10.  */
 static inline Elf32_Addr __attribute__ ((unused))
 elf_machine_dynamic (void)
 {
-  register Elf32_Addr *got asm ("r10");
-  return *got;
+  Elf32_Addr dynamic;
+  asm ("ldr %0, 2f\n"
+       "1: ldr %0, [pc, %0]\n"
+       "b 3f\n"
+       "2: .word _GLOBAL_OFFSET_TABLE_ - (1b+8)\n"
+       "3:" : "=r" (dynamic));
+  return dynamic;
 }
 
 
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/arm/initfini.c ports/sysdeps/arm/initfini.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/arm/initfini.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/arm/initfini.c	2006-05-30 17:31:04.000000000 +0200
@@ -0,0 +1,42 @@
+/* Special .init and .fini section support.  ARM version.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Prevent this function from being inlined.  Otherwise half of its
+   constant pool will end up in crti and the other half in crtn.  */
+
+static void call_gmon_start (void) __attribute__((noinline));
+
+#include <sysdeps/generic/initfini.c>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/arm/nptl/pthreaddef.h ports/sysdeps/arm/nptl/pthreaddef.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/arm/nptl/pthreaddef.h	2005-11-16 20:03:42.000000000 +0100
+++ ports/sysdeps/arm/nptl/pthreaddef.h	2006-06-08 19:38:55.000000000 +0200
@@ -30,8 +30,16 @@
 #define TCB_ALIGNMENT		16
 
 
-/* Location of current stack frame.  */
-#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
+/* Location of current stack frame.
+
+   __builtin_frame_address (0) returns the value of the hard frame
+   pointer, which will point at the location of the saved PC on the
+   stack.  Below this in memory is the remainder of the linkage info,
+   occupying 12 bytes.  Therefore in order to address from
+   CURRENT_STACK_FRAME using "struct layout", we need to have the macro
+   return the hard FP minus 12.  Of course, this makes no sense
+   without the obsolete APCS stack layout...  */
+#define CURRENT_STACK_FRAME	(__builtin_frame_address (0) - 12)
 
 
 /* XXX Until we have a better place keep the definitions here.  */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/abort-instr.h ports/sysdeps/hppa/abort-instr.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/abort-instr.h	2002-09-23 05:30:34.000000000 +0200
+++ ports/sysdeps/hppa/abort-instr.h	2006-05-15 01:54:47.000000000 +0200
@@ -3,4 +3,4 @@
    We go with iitlbp because it has a history of being used to crash
    programs.  */
 
-#define ABORT_INSTRUCTION asm ("iitlbp %r0,(%r0)")
+#define ABORT_INSTRUCTION asm ("iitlbp %r0,(%sr0, %r0)")
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/bits/link.h ports/sysdeps/hppa/bits/link.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/bits/link.h	2005-01-06 23:40:18.000000000 +0100
+++ ports/sysdeps/hppa/bits/link.h	2006-05-15 01:54:47.000000000 +0200
@@ -0,0 +1,57 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+/* Registers for entry into PLT on hppa.  */
+typedef struct La_hppa_regs
+{
+  uint32_t lr_reg[4];
+  double lr_fpreg[4];
+  uint32_t lr_sp;
+  uint32_t lr_ra;
+} La_hppa_regs;
+
+/* Return values for calls from PLT on hppa.  */
+typedef struct La_hppa_retval
+{
+  uint32_t lrv_r28;
+  uint32_t lrv_r29;
+  double lr_fr4;
+} La_hppa_retval;
+
+
+__BEGIN_DECLS
+
+extern Elf32_Addr la_hppa_gnu_pltenter (Elf32_Sym *__sym, unsigned int __ndx,
+				       uintptr_t *__refcook,
+				       uintptr_t *__defcook,
+				       La_hppa_regs *__regs,
+				       unsigned int *__flags,
+				       const char *__symname,
+				       long int *__framesizep);
+extern unsigned int la_hppa_gnu_pltexit (Elf32_Sym *__sym, unsigned int __ndx,
+					uintptr_t *__refcook,
+					uintptr_t *__defcook,
+					const La_hppa_regs *__inregs,
+					La_hppa_retval *__outregs,
+					const char *symname);
+
+__END_DECLS
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/dl-lookupcfg.h ports/sysdeps/hppa/dl-lookupcfg.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/dl-lookupcfg.h	2005-01-06 23:40:18.000000000 +0100
+++ ports/sysdeps/hppa/dl-lookupcfg.h	2006-05-15 01:54:47.000000000 +0200
@@ -20,6 +20,8 @@
 #define ELF_FUNCTION_PTR_IS_SPECIAL
 #define DL_UNMAP_IS_SPECIAL
 
+#include <dl-fptr.h>
+
 /* Forward declaration.  */
 struct link_map;
 
@@ -63,3 +65,16 @@
   ((Elf32_Addr)(addr) & 2 ? (addr) : DL_AUTO_FUNCTION_ADDRESS (map, addr))
 #define DL_DT_FINI_ADDRESS(map, addr) \
   ((Elf32_Addr)(addr) & 2 ? (addr) : DL_AUTO_FUNCTION_ADDRESS (map, addr))
+
+/* The type of the return value of fixup/profile_fixup */
+#define DL_FIXUP_VALUE_TYPE struct fdesc
+
+/* Construct a fixup value from the address and linkmap */
+#define DL_FIXUP_MAKE_VALUE(map, addr) \
+   ((struct fdesc) { (addr), (map)->l_info[DT_PLTGOT]->d_un.d_ptr })
+
+/* Extract the code address from a fixup value */
+#define DL_FIXUP_VALUE_CODE_ADDR(value) ((value).ip)
+#define DL_FIXUP_VALUE_ADDR(value) ((uintptr_t) &(value))
+#define DL_FIXUP_ADDR_VALUE(addr) (*(struct fdesc *) (addr))
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/dl-machine.h ports/sysdeps/hppa/dl-machine.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/dl-machine.h	2004-11-19 01:01:25.000000000 +0100
+++ ports/sysdeps/hppa/dl-machine.h	2006-05-15 01:54:46.000000000 +0200
@@ -31,6 +31,7 @@
 #include <errno.h>
 #include <dl-fptr.h>
 #include <abort-instr.h>
+#include <tls.h>
 
 # define VALID_ELF_OSABI(osabi)		((osabi == ELFOSABI_SYSV) || (osabi == ELFOSABI_LINUX))
 # define VALID_ELF_ABIVERSION(ver)	(ver == 0)
@@ -116,43 +117,28 @@
   return dynamic - elf_machine_dynamic ();
 }
 
-/* Fixup a PLT entry to bounce directly to the function at VALUE.  
-   Optimized non-profile version. */
-static inline Elf32_Addr
+/* Fixup a PLT entry to bounce directly to the function at VALUE. */ 
+static inline struct fdesc __attribute__ ((always_inline)) 
 elf_machine_fixup_plt (struct link_map *map, lookup_t t,
 		       const Elf32_Rela *reloc,
-		       Elf32_Addr *reloc_addr, Elf32_Addr value)
+		       Elf32_Addr *reloc_addr, struct fdesc value)
 {
   /* map is the link_map for the caller, t is the link_map for the object
      being called */
-  reloc_addr[1] = D_PTR (t, l_info[DT_PLTGOT]);
-  reloc_addr[0] = value;
-  /* Return the PLT slot rather than the function value so that the
-     trampoline can load the new LTP. */
-  return (Elf32_Addr) reloc_addr;
-}
-
-/* Fixup a PLT entry to bounce directly to the function at VALUE.  */
-#define ELF_MACHINE_PROFILE_FIXUP_PLT elf_machine_profile_fixup_plt
-static inline Elf32_Addr
-elf_machine_profile_fixup_plt (struct link_map *map, lookup_t t,
-		       const Elf32_Rela *reloc,
-		       Elf32_Addr *reloc_addr, Elf32_Addr value)
-{
-  if(__builtin_expect (t == NULL, 1)) 
-    return (Elf32_Addr) reloc_addr;
-  /* Return the PLT slot rather than the function value so that the
-     trampoline can load the new LTP. */
-  return (Elf32_Addr) elf_machine_fixup_plt(map, t, reloc, reloc_addr, value);
+  reloc_addr[1] = value.gp;
+  /* Need to ensure that the gp is visible before the code
+     entry point is updated */
+  ((volatile Elf32_Addr *) reloc_addr)[0] = value.ip;
+  return value;
 }
 
 /* Return the final value of a plt relocation.  */
-static inline Elf32_Addr
+static inline struct fdesc 
 elf_machine_plt_value (struct link_map *map, const Elf32_Rela *reloc,
-		       Elf32_Addr value)
+		       struct fdesc value)
 {
-  /* We are rela only */
-  return value + reloc->r_addend;
+  /* We are rela only, return a function descriptor as a plt entry. */
+  return (struct fdesc) { value.ip + reloc->r_addend, value.gp };
 }
 
 /* Set up the loaded object described by L so its unrelocated PLT
@@ -181,7 +167,7 @@
   
   extern void _dl_runtime_resolve (void);
   extern void _dl_runtime_profile (void);
-  
+ 
   /* Linking lazily */
   if (lazy)
     {
@@ -215,9 +201,10 @@
 	    {
               /* Found the GOT! */       	
               register Elf32_Addr ltp __asm__ ("%r19");
-              /* Identify this shared object. */
+              
+              /* Identify this shared object. Second entry in the got. */
               got[1] = (Elf32_Addr) l;
-
+              
               /* This function will be called to perform the relocation. */
               if (__builtin_expect (!profile, 1))
                 {
@@ -236,7 +223,8 @@
                 }
               else
 	        {
-	          if (_dl_name_match_p (GLRO(dl_profile), l))
+	          if (GLRO(dl_profile) != NULL
+		      && _dl_name_match_p (GLRO(dl_profile), l))
 	            {
 		      /* This is the object we are looking for.  Say that
 		         we really want profiling and the timers are
@@ -316,6 +304,11 @@
   return lazy;
 }
 
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER hppa_gnu_pltenter
+#define ARCH_LA_PLTEXIT hppa_gnu_pltexit
+
 /* Initial entry point code for the dynamic linker.
    The C function `_dl_start' is the real entry point;
    its return value is the user program's entry point.  */
@@ -367,7 +360,7 @@
 "	ldw,ma	8(%r26),%r19\n"						\
 									\
 	/* Uh oh!  We didn't find one.  Abort. */			\
-"	iitlbp	%r0,(%r0)\n"						\
+"	iitlbp	%r0,(%sr0,%r0)\n"					\
 									\
 "2:	ldw	-4(%r26),%r19\n"	/* Found it, load value. */	\
 "	add	%r19,%r20,%r19\n"	/* And add the load offset. */	\
@@ -471,85 +464,28 @@
 "	ldw	4(%r3),%r19\n"	/* load the object's gp */		\
 "	bv	%r0(%r2)\n"						\
 "	depi	2,31,2,%r23\n"	/* delay slot */			\
-	);
-
+);
 
-/* This code gets called via the .plt stub, and is used in
-   dl-runtime.c to call the `fixup' function and then redirect to the
-   address it returns.
-   
-   WARNING: This template is also used by gcc's __cffc, and expects
-   that the "bl" for fixup() exist at a particular offset.
-   Do not change this template without changing gcc, while the prefix
-   "bl" should fix everything so gcc finds the right spot, it will
-   slow down __cffc when it attempts to call fixup to resolve function
-   descriptor references. Please refer to gcc/gcc/config/pa/fptr.c
-   
-   Enter with r19 = reloc offset, r20 = got-8, r21 = fixup ltp.  */
-#define TRAMPOLINE_TEMPLATE(tramp_name, fixup_name) 			\
-  extern void tramp_name (void);		    			\
-  asm (									\
- "	.text\n"							\
- 	/* FAKE bl to provide gcc's __cffc with fixup's address */	\
- "	bl	" #fixup_name ",%r2\n" /* Runtime address of fixup */	\
- "	.globl " #tramp_name "\n"					\
- "	.type " #tramp_name ",@function\n"				\
-  #tramp_name ":\n"							\
- "	.proc\n"							\
- "	.callinfo frame=64,calls,save_rp\n"				\
- "	.entry\n"							\
- 	/* Save return pointer */					\
- "	stw	%r2,-20(%sp)\n"						\
- 	/* Save argument registers in the call stack frame. */		\
- "	stw	%r26,-36(%sp)\n"					\
- "	stw	%r25,-40(%sp)\n"					\
- "	stw	%r24,-44(%sp)\n"					\
- "	stw	%r23,-48(%sp)\n"					\
- 	/* Build a call frame, and save structure pointer. */		\
- "	stwm	%r28,64(%sp)\n"						\
- 									\
- 	/* Set up args to fixup func.  */				\
- "	ldw	8+4(%r20),%r26\n" /* (1) got[1] == struct link_map */	\
- "	copy	%r19,%r25\n"	  /* (2) reloc offset  */		\
- "	copy    %r2,%r24\n"	  /* (3) profile_fixup needs rp */	\
- 									\
- 	/* Call the real address resolver. */				\
- "	bl	" #fixup_name ",%r2\n"					\
- "	copy	%r21,%r19\n"	  /* set fixup func ltp (DELAY SLOT)*/	\
- 									\
- "	ldw	0(%r28),%r22\n"	  /* load up the returned func ptr */	\
- "	ldw	4(%r28),%r19\n"						\
- "	ldwm	-64(%sp),%r28\n"					\
- 	/* Arguments. */						\
- "	ldw	-36(%sp),%r26\n"					\
- "	ldw	-40(%sp),%r25\n"					\
- "	ldw	-44(%sp),%r24\n"					\
- "	ldw	-48(%sp),%r23\n"					\
- 	/* Call the real function. */					\
- "	bv	%r0(%r22)\n"						\
- 	/* Return pointer. */						\
- "	ldw	-20(%sp),%r2\n"						\
- "	.exit\n"							\
- "	.procend\n");
-  
-#ifndef PROF
-#define ELF_MACHINE_RUNTIME_TRAMPOLINE			\
-  TRAMPOLINE_TEMPLATE (_dl_runtime_resolve, fixup);	\
-  TRAMPOLINE_TEMPLATE (_dl_runtime_profile, profile_fixup);
-#else
-#define ELF_MACHINE_RUNTIME_TRAMPOLINE			\
-  TRAMPOLINE_TEMPLATE (_dl_runtime_resolve, fixup);	\
-  strong_alias (_dl_runtime_resolve, _dl_runtime_profile);
-#endif
-
-/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry, so
-   PLT entries should not be allowed to define the value.
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry or 
+   a TLS variable, so references should not be allowed to define the value.
    ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
    of the main executable's symbols, as for a COPY reloc.  */
-#define elf_machine_type_class(type) \
-  ((((type) == R_PARISC_IPLT || (type) == R_PARISC_EPLT)	\
-    * ELF_RTYPE_CLASS_PLT)					\
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || USE___THREAD)
+# define elf_machine_type_class(type)				\
+  ((((type) == R_PARISC_IPLT	 				\
+  || (type) == R_PARISC_EPLT					\
+  || (type) == R_PARISC_TLS_DTPMOD32				\
+  || (type) == R_PARISC_TLS_DTPOFF32				\
+  || (type) == R_PARISC_TLS_TPREL32)				\
+  * ELF_RTYPE_CLASS_PLT)					\
+  | (((type) == R_PARISC_COPY) * ELF_RTYPE_CLASS_COPY))
+#else
+#define elf_machine_type_class(type) 				\
+ ((((type) == R_PARISC_IPLT					\
+   || (type) == R_PARISC_EPLT)					\
+   * ELF_RTYPE_CLASS_PLT)					\
    | (((type) == R_PARISC_COPY) * ELF_RTYPE_CLASS_COPY))
+#endif
 
 /* Used by the runtime in fixup to figure out if reloc is *really* PLT */
 #define ELF_MACHINE_JMP_SLOT R_PARISC_IPLT
@@ -579,9 +515,22 @@
 /* These are only actually used where RESOLVE_MAP is defined, anyway. */
 #ifdef RESOLVE_MAP
 
+#define reassemble_21(as21) \
+  (  (((as21) & 0x100000) >> 20) \
+   | (((as21) & 0x0ffe00) >> 8) \
+   | (((as21) & 0x000180) << 7) \
+   | (((as21) & 0x00007c) << 14) \
+   | (((as21) & 0x000003) << 12))
+
+#define reassemble_14(as14) \
+  (  (((as14) & 0x1fff) << 1) \
+   | (((as14) & 0x2000) >> 13))
+
 auto void __attribute__((always_inline))
-elf_machine_rela (struct link_map *map, const Elf32_Rela *reloc,
-		  const Elf32_Sym *sym, const struct r_found_version *version,
+elf_machine_rela (struct link_map *map, 
+    		  const Elf32_Rela *reloc,
+		  const Elf32_Sym *sym, 
+		  const struct r_found_version *version,
 		  void *const reloc_addr_arg)
 {
   Elf32_Addr *const reloc_addr = reloc_addr_arg;
@@ -590,7 +539,7 @@
   struct link_map *sym_map;
   Elf32_Addr value;
 
-# if !defined RTLD_BOOTSTRAP && !defined SHARED
+# if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC && !defined SHARED
   /* This is defined in rtld.c, but nowhere in the static libc.a; make the
      reference weak so static programs can still link.  This declaration
      cannot be done when compiling rtld.c (i.e.  #ifdef RTLD_BOOTSTRAP)
@@ -612,6 +561,7 @@
 # else
   sym_map = RESOLVE_MAP (&sym, version, r_type);
 # endif
+  
   if (sym_map)
     {
       value = sym ? sym_map->l_addr + sym->st_value : 0;
@@ -635,6 +585,27 @@
 	}
       break;
 
+    case R_PARISC_DIR21L:
+      {
+	unsigned int insn = *(unsigned int *)reloc_addr;
+        value = sym_map->l_addr + sym->st_value 
+		+ ((reloc->r_addend + 0x1000) & -0x2000);
+	value = value >> 11;
+	insn = (insn &~ 0x1fffff) | reassemble_21 (value);
+	*(unsigned int *)reloc_addr = insn;
+      }
+      return;
+
+    case R_PARISC_DIR14R:
+      {
+	unsigned int insn = *(unsigned int *)reloc_addr;
+	value = ((sym_map->l_addr + sym->st_value) & 0x7ff) 
+		+ (((reloc->r_addend & 0x1fff) ^ 0x1000) - 0x1000);
+	insn = (insn &~ 0x3fff) | reassemble_14 (value);
+	*(unsigned int *)reloc_addr = insn;
+      }
+      return;
+
     case R_PARISC_PLABEL32:
       /* Easy rule: If there is a symbol and it is global, then we
          need to make a dynamic function descriptor.  Otherwise we
@@ -653,15 +624,42 @@
       value = (Elf32_Addr)((unsigned int)_dl_make_fptr (sym_map, sym, value) | 2);
       break;
 
+    case R_PARISC_PLABEL21L:
+    case R_PARISC_PLABEL14R:
+      {
+	unsigned int insn = *(unsigned int *)reloc_addr;
+
+        if (__builtin_expect (sym == NULL, 0))
+          break;
+
+        value = (Elf32_Addr)((unsigned int)_dl_make_fptr (sym_map, sym, value) | 2);
+
+        if (r_type == R_PARISC_PLABEL21L)
+	  {
+	    value >>= 11;
+	    insn = (insn &~ 0x1fffff) | reassemble_21 (value);
+	  }
+        else
+	  {
+	    value &= 0x7ff;
+	    insn = (insn &~ 0x3fff) | reassemble_14 (value);
+	  }
+
+	*(unsigned int *)reloc_addr = insn;
+      }
+      return;
+
     case R_PARISC_IPLT:
       if (__builtin_expect (sym_map != NULL, 1))
         {
-	  elf_machine_fixup_plt (NULL, sym_map, reloc, reloc_addr, value);
+	  elf_machine_fixup_plt (NULL, sym_map, reloc, reloc_addr, 
+	      			 DL_FIXUP_MAKE_VALUE(sym_map, value));
         } 
       else 
         {
 	  /* If we get here, it's a (weak) undefined sym.  */
-	  elf_machine_fixup_plt (NULL, map, reloc, reloc_addr, value);
+	  elf_machine_fixup_plt (NULL, map, reloc, reloc_addr, 
+	      			 DL_FIXUP_MAKE_VALUE(map, value));
         }
       return;
 
@@ -685,6 +683,28 @@
       memcpy (reloc_addr_arg, (void *) value,
 	      MIN (sym->st_size, refsym->st_size));
       return;
+
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP)
+    case R_PARISC_TLS_DTPMOD32:
+      value = sym_map->l_tls_modid;
+      break;
+
+    case R_PARISC_TLS_DTPOFF32:
+      /* During relocation all TLS symbols are defined and used.
+         Therefore the offset is already correct.  */
+      if (sym != NULL)
+        *reloc_addr = sym->st_value;
+      return;
+
+    case R_PARISC_TLS_TPREL32:
+      /* The offset is negative, forward from the thread pointer */
+      if (sym != NULL)
+        {
+          CHECK_STATIC_TLS (map, sym_map);
+	  value = sym_map->l_tls_offset + sym->st_value + reloc->r_addend;
+	}
+      break;
+#endif	/* use TLS */
       
     case R_PARISC_NONE:	/* Alright, Wilbur. */
       return;
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/dl-tls.h ports/sysdeps/hppa/dl-tls.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/dl-tls.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/dl-tls.h	2006-04-22 04:21:00.000000000 +0200
@@ -0,0 +1,29 @@
+/* Thread-local storage handling in the ELF dynamic linker.  hppa version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+
+extern void *__tls_get_addr (tls_index *ti);
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/dl-trampoline.S ports/sysdeps/hppa/dl-trampoline.S
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/dl-trampoline.S	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/dl-trampoline.S	2006-05-15 01:54:47.000000000 +0200
@@ -0,0 +1,197 @@
+/* PLT trampolines. hppa version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* This code gets called via the .plt stub, and is used in
+   dl-runtime.c to call the `_dl_fixup' function and then redirect 
+   to the    address it returns. `_dl_fixup' takes two
+   arguments, however `_dl_profile_fixup' takes a number of 
+   parameters for use with library auditing (LA).
+   
+   WARNING: This template is also used by gcc's __cffc, and expects
+   that the "bl" for _dl_runtime_resolve exist at a particular offset.
+   Do not change this template without changing gcc, while the prefix
+   "bl" should fix everything so gcc finds the right spot, it will
+   slow down __cffc when it attempts to call fixup to resolve function
+   descriptor references. Please refer to gcc/gcc/config/pa/fptr.c
+   
+   Enter with r19 = reloc offset, r20 = got-8, r21 = fixup ltp.  */
+
+	/* FAKE bl to provide gcc's __cffc with fixup loc. */
+	.text
+	bl	_dl_fixup, %r2
+        .text
+        .align 4
+        .global _dl_runtime_resolve
+        .type _dl_runtime_resolve,@function
+_dl_runtime_resolve:
+        .PROC
+        .CALLINFO FRAME=128,CALLS,SAVE_RP,ENTRY_GR=3
+        .ENTRY
+        /* SAVE_RP says we do */
+        stw %rp, -20(%sp)
+
+	/* Save static link register */
+	stw	%r29,-16(%sp)
+ 	/* Save argument registers in the call stack frame. */
+	stw	%r26,-36(%sp)
+	stw	%r25,-40(%sp)
+	stw	%r24,-44(%sp)
+	stw	%r23,-48(%sp)
+
+	/* Build a call frame, and save structure pointer. */
+	copy	%sp, %r26	/* Copy previous sp */
+	/* Save function result address (on entry) */
+	stwm	%r28,128(%sp)
+
+	/* Save floating point argument registers */
+	ldo	-56(%sp),%r26	
+	fstd,ma	%fr4,-8(%r26)
+	fstd,ma	%fr5,-8(%r26)
+	fstd,ma	%fr6,-8(%r26)
+	fstd	%fr7,0(%r26)
+
+	/* Fillin some frame info to follow ABI */
+	stw	%r21,-32(%sp)	/* PIC register value */
+	stw	%r26,-4(%sp)	/* Previous sp */
+
+ 	/* Set up args to fixup func, needs only two arguments  */
+	ldw	8+4(%r20),%r26		/* (1) got[1] == struct link_map */
+	copy	%r19,%r25		/* (2) reloc offset  */
+
+ 	/* Call the real address resolver. */
+	bl	_dl_fixup,%rp
+	copy	%r21,%r19		/* set fixup func ltp */
+
+	/* Load up the returned func descriptor */
+	copy	%ret0, %r22
+	copy	%ret1, %r19
+
+	/* Reload arguments fp args */
+	ldo	-80(%sp),%r26
+	fldd,ma	8(%r26),%fr7
+	fldd,ma	8(%r26),%fr6
+	fldd,ma	8(%r26),%fr5
+	fldd	0(%r26),%fr4
+
+	/* Adjust sp, and restore function result address*/
+	ldwm	-128(%sp),%r28
+
+	/* Reload static link register */
+	ldw	-16(%sp),%r29
+	/* Reload general args */
+	ldw	-36(%sp),%r26
+	ldw	-40(%sp),%r25
+	ldw	-44(%sp),%r24
+	ldw	-48(%sp),%r23
+
+	/* Jump to new function, but return to previous function */
+	bv	%r0(%r22)
+	ldw	-20(%sp),%rp
+        .EXIT
+        .PROCEND
+	.size   _dl_runtime_resolve, . - _dl_runtime_resolve
+
+
+	/* FIXME:
+		Need to largely rewrite the bottom half of
+		this code in order to save and restore the
+		LA struct from the stack along with
+		interpreted parameters.
+	*/
+        .text
+        .align 4
+        .global _dl_runtime_profile
+        .type _dl_runtime_profile,@function
+_dl_runtime_profile:
+        .PROC
+        .CALLINFO FRAME=128,CALLS,SAVE_RP,ENTRY_GR=3
+        .ENTRY
+
+        /* SAVE_RP says we do */
+        stw %rp, -20(%sp)
+
+	/* Save static link register */
+	stw	%r29,-16(%sp)
+ 	/* Save argument registers in the call stack frame. */
+	stw	%r26,-36(%sp)
+	stw	%r25,-40(%sp)
+	stw	%r24,-44(%sp)
+	stw	%r23,-48(%sp)
+
+	/* Build a call frame, and save structure pointer. */
+	copy	%sp, %r26	/* Copy previous sp */
+	/* Save function result address (on entry) */
+	stwm	%r28,128(%sp)
+
+	/* Save floating point argument registers */
+	ldo	-56(%sp),%r26	
+	fstd,ma	%fr4,-8(%r26)
+	fstd,ma	%fr5,-8(%r26)
+	fstd,ma	%fr6,-8(%r26)
+	fstd	%fr7,0(%r26)
+
+	/* Fillin some frame info to follow ABI */
+	stw	%r21,-32(%sp)	/* PIC register value */
+	stw	%r26,-4(%sp)	/* Previous sp */
+
+ 	/* Set up args to fixup func, needs five arguments  */
+	ldw	8+4(%r20),%r26		/* (1) got[1] == struct link_map */
+	copy	%r19,%r25		/* (2) reloc offset  */
+	copy    %rp,%r24		/* (3) profile_fixup needs rp */
+	copy	%r0,%r23		/* (4) regs */
+	ldo	-56(%sp), %r1
+	stw	%r1, -52(%sp)		/* (5) long int *framesizep */
+
+ 	/* Call the real address resolver. */
+	bl	_dl_profile_fixup,%rp
+	copy	%r21,%r19		/* set fixup func ltp */
+
+	/* Load up the returned func descriptor */
+	copy	%ret0, %r22
+	copy	%ret1, %r19
+
+	/* Reload arguments fp args */
+	ldo	-80(%sp),%r26
+	fldd,ma	8(%r26),%fr7
+	fldd,ma	8(%r26),%fr6
+	fldd,ma	8(%r26),%fr5
+	fldd	0(%r26),%fr4
+
+	/* Adjust sp, and restore function result address*/
+	ldwm	-128(%sp),%r28
+
+	/* Reload static link register */
+	ldw	-16(%sp),%r29
+	/* Reload general args */
+	ldw	-36(%sp),%r26
+	ldw	-40(%sp),%r25
+	ldw	-44(%sp),%r24
+	ldw	-48(%sp),%r23
+
+	/* Jump to new function, but return to previous function */
+	bv	%r0(%r22)
+	ldw	-20(%sp),%rp
+        .EXIT
+        .PROCEND
+	.size   _dl_runtime_profile, . - _dl_runtime_profile
+
+
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/elf/configure ports/sysdeps/hppa/elf/configure
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/elf/configure	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/elf/configure	2006-04-22 04:21:00.000000000 +0200
@@ -0,0 +1,63 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/hppa/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+echo "$as_me:$LINENO: checking for hppa TLS support" >&5
+echo $ECHO_N "checking for hppa TLS support... $ECHO_C" >&6
+if test "${libc_cv_hppa_tls+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat > conftest.s <<\EOF
+; Setup tls data
+.section ".tdata","awT",@progbits
+foo:	.data	32
+	.text
+; Test general dyanmic relocations
+test0:
+	addil 	LT'foo-$tls_gdidx$, %r19
+	ldo 	RT'foo-$tls_gdidx$(%r1), %r26
+	b 	__tls_get_addr
+	nop
+; Test local dynamic relocations
+test1:
+	addil 	LT'foo-$tls_ldidx$, %r19
+	b 	__tls_get_addr
+	ldo 	RT'foo-$tls_ldidx$(%r1), %r26
+	ldo 	RR'foo-$tls_dtpoff$(%r1), %r25
+	; More variables can be loaded...
+; Test initial exec reloctiosn
+test2:
+	mfctl 	%cr27, %r26
+	addil 	LT'foo-$tls_ieoff$, %r19
+	ldw 	RT'foo-$tls_ieoff$(%r1), %r25
+	add 	%r26, %r25, %r24
+; Test local exec relocations
+test3:
+	mfctl 	%cr27, %r26
+	addil 	LR'foo-$tls_leoff$, %r26
+	ldo 	RR'foo-$tls_leoff$(%r1), %r25
+; Done all the TLS tests.
+EOF
+if { ac_try='${CC-cc} -c $CFLAGS conftest.s 1>&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  libc_cv_hppa_tls=yes
+else
+  libc_cv_hppa_tls=no
+fi
+rm -f conftest*
+fi
+echo "$as_me:$LINENO: result: $libc_cv_hppa_tls" >&5
+echo "${ECHO_T}$libc_cv_hppa_tls" >&6
+if test $libc_cv_hppa_tls = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_TLS_SUPPORT 1
+_ACEOF
+
+fi
+fi
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/elf/configure.in ports/sysdeps/hppa/elf/configure.in
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/elf/configure.in	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/elf/configure.in	2006-04-22 04:21:00.000000000 +0200
@@ -0,0 +1,49 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/hppa/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+AC_CACHE_CHECK(for hppa TLS support, libc_cv_hppa_tls, [dnl
+cat > conftest.s <<\EOF
+; Setup tls data
+.section ".tdata","awT",@progbits
+foo:	.data	32 
+	.text
+; Test general dyanmic relocations
+test0:
+	addil 	LT'foo-$tls_gdidx$, %r19	
+	ldo 	RT'foo-$tls_gdidx$(%r1), %r26
+	b 	__tls_get_addr
+	nop
+; Test local dynamic relocations
+test1:
+	addil 	LT'foo-$tls_ldidx$, %r19
+	b 	__tls_get_addr
+	ldo 	RT'foo-$tls_ldidx$(%r1), %r26
+	ldo 	RR'foo-$tls_dtpoff$(%r1), %r25
+	; More variables can be loaded...
+; Test initial exec reloctiosn
+test2:
+	mfctl 	%cr27, %r26
+	addil 	LT'foo-$tls_ieoff$, %r19
+	ldw 	RT'foo-$tls_ieoff$(%r1), %r25
+	add 	%r26, %r25, %r24
+; Test local exec relocations
+test3:
+	mfctl 	%cr27, %r26
+	addil 	LR'foo-$tls_leoff$, %r26 
+	ldo 	RR'foo-$tls_leoff$(%r1), %r25
+; Done all the TLS tests.
+EOF
+dnl
+if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AS_MESSAGE_LOG_FD); then
+  libc_cv_hppa_tls=yes
+else
+  libc_cv_hppa_tls=no
+fi
+rm -f conftest*])
+if test $libc_cv_hppa_tls = yes; then
+  AC_DEFINE(HAVE_TLS_SUPPORT)
+fi
+fi
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/bits/fenv.h ports/sysdeps/hppa/fpu/bits/fenv.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/bits/fenv.h	2001-07-06 06:55:52.000000000 +0200
+++ ports/sysdeps/hppa/fpu/bits/fenv.h	2006-04-21 02:27:20.000000000 +0200
@@ -62,7 +62,12 @@
 
 /* Type representing floating-point environment.  This structure
    corresponds to the layout of the status and exception words in the
-   register file. */
+   register file. The exception registers are never saved/stored by
+   userspace. This structure is also not correctly aligned ever, in
+   an ABI error we left out __aligned(8) and subsequently all of our
+   fenv functions must accept unaligned input, align the input, and
+   then use assembly to store fr0. This is a performance hit, but 
+   means the ABI is stable. */
 typedef struct
 {
   unsigned int __status_word;
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fclrexcpt.c ports/sysdeps/hppa/fpu/fclrexcpt.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fclrexcpt.c	2003-12-18 04:56:15.000000000 +0100
+++ ports/sysdeps/hppa/fpu/fclrexcpt.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,14 +23,13 @@
 int
 feclearexcept (int excepts)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2]; } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
-
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
   /* Clear all the relevant bits. */
-  sw[0] &= ~((excepts & FE_ALL_EXCEPT) << 27);
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  s.sw[0] &= ~((excepts & FE_ALL_EXCEPT) << 27);
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   /* Success.  */
   return 0;
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fedisblxcpt.c ports/sysdeps/hppa/fpu/fedisblxcpt.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fedisblxcpt.c	2001-07-06 06:55:52.000000000 +0200
+++ ports/sysdeps/hppa/fpu/fedisblxcpt.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,15 +23,16 @@
 int
 fedisableexcept (int excepts)
 {
-  unsigned int sw[2], old_exc;
+  union { unsigned long long l; unsigned int sw[2]; } s; 
+  unsigned int old_exc;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
 
-  old_exc = sw[0] & FE_ALL_EXCEPT;
+  old_exc = s.sw[0] & FE_ALL_EXCEPT;
 
-  sw[0] &= ~(excepts & FE_ALL_EXCEPT);
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  s.sw[0] &= ~(excepts & FE_ALL_EXCEPT);
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   return old_exc;
 }
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/feenablxcpt.c ports/sysdeps/hppa/fpu/feenablxcpt.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/feenablxcpt.c	2001-07-06 06:55:52.000000000 +0200
+++ ports/sysdeps/hppa/fpu/feenablxcpt.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,15 +23,16 @@
 int
 feenableexcept (int excepts)
 {
-  unsigned int sw[2], old_exc;
+  union { unsigned long long l; unsigned int sw[2]; } s;
+  unsigned int old_exc;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
 
-  old_exc = sw[0] & FE_ALL_EXCEPT;
+  old_exc = s.sw[0] & FE_ALL_EXCEPT;
 
-  sw[0] |= (excepts & FE_ALL_EXCEPT);
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  s.sw[0] |= (excepts & FE_ALL_EXCEPT);
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   return old_exc;
 }
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fegetenv.c ports/sysdeps/hppa/fpu/fegetenv.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fegetenv.c	2003-12-18 04:56:50.000000000 +0100
+++ ports/sysdeps/hppa/fpu/fegetenv.c	2006-04-21 02:27:20.000000000 +0200
@@ -19,15 +19,17 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <string.h>
 
 int
 fegetenv (fenv_t *envp)
 {
+  unsigned long long buf[4], *bufptr = buf;
+  
   __asm__ (
-	   "fstd,ma %%fr0,8(%1)\n"
-	   "fstd,ma %%fr1,8(%1)\n"
-	   "fstd,ma %%fr2,8(%1)\n"
-	   "fstd %%fr3,0(%1)\n"
-	   : "=m" (*envp), "+r" (envp));
+	   "fstd,ma %%fr0,8(%1)	\n\t"
+	   "fldd -8(%1),%%fr0	\n\t"
+	   : "=m" (buf), "+r" (bufptr) : : "%r0");
+  memcpy(envp, buf, sizeof (*envp));
   return 0;
 }
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fegetexcept.c ports/sysdeps/hppa/fpu/fegetexcept.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fegetexcept.c	2001-07-06 06:55:52.000000000 +0200
+++ ports/sysdeps/hppa/fpu/fegetexcept.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,10 +23,12 @@
 int
 fegetexcept (void)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2] } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+           "fldd 0(%1),%%fr0	\n\t"
+      	   : "=m" (s.l) : "r" (&s.l) : "%r0");
 
-  return sw[0] & FE_ALL_EXCEPT;
+  return (s.sw[0] & FE_ALL_EXCEPT);
 }
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fegetround.c ports/sysdeps/hppa/fpu/fegetround.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fegetround.c	2001-07-06 06:55:52.000000000 +0200
+++ ports/sysdeps/hppa/fpu/fegetround.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,10 +23,12 @@
 int
 fegetround (void)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2] } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+	   "fldd 0(%1),%%fr0	\n\t" 
+           : "=m" (s.l) : "r" (&s.l));
 
-  return sw[0] & FE_DOWNWARD;
+  return (s.sw[0] & FE_DOWNWARD);
 }
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/feholdexcpt.c ports/sysdeps/hppa/fpu/feholdexcpt.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/feholdexcpt.c	2004-02-21 03:10:01.000000000 +0100
+++ ports/sysdeps/hppa/fpu/feholdexcpt.c	2006-04-21 02:27:20.000000000 +0200
@@ -24,33 +24,32 @@
 int
 feholdexcept (fenv_t *envp)
 {
-  fenv_t clear;
-  fenv_t * _regs = envp;
+  union { unsigned long long buf[4]; fenv_t env; } clear;
+  unsigned long long *bufptr;
 
   /* Store the environment.  */
+  bufptr = clear.buf;
   __asm__ (
 	   "fstd,ma %%fr0,8(%1)\n"
-	   "fstd,ma %%fr1,8(%1)\n"
-	   "fstd,ma %%fr2,8(%1)\n"
-	   "fstd %%fr3,0(%1)\n"
-	   : "=m" (*_regs), "+r" (_regs));
-  memcpy (&clear, envp, sizeof (clear));
-
-  /* Now clear all exceptions.  */
-  clear.__status_word &= ~(FE_ALL_EXCEPT << 27);
-  memset (clear.__exception, 0, sizeof (clear.__exception));
+	   : "=m" (clear), "+r" (bufptr) : : "%r0");
+  memcpy (envp, &clear.env, sizeof (fenv_t));
 
+  /* Clear exception queues */
+  memset (clear.env.__exception, 0, sizeof (clear.env.__exception));
   /* And set all exceptions to non-stop.  */
-  clear.__status_word &= ~FE_ALL_EXCEPT;
+  clear.env.__status_word &= ~FE_ALL_EXCEPT;
+  /* Now clear all flags  */
+  clear.env.__status_word &= ~(FE_ALL_EXCEPT << 27);
 
-  /* Load the new environment. */
-  _regs = &clear;
+  /* Load the new environment. Note: fr0 must load last to enable T-bit 
+     Thus we start bufptr at the end and work backwards */
+  bufptr = (unsigned int)(clear.buf) + sizeof(unsigned int)*4;
   __asm__ (
-	   "fldd,ma 8(%0),%%fr0\n"
-	   "fldd,ma 8(%0),%%fr1\n"
-	   "fldd,ma 8(%0),%%fr2\n"
-	   "fldd 0(%0),%%fr3\n"
-	   : : "r" (_regs));
+	   "fldd,mb -8(%0),%%fr0\n"
+	   : : "r" (bufptr), "m" (clear) : "%r0");
 
   return 0;
 }
+
+libm_hidden_def (feholdexcept)
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fesetenv.c ports/sysdeps/hppa/fpu/fesetenv.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fesetenv.c	2003-12-18 04:57:31.000000000 +0100
+++ ports/sysdeps/hppa/fpu/fesetenv.c	2006-04-21 02:27:20.000000000 +0200
@@ -25,40 +25,38 @@
 int
 fesetenv (const fenv_t *envp)
 {
-  fenv_t temp;
-  fenv_t * _regs = &temp;
+  union { unsigned long long buf[4]; fenv_t env; } temp;
+  unsigned long long *bufptr;
 
   /* Install the environment specified by ENVP.  But there are a few
      values which we do not want to come from the saved environment.
      Therefore, we get the current environment and replace the values
      we want to use from the environment specified by the parameter.  */
+  bufptr = temp.buf;
   __asm__ (
 	   "fstd,ma %%fr0,8(%1)\n"
-	   "fstd,ma %%fr1,8(%1)\n"
-	   "fstd,ma %%fr2,8(%1)\n"
-	   "fstd %%fr3,0(%1)\n"
-	   : "=m" (*_regs), "+r" (_regs));
+	   : "=m" (temp), "+r" (bufptr) : : "%r0");
 
-  temp.__status_word &= ~(FE_ALL_EXCEPT
-			  | (FE_ALL_EXCEPT << 27)
-			  | FE_DOWNWARD);
+  temp.env.__status_word &= ~(FE_ALL_EXCEPT
+			    | (FE_ALL_EXCEPT << 27)
+			    | FE_DOWNWARD);
   if (envp == FE_DFL_ENV)
     ;
   else if (envp == FE_NOMASK_ENV)
-    temp.__status_word |= FE_ALL_EXCEPT;
+    temp.env.__status_word |= FE_ALL_EXCEPT;
   else
-    temp.__status_word |= (envp->__status_word
-			   & (FE_ALL_EXCEPT
-			      | FE_DOWNWARD
-			      | (FE_ALL_EXCEPT << 27)));
+    temp.env.__status_word |= (envp->__status_word
+			       & (FE_ALL_EXCEPT
+				  | FE_DOWNWARD
+				  | (FE_ALL_EXCEPT << 27)));
 
-  /* Load the new environment. */
+  /* Load the new environment. We use bufptr again since the 
+     initial asm has modified the value of the register and here
+     we take advantage of that to load in reverse order so fr0
+     is loaded last and T-Bit is enabled. */
   __asm__ (
-	   "fldd,ma -8(%1),%%fr3\n"
-	   "fldd,ma -8(%1),%%fr2\n"
-	   "fldd,ma -8(%1),%%fr1\n"
-	   "fldd 0(%1),%%fr0\n"
-	   : "=m" (*_regs), "+r" (_regs));
+	   "fldd,mb -8(%1),%%fr0\n"
+	   : "=m" (temp), "+r" (bufptr) : : "%r0" );
 
   /* Success.  */
   return 0;
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fesetround.c ports/sysdeps/hppa/fpu/fesetround.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fesetround.c	2002-12-03 03:50:52.000000000 +0100
+++ ports/sysdeps/hppa/fpu/fesetround.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,17 +23,19 @@
 int
 fesetround (int round)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2]; } s;
 
   if (round & ~FE_DOWNWARD)
-    /* ROUND is not a valid rounding mode.  */
+    /* round is not a valid rounding mode. */
     return 1;
-
+  
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
-  sw[0] &= ~FE_DOWNWARD;
-  sw[0] |= round;
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
+  s.sw[0] &= ~FE_DOWNWARD;
+  s.sw[0] |= round & FE_DOWNWARD;
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   return 0;
 }
+
+libm_hidden_def (fesetround)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/feupdateenv.c ports/sysdeps/hppa/fpu/feupdateenv.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/feupdateenv.c	2004-04-18 00:51:43.000000000 +0200
+++ ports/sysdeps/hppa/fpu/feupdateenv.c	2006-04-21 02:27:20.000000000 +0200
@@ -19,19 +19,22 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <string.h>
 
 int
 feupdateenv (const fenv_t *envp)
 {
-  unsigned int sw[2];
-
-  /* Get the current exception status. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  union { unsigned long long l; unsigned int sw[2]; } s;
+  fenv_t temp;
+  /* Get the current exception status */
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+           "fldd 0(%1),%%fr0	\n\t" 
+	   : "=m" (s.l) : "r" (&s.l));
+  memcpy(&temp, envp, sizeof(fenv_t));
+  /* Currently raised exceptions not cleared */
+  temp.__status_word |= s.sw[0] & (FE_ALL_EXCEPT << 27);
   /* Install new environment.  */
-  fesetenv (envp);
-  /* Raise the saved exceptions */
-  feraiseexcept(sw[0] & FE_ALL_EXCEPT);
-
+  fesetenv (&temp);
   /* Success.  */
   return 0;
 }
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fgetexcptflg.c ports/sysdeps/hppa/fpu/fgetexcptflg.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fgetexcptflg.c	2001-07-06 06:55:52.000000000 +0200
+++ ports/sysdeps/hppa/fpu/fgetexcptflg.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,12 +23,14 @@
 int
 fegetexceptflag (fexcept_t *flagp, int excepts)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2]; } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+           "fldd 0(%1),%%fr0	\n\t" 
+      	   : "=m" (s.l) : "r" (&s.l) : "%r0");
 
-  *flagp = (sw[0] >> 27) & excepts & FE_ALL_EXCEPT;
+  *flagp = (s.sw[0] >> 27) & excepts & FE_ALL_EXCEPT;
 
   /* Success.  */
   return 0;
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fsetexcptflg.c ports/sysdeps/hppa/fpu/fsetexcptflg.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/fsetexcptflg.c	2003-12-18 04:58:26.000000000 +0100
+++ ports/sysdeps/hppa/fpu/fsetexcptflg.c	2006-04-21 02:27:20.000000000 +0200
@@ -24,16 +24,14 @@
 int
 fesetexceptflag (const fexcept_t *flagp, int excepts)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2]; } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
-
-  /* Install new enable trap bits  */
-  sw[0] |= (*flagp & excepts & FE_ALL_EXCEPT) << 27;
-
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
+  /* Install new raised trap bits */
+  s.sw[0] |= (*flagp & excepts & FE_ALL_EXCEPT) << 27;
   /* Store the new status word.  */
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   /* Success.  */
   return 0;
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/ftestexcept.c ports/sysdeps/hppa/fpu/ftestexcept.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/ftestexcept.c	2001-07-06 06:55:52.000000000 +0200
+++ ports/sysdeps/hppa/fpu/ftestexcept.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,10 +23,12 @@
 int
 fetestexcept (int excepts)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2] } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+           "fldd 0(%1),%%fr0	\n\t" 
+      	   : "=m" (s.l) : "r" (&s.l));
 
-  return (sw[0] >> 27) & excepts & FE_ALL_EXCEPT;
+  return (s.sw[0] >> 27) & excepts & FE_ALL_EXCEPT;
 }
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/libm-test-ulps ports/sysdeps/hppa/fpu/libm-test-ulps
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/fpu/libm-test-ulps	2006-01-15 18:59:37.000000000 +0100
+++ ports/sysdeps/hppa/fpu/libm-test-ulps	2006-04-21 02:27:20.000000000 +0200
@@ -1,6 +1,9 @@
 # Begin of automatic generation
 
 # atan2
+Test "atan2 (-0.00756827042671106339, -.001792735857538728036) == -1.80338464113663849327153994380":
+float: 6
+ifloat: 6
 Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
 float: 3
 ifloat: 3
@@ -258,9 +261,6 @@
 ifloat: 1
 
 # ctan
-Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
-double: 1
-idouble: 1
 Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
 double: 1
 idouble: 1
@@ -479,6 +479,11 @@
 float: 1
 ifloat: 1
 
+# lround
+Test "lround (1071930.0008) == 1071930":
+double: -214511494
+idouble: -214511494
+
 # sincos
 Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
 double: 1
@@ -640,8 +645,8 @@
 
 # Maximal error of functions:
 Function: "atan2":
-float: 3
-ifloat: 3
+float: 6
+ifloat: 6
 
 Function: "atanh":
 float: 1
@@ -777,10 +782,6 @@
 float: 1
 ifloat: 1
 
-Function: Real part of "ctan":
-double: 1
-idouble: 1
-
 Function: Imaginary part of "ctan":
 double: 1
 idouble: 1
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/hppa1.1/Implies ports/sysdeps/hppa/hppa1.1/Implies
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/hppa1.1/Implies	2000-10-15 05:25:29.000000000 +0200
+++ ports/sysdeps/hppa/hppa1.1/Implies	2006-06-09 03:25:30.000000000 +0200
@@ -1,4 +1,3 @@
 wordsize-32
 ieee754/flt-32
 ieee754/dbl-64
-ieee754/ldbl-128
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/ldsodefs.h ports/sysdeps/hppa/ldsodefs.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/ldsodefs.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/ldsodefs.h	2006-05-24 17:31:25.000000000 +0200
@@ -0,0 +1,42 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _HPPA_LDSODEFS_H
+#define _HPPA_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_hppa_regs;
+struct La_hppa_retval;
+
+#define ARCH_PLTENTER_MEMBERS \
+    Elf32_Addr (*hppa_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,	\
+				     uintptr_t *, struct La_hppa_regs *,	\
+				     unsigned int *, const char *name,		\
+				     long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS \
+    unsigned int (*hppa_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,	\
+				      uintptr_t *,				\
+				      const struct La_hppa_regs *,		\
+				      struct La_hppa_retval *, const char *);
+
+#include_next <ldsodefs.h>
+
+#endif
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/libc-tls.c ports/sysdeps/hppa/libc-tls.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/libc-tls.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/libc-tls.c	2006-04-22 04:21:00.000000000 +0200
@@ -0,0 +1,38 @@
+/* Thread-local storage handling in the ELF dynamic linker.  hppa version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+#if USE_TLS
+
+/* On hppa, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + ti->ti_offset;
+}
+
+#endif
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/linuxthreads/pspinlock.c ports/sysdeps/hppa/linuxthreads/pspinlock.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/linuxthreads/pspinlock.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/linuxthreads/pspinlock.c	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,82 @@
+/* POSIX spinlock implementation.  hppa version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include "internals.h"
+
+int
+__pthread_spin_lock (pthread_spinlock_t *lock)
+{
+  volatile unsigned int *addr = __ldcw_align (lock);
+
+  while (__ldcw (addr) == 0)
+    while (*addr == 0) ;
+
+  return 0;
+}
+weak_alias (__pthread_spin_lock, pthread_spin_lock)
+
+
+int
+__pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+  volatile unsigned int *a = __ldcw_align (lock);
+
+  return __ldcw (a) ? 0 : EBUSY;
+}
+weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
+
+
+int
+__pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+  volatile unsigned int *a = __ldcw_align (lock);
+  int tmp = 1;
+  /* This should be a memory barrier to newer compilers */
+  __asm__ __volatile__ ("stw,ma %1,0(%0)"
+                        : : "r" (a), "r" (tmp) : "memory");           
+  return 0;
+}
+weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
+
+
+int
+__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
+     all processes which can access the memory location `lock' points
+     to can use the spinlock.  */
+  volatile unsigned int *a = __ldcw_align (lock);
+  int tmp = 1;
+  /* This should be a memory barrier to newer compilers */
+  __asm__ __volatile__ ("stw,ma %1,0(%0)"
+                        : : "r" (a), "r" (tmp) : "memory");           
+  return 0;
+}
+weak_alias (__pthread_spin_init, pthread_spin_init)
+
+
+int
+__pthread_spin_destroy (pthread_spinlock_t *lock)
+{
+  /* Nothing to do.  */
+  return 0;
+}
+weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/linuxthreads/pt-machine.h ports/sysdeps/hppa/linuxthreads/pt-machine.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/linuxthreads/pt-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/linuxthreads/pt-machine.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,134 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   hppa version.
+   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <sys/types.h>
+#include <bits/initspin.h>
+
+#ifndef PT_EI
+# define PT_EI extern inline __attribute__ ((always_inline))
+#endif
+
+extern inline long int testandset (__atomic_lock_t *spinlock);
+extern inline int __compare_and_swap (long int *p, long int oldval, long int newval);
+extern inline int lock_held (__atomic_lock_t *spinlock); 
+extern inline int __load_and_clear (__atomic_lock_t *spinlock);
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("%r30");
+
+/* Get/Set thread-specific pointer.  We have to call into the kernel to
+ * modify it, but we can read it in user mode.  */
+#ifndef THREAD_SELF
+#define THREAD_SELF __get_cr27()
+#endif
+
+#ifndef SET_THREAD_SELF
+#define SET_THREAD_SELF(descr) __set_cr27(descr)
+#endif
+/* Use this to determine type */
+struct _pthread_descr_struct *__thread_self;
+
+static inline struct _pthread_descr_struct * __get_cr27(void)
+{
+  long cr27;
+  asm ("mfctl %%cr27, %0" : "=r" (cr27) : );
+  return (struct _pthread_descr_struct *) cr27;
+}
+
+#ifndef INIT_THREAD_SELF
+#define INIT_THREAD_SELF(descr, nr) __set_cr27(descr)
+#endif
+
+static inline void __set_cr27(struct _pthread_descr_struct * cr27)
+{
+  asm ( "ble	0xe0(%%sr2, %%r0)\n\t"
+	"copy	%0, %%r26"
+	: : "r" (cr27) : "r26" );
+}
+
+/* We want the OS to assign stack addresses.  */
+#define FLOATING_STACKS	1
+#define ARCH_STACK_MAX_SIZE	8*1024*1024
+
+/* The hppa only has one atomic read and modify memory operation,
+   load and clear, so hppa spinlocks must use zero to signify that
+   someone is holding the lock.  The address used for the ldcw
+   semaphore must be 16-byte aligned.  */
+#define __ldcw(a) \
+({ 									\
+  unsigned int __ret;							\
+  __asm__ __volatile__("ldcw 0(%1),%0"					\
+                      : "=r" (__ret) : "r" (a) : "memory");		\
+  __ret;								\
+})
+
+/* Strongly ordered lock reset */
+#define __lock_reset(lock_addr, tmp) \
+({										\
+	__asm__ __volatile__ ("stw,ma %1,0(%0)"					\
+				: : "r" (lock_addr), "r" (tmp) : "memory"); 	\
+})
+
+/* Because malloc only guarantees 8-byte alignment for malloc'd data,
+   and GCC only guarantees 8-byte alignment for stack locals, we can't
+   be assured of 16-byte alignment for atomic lock data even if we
+   specify "__attribute ((aligned(16)))" in the type declaration.  So,
+   we use a struct containing an array of four ints for the atomic lock
+   type and dynamically select the 16-byte aligned int from the array
+   for the semaphore.  */
+#define __PA_LDCW_ALIGNMENT 16
+#define __ldcw_align(a) ({ \
+  volatile unsigned int __ret = (unsigned int) a;			\
+  if ((__ret & ~(__PA_LDCW_ALIGNMENT - 1)) < (unsigned int) a)		\
+    __ret = (__ret & ~(__PA_LDCW_ALIGNMENT - 1)) + __PA_LDCW_ALIGNMENT; \
+  (unsigned int *) __ret;						\
+})
+
+/* Spinlock implementation; required.  */
+PT_EI int
+__load_and_clear (__atomic_lock_t *spinlock)
+{
+  volatile unsigned int *a = __ldcw_align (spinlock);
+
+  return __ldcw (a);
+}
+
+/* Emulate testandset */
+PT_EI long int
+testandset (__atomic_lock_t *spinlock)
+{
+  return (__load_and_clear(spinlock) == 0);
+}
+
+PT_EI int
+lock_held (__atomic_lock_t *spinlock)
+{
+  volatile unsigned int *a = __ldcw_align (spinlock);
+
+  return *a == 0;
+}
+		
+#endif /* pt-machine.h */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/linuxthreads/tls.h ports/sysdeps/hppa/linuxthreads/tls.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/linuxthreads/tls.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/linuxthreads/tls.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,163 @@
+/* Definition for thread-local data handling.  linuxthreads/hppa version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H
+
+#ifndef __ASSEMBLER__
+# include <pt-machine.h>
+# include <stdbool.h>
+# include <stddef.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif /* __ASSEMBLER__ */
+
+
+#if defined HAVE_TLS_SUPPORT 
+
+/* Signal that TLS support is available.  */
+# define USE_TLS	1
+
+# ifndef __ASSEMBLER__
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* Include some syscall information for other headers */
+#  include <sysdep.h>
+
+/* This is the size of the initial TCB.  */
+#  define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
+
+/* Alignment requirements for the initial TCB.  */
+#  define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
+
+/* This is the size of the TCB.  */
+#  define TLS_TCB_SIZE sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+#  define TLS_PRE_TCB_SIZE sizeof (struct _pthread_descr_struct)
+
+/* Alignment requirements for the TCB.  */
+#  define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
+
+/* The TLS blocks start right after the TCB.  */
+#  define TLS_DTV_AT_TP	1
+
+/* Return the thread descriptor for the current thread.  */
+#  undef THREAD_SELF
+#  define THREAD_SELF 				\
+  ({ struct _pthread_descr_struct *__self;	\
+	__self = __get_cr27();			\
+   	__self - 1;				\
+   })
+
+#  undef INIT_THREAD_SELF
+#  define INIT_THREAD_SELF(descr, nr) 				\
+  ({ struct _pthread_descr_struct *__self = (void *)descr;	\
+	__set_cr27(__self + 1);					\
+   	0;							\
+   })
+
+/* Access to data in the thread descriptor is easy.  */
+#define THREAD_GETMEM(descr, member) \
+  ((void) sizeof (descr), THREAD_SELF->member)
+#define THREAD_GETMEM_NC(descr, member) \
+  ((void) sizeof (descr), THREAD_SELF->member)
+#define THREAD_SETMEM(descr, member, value) \
+  ((void) sizeof (descr), THREAD_SELF->member = (value))
+#define THREAD_SETMEM_NC(descr, member, value) \
+  ((void) sizeof (descr), THREAD_SELF->member = (value))
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+#  define INSTALL_DTV(tcbp, dtvp) \
+  ((tcbhead_t *) (tcbp))->dtv = dtvp + 1
+
+/* Install new dtv for current thread.  */
+#  define INSTALL_NEW_DTV(dtv) \
+  ({ tcbhead_t *__tcbp = (tcbhead_t *)__get_cr27();	\
+   	__tcbp->dtv = dtv;				\
+   })
+
+/* Return dtv of given thread descriptor.  */
+#  define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+#  define TLS_INIT_TP(tcbp, secondcall) \
+  ({ __set_cr27(tcbp); 0; })
+
+/* Return the address of the dtv for the current thread.  */
+#  define THREAD_DTV() 					\
+  ({ tcbhead_t *__tcbp = (tcbhead_t *)__get_cr27();	\
+   	__tcbp->dtv;					\
+   })
+
+# define TLS_MULTIPLE_THREADS_IN_TCB 1
+
+/* Get the thread descriptor definition.  This must be after the
+   the definition of THREAD_SELF for TLS.  */
+#  include <linuxthreads/descr.h>
+
+# endif /* __ASSEMBLER__ */
+
+#else
+
+# ifndef __ASSEMBLER__
+
+typedef struct
+{
+  void *tcb;
+  dtv_t *dtv;
+  void *self;
+  int multiple_threads;
+} tcbhead_t;
+
+/* Get the thread descriptor definition.  */
+#  include <linuxthreads/descr.h>
+
+#  define NONTLS_INIT_TP \
+  do { 									\
+    static const tcbhead_t nontls_init_tp = { .multiple_threads = 0 };	\
+    INIT_THREAD_SELF(&nontls_init_tp, 0);	      			\
+  } while (0)
+
+# endif /* __ASSEMBLER__ */
+
+#endif	/* HAVE_TLS_SUPPORT */
+
+#endif	/* tls.h */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/jmpbuf-unwind.h ports/sysdeps/hppa/nptl/jmpbuf-unwind.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/jmpbuf-unwind.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/nptl/jmpbuf-unwind.h	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,31 @@
+/* Copyright (C) 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <jmpbuf-offsets.h>
+#include <stdint.h>
+#include <unwind.h>
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) > (uintptr_t)(((unsigned long *) _jmpbuf)[JB_SP]) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/Makefile ports/sysdeps/hppa/nptl/Makefile
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/nptl/Makefile	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,21 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/pthreaddef.h ports/sysdeps/hppa/nptl/pthreaddef.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/pthreaddef.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/nptl/pthreaddef.h	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(8 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN		64
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Alignment requirement for TCB, note that this must be larger than STACK_ALIGN  */
+#define TCB_ALIGNMENT		STACK_ALIGN
+
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("%r30");
+
+
+/* XXX Until we have a better place keep the definitions here.  */
+
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/pthread_spin_lock.c ports/sysdeps/hppa/nptl/pthread_spin_lock.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/pthread_spin_lock.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/nptl/pthread_spin_lock.c	2006-07-19 00:46:12.000000000 +0200
@@ -0,0 +1,38 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <atomic.h>
+#include "pthreadP.h"
+
+int
+pthread_spin_lock (pthread_spinlock_t *lock)
+{
+#if 0
+  volatile unsigned int *addr = __ldcw_align (lock);
+
+  while (__ldcw (addr) == 0)
+    while (*addr == 0) ;
+
+  return 0;
+#endif
+
+  while (atomic_compare_and_exchange_val_acq(lock, 1, 0) == 1)
+    while (*lock == 1);
+  
+  return 0;
+}
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/pthread_spin_trylock.c ports/sysdeps/hppa/nptl/pthread_spin_trylock.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/pthread_spin_trylock.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/nptl/pthread_spin_trylock.c	2006-07-19 00:46:12.000000000 +0200
@@ -0,0 +1,34 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <atomic.h>
+#include "pthreadP.h"
+
+int
+pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+#if 0
+  volatile unsigned int *a = __ldcw_align (lock);
+
+  return __ldcw (a) ? 0 : EBUSY;
+#endif
+
+  return atomic_compare_and_exchange_val_acq(lock, 1, 0) ? EBUSY : 0;
+
+}
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/pthread_spin_unlock.c ports/sysdeps/hppa/nptl/pthread_spin_unlock.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/pthread_spin_unlock.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/nptl/pthread_spin_unlock.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,36 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Ugly hack to avoid the declaration of pthread_spin_init.  */
+#define pthread_spin_init pthread_spin_init_XXX
+#include "pthreadP.h"
+#undef pthread_spin_init
+
+int
+pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+#if 0
+  volatile unsigned int *a = __ldcw_align (lock);
+#endif
+  int tmp = 0;
+  /* This should be a memory barrier to newer compilers */
+  __asm__ __volatile__ ("stw,ma %1,0(%0)"
+                        : : "r" (lock), "r" (tmp) : "memory");           
+  return 0;
+}
+strong_alias (pthread_spin_unlock, pthread_spin_init)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/tcb-offsets.sym ports/sysdeps/hppa/nptl/tcb-offsets.sym
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/tcb-offsets.sym	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/nptl/tcb-offsets.sym	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,18 @@
+#include <sysdep.h>
+#include <tls.h>
+
+RESULT			offsetof (struct pthread, result)
+TID			offsetof (struct pthread, tid)
+PID			offsetof (struct pthread, pid)
+CANCELHANDLING		offsetof (struct pthread, cancelhandling)
+CLEANUP_JMP_BUF		offsetof (struct pthread, cleanup_jmp_buf)
+MULTIPLE_THREADS_OFFSET	offsetof (struct pthread, header.multiple_threads)
+TLS_PRE_TCB_SIZE	sizeof (struct pthread)
+MUTEX_FUTEX		offsetof (pthread_mutex_t, __data.__lock)
+
+-- Use a thread_offset when working with asm to make things simpler
+-- This way we get the offset of a member in the struct pthread that
+-- preceeds the thread pointer (which points to the dtv).
+#define thread_offsetof(mem)    (unsigned int)(offsetof(struct pthread, mem) - sizeof(struct pthread))
+PID_THREAD_OFFSET		thread_offsetof (pid)
+MULTIPLE_THREADS_THREAD_OFFSET	thread_offsetof (header.multiple_threads)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/tls.h ports/sysdeps/hppa/nptl/tls.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/nptl/tls.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/nptl/tls.h	2006-07-16 20:25:24.000000000 +0200
@@ -0,0 +1,151 @@
+/* Definition for thread-local data handling.  NPTL/hppa version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+#include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif /* __ASSEMBLER__ */
+
+
+/* We require TLS support in the tools.  */
+#ifndef HAVE_TLS_SUPPORT
+# error "TLS support is required."
+#endif
+
+/* Signal that TLS support is available.  */
+#define USE_TLS	1
+
+#ifndef __ASSEMBLER__
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE	sizeof (tcbhead_t)
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN	__alignof__ (tcbhead_t)
+
+/* This is the size of the TCB.  */
+# define TLS_TCB_SIZE		sizeof (tcbhead_t)
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (struct pthread)
+
+/* This is the size we need before TCB */
+# define TLS_PRE_TCB_SIZE	sizeof (struct pthread)
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  ((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  ({ tcbhead_t *__tcbp = (tcbhead_t *)__get_cr27();	\
+   	__tcbp->dtv = dtv;				\
+   })
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+# define TLS_INIT_TP(tcbp, secondcall) \
+  ({ __set_cr27(tcbp); NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  ({ tcbhead_t *__tcbp = (tcbhead_t *)__get_cr27();	\
+   	__tcbp->dtv;					\
+   })
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+  ({ struct pthread *__self;			\
+	__self = __get_cr27();			\
+   	__self - 1;				\
+   })
+
+/* FIXME */
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  REGISTER (32, 32, 32 * 4, -sizeof (struct pthread))
+
+/* Access to data in the thread descriptor is easy.  */
+# define THREAD_GETMEM(descr, member) \
+  descr->member
+# define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+# define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+# define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+static inline struct pthread *__get_cr27(void)
+{
+  long cr27;
+  asm ("mfctl %%cr27, %0" : "=r" (cr27) : );
+  return (struct pthread *) cr27;
+}
+
+static inline void __set_cr27(struct pthread *cr27)
+{
+  asm ( "ble	0xe0(%%sr2, %%r0)\n\t"
+	"copy	%0, %%r26"
+	: : "r" (cr27) : "r26" );
+}
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/sysdep.h ports/sysdeps/hppa/sysdep.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/sysdep.h	2003-10-15 07:31:42.000000000 +0200
+++ ports/sysdeps/hppa/sysdep.h	2006-05-15 01:54:47.000000000 +0200
@@ -22,9 +22,8 @@
 #include <sys/syscall.h>
 #include "config.h"
 
-#ifndef ASM_LINE_SEP
-#define ASM_LINE_SEP ;
-#endif
+#undef ASM_LINE_SEP
+#define ASM_LINE_SEP ! 
 
 #ifdef	__ASSEMBLER__
 
@@ -51,13 +50,9 @@
 #define END(name)							      \
   .PROCEND
 
-
-/* If compiled for profiling, call `mcount' at the start of each function.  */
+/* GCC does everything for us. */
 #ifdef	PROF
-/* The mcount code relies on a normal frame pointer being on the stack
-   to locate our caller, so push one just for its benefit.  */
-#define CALL_MCOUNT \
-  XXX	ASM_LINE_SEP
+#define CALL_MCOUNT 
 #else
 #define CALL_MCOUNT		/* Do nothing.  */
 #endif
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/tls-macros.h ports/sysdeps/hppa/tls-macros.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/tls-macros.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/tls-macros.h	2006-07-16 20:31:20.000000000 +0200
@@ -0,0 +1,115 @@
+/* TLS Access Macros for HP PARISC Linux */
+
+/* HPPA Local Exec TLS access.  */
+#define TLS_LE(x) \
+  ({  int * __result;  \
+      unsigned long __tmp; \
+      asm ( \
+	"  mfctl %%cr27, %1\n" \
+	"  addil LR'" #x "-$tls_leoff$, %1\n" \
+	"  ldo RR'" #x "-$tls_leoff$(%%r1), %0\n" \
+        : "=r" (__result), "=r" (__tmp) \
+	: \
+	: "r1" );  \
+      __result;  \
+  })
+
+/* HPPA Initial Exec TLS access.  */
+#ifdef PIC
+#  define TLS_IE(x) \
+  ({  int * __result;  \
+      unsigned long __tmp, __tmp2; \
+      asm ( \
+	"  mfctl %%cr27, %1\n" \
+	"  addil LT'" #x "-$tls_ieoff$, %%r19\n" \
+	"  ldw RT'" #x "-$tls_ieoff$(%%r1), %2\n" \
+	"  add %1, %2, %0\n" \
+	: "=r" (__result), "=r" (__tmp), "=r" (__tmp2) \
+	: \
+	: "r1" ); \
+      __result;  \
+  })
+#else
+#  define TLS_IE(x) \
+  ({  int * __result;  \
+      unsigned long __tmp, __tmp2; \
+      asm ( \
+	"  mfctl %%cr27, %1\n" \
+	"  addil LR'" #x "-$tls_ieoff$, %%r27\n" \
+	"  ldw RR'" #x "-$tls_ieoff$(%%r1), %2\n" \
+	"  add %1, %2, %0\n" \
+	: "=r" (__result), "=r" (__tmp), "=r" (__tmp2) \
+	: \
+	: "r1" ); \
+      __result;  \
+  })
+#endif
+
+#ifdef PIC
+/* HPPA Local Dynamic TLS access.  */
+#  define TLS_LD(x) \
+  ({  int * __result;  \
+      asm (  \
+	"  copy %%r19, %%r4\n" \
+	"  addil LT'" #x "-$tls_ldidx$, %%r19\n" \
+	"  bl __tls_get_addr, %%r2\n" \
+	"  ldo RT'" #x "-$tls_ldidx$(%%r1), %%r26\n" \
+	"  addil LR'" #x "-$tls_dtpoff$, %%r28\n" \
+	"  ldo RR'" #x "-$tls_dtpoff$(%%r1), %0\n" \
+	"  copy %%r4, %%r19\n" \
+	: "=r" (__result) \
+	: \
+	: "r1", "r2", "r4", "r20", "r21", "r22", "r23", "r24", \
+	  "r25", "r26", "r28", "r29", "r31" ); \
+      __result;  \
+  })
+#else
+#  define TLS_LD(x) \
+  ({  int * __result;  \
+      asm (  \
+	"  addil LR'" #x "-$tls_ldidx$, %%r27\n" \
+	"  bl __tls_get_addr, %%r2\n" \
+	"  ldo RR'" #x "-$tls_ldidx$(%%r1), %%r26\n" \
+	"  addil LR'" #x "-$tls_dtpoff$, %%r28\n" \
+	"  ldo RR'" #x "-$tls_dtpoff$(%%r1), %0\n" \
+	: "=r" (__result) \
+	: \
+	: "r1", "r2", "r20", "r21", "r22", "r23", "r24", \
+	  "r25", "r26", "r28", "r29", "r31" ); \
+      __result;  \
+  })
+#endif
+
+/* HPPA General Dynamic TLS access.  */
+#ifdef PIC
+#  define TLS_GD(x) \
+  ({  int * __result;  \
+      asm (  \
+	"  copy %%r19, %%r4\n" \
+        "  addil LT'" #x "-$tls_gdidx$, %%r19\n" \
+	"  bl __tls_get_addr, %%r2\n" \
+	"  ldo RT'" #x "-$tls_gdidx$(%%r1), %%r26\n" \
+	"  copy %%r28, %0\n" \
+	"  copy %%r4, %%r19\n" \
+	: "=r" (__result) \
+	: \
+	: "r1", "r2", "r4", "r20", "r21", "r22", "r23", "r24", \
+	  "r25", "r26", "r28", "r29", "r31" ); \
+      __result;  \
+  })
+#else
+#  define TLS_GD(x) \
+  ({  int * __result;  \
+      asm (  \
+        "  addil LR'" #x "-$tls_gdidx$, %%r27\n" \
+	"  bl __tls_get_addr, %%r2\n" \
+	"  ldo RR'" #x "-$tls_gdidx$(%%r1), %%r26\n" \
+	"  copy %%r28, %0\n" \
+	: "=r" (__result) \
+	: \
+	: "r1", "r2", "r20", "r21", "r22", "r23", "r24", \
+	  "r25", "r26", "r28", "r29", "r31" ); \
+      __result;  \
+  })
+#endif
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/tst-audit.h ports/sysdeps/hppa/tst-audit.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/hppa/tst-audit.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/hppa/tst-audit.h	2006-07-16 20:31:20.000000000 +0200
@@ -0,0 +1,26 @@
+/* Definitions for testing PLT entry/exit auditing.  HP-PARISC version.
+
+   Copyright (C) 2006 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define pltenter la_hppa_gnu_pltenter
+#define pltexit la_hppa_gnu_pltexit
+#define La_regs La_hppa_regs
+#define La_retval La_hppa_retval
+#define int_retval lrv_r28
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/fpu/feholdexcpt.c ports/sysdeps/mips/fpu/feholdexcpt.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/fpu/feholdexcpt.c	2001-07-06 06:56:01.000000000 +0200
+++ ports/sysdeps/mips/fpu/feholdexcpt.c	2006-06-02 17:06:07.000000000 +0200
@@ -36,3 +36,5 @@
 
   return 0;
 }
+
+libm_hidden_def (feholdexcept)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/fpu/fesetround.c ports/sysdeps/mips/fpu/fesetround.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/fpu/fesetround.c	2001-07-06 06:56:01.000000000 +0200
+++ ports/sysdeps/mips/fpu/fesetround.c	2006-06-02 17:06:07.000000000 +0200
@@ -41,3 +41,5 @@
 
   return 0;
 }
+
+libm_hidden_def (fesetround)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/ldsodefs.h ports/sysdeps/mips/ldsodefs.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/ldsodefs.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/mips/ldsodefs.h	2006-05-08 21:19:56.000000000 +0200
@@ -0,0 +1,66 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __LDSODEFS_H \
+#define _MIPS_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_mips_32_regs;
+struct La_mips_32_retval;
+struct La_mips_64_regs;
+struct La_mips_64_retval;
+
+#define ARCH_PLTENTER_MEMBERS						    \
+    Elf32_Addr (*mips_o32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_32_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf32_Addr (*mips_n32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf64_Addr (*mips_n64_gnu_pltenter) (Elf64_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS						    \
+    unsigned int (*mips_o32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_32_regs *,   \
+					  struct La_mips_32_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n64_gnu_pltexit) (Elf64_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);
+
+#include_next <ldsodefs.h>
+
+#endif
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/Makefile ports/sysdeps/mips/Makefile
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/Makefile	2004-12-20 09:34:03.000000000 +0100
+++ ports/sysdeps/mips/Makefile	2006-06-02 17:09:39.000000000 +0200
@@ -10,3 +10,5 @@
 ifeq ($(subdir),rt)
 librt-sysdep_routines += rt-sysdep
 endif
+
+ASFLAGS-.os += $(pic-ccflag)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/mips64/n32/libm-test-ulps ports/sysdeps/mips/mips64/n32/libm-test-ulps
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/mips64/n32/libm-test-ulps	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/mips/mips64/n32/libm-test-ulps	2006-07-24 17:51:49.000000000 +0200
@@ -0,0 +1,1245 @@
+# Begin of automatic generation
+
+# atan2
+Test "atan2 (-0.00756827042671106339, -.001792735857538728036) == -1.80338464113663849327153994379639112":
+ildouble: 1
+ldouble: 1
+Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# atanh
+Test "atanh (0.75) == 0.972955074527656652552676371721589865":
+float: 1
+ifloat: 1
+
+# cacos
+Test "Imaginary part of: cacos (0.75 + 1.25 i) == 1.11752014915610270578240049553777969 - 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+
+# cacosh
+Test "Imaginary part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# casin
+Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+
+# casinh
+Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# catan
+Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
+ildouble: 1
+ldouble: 1
+
+# catanh
+Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+double: 4
+idouble: 4
+Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+ildouble: 1
+ldouble: 1
+
+# cbrt
+Test "cbrt (-0.001) == -0.1":
+ildouble: 1
+ldouble: 1
+Test "cbrt (-27.0) == -3.0":
+double: 1
+idouble: 1
+Test "cbrt (0.75) == 0.908560296416069829445605878163630251":
+double: 1
+idouble: 1
+Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
+double: 1
+idouble: 1
+
+# ccos
+Test "Real part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+float: 1
+ifloat: 1
+
+# ccosh
+Test "Real part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+float: 1
+ifloat: 1
+
+# cexp
+Test "Real part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+ildouble: 1
+ldouble: 1
+
+# clog
+Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# clog10
+Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + inf i) == inf + 3/4 pi*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# cos
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cpow
+Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 4
+ldouble: 4
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+ildouble: 10
+ldouble: 10
+Test "Real part of: cpow (2 + 0 i, 10 + 0 i) == 1024.0 + 0.0 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+float: 2
+ifloat: 2
+Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# csin
+Test "Imaginary part of: csin (-2 - 3 i) == -9.15449914691142957346729954460983256 + 4.16890695996656435075481305885375484 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 + 1.25 i) == 1.28722291002649188575873510790565441 + 1.17210635989270256101081285116138863 i":
+ildouble: 1
+ldouble: 1
+
+# csinh
+Test "Real part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+double: 1
+idouble: 1
+Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+
+# csqrt
+Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0.75 + 1.25 i) == 1.05065169626078392338656675760808326 + 0.594868882070379067881984030639932657 i":
+ildouble: 1
+ldouble: 1
+
+# ctan
+Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+
+# ctanh
+Test "Real part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
+float: 1
+ifloat: 1
+Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+double: 1
+idouble: 1
+
+# erf
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+idouble: 1
+
+# erfc
+Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
+double: 1
+idouble: 1
+Test "erfc (27.0) == 0.523704892378925568501606768284954709e-318":
+ildouble: 1
+ldouble: 1
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+idouble: 1
+
+# exp10
+Test "exp10 (-1) == 0.1":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "exp10 (3) == 1000":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# exp2
+Test "exp2 (10) == 1024":
+ildouble: 2
+ldouble: 2
+
+# expm1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+idouble: 1
+Test "expm1 (1) == M_El - 1.0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# gamma
+Test "gamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+
+# hypot
+Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+
+# j0
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "j0 (2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# j1
+Test "j1 (-1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "j1 (1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (0, 2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (1, -1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+Test "jn (10, -1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+ildouble: 2
+ldouble: 2
+Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
+float: 4
+ifloat: 4
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# lgamma
+Test "lgamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "log10 (e) == log10(e)":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# log1p
+Test "log1p (-0.25) == -0.287682072451780927439219005993827432":
+float: 1
+ifloat: 1
+
+# log2
+Test "log2 (0.75) == -.415037499278843818546261056052183492":
+ildouble: 1
+ldouble: 1
+
+# sincos
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
+float: 1
+ifloat: 1
+
+# sqrt
+Test "sqrt (2) == M_SQRT2l":
+ildouble: 1
+ldouble: 1
+
+# tanh
+Test "tanh (-0.75) == -0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (-1.0) == -0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+Test "tanh (0.75) == 0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (1.0) == 0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+
+# tgamma
+Test "tgamma (-0.5) == -2 sqrt (pi)":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tgamma (0.5) == sqrt (pi)":
+float: 1
+ifloat: 1
+Test "tgamma (0.7) == 1.29805533264755778568117117915281162":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "tgamma (4) == 6":
+ildouble: 1
+ldouble: 1
+
+# y0
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+# y1
+Test "y1 (0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "y1 (0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "y1 (1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# yn
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (1, 0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "yn (1, 0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "yn (1, 1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "yn (10, 0.125) == -127057845771019398.252538486899753195":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 2
+idouble: 2
+ildouble: 2
+ldouble: 2
+Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
+double: 1
+idouble: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+idouble: 1
+
+# Maximal error of functions:
+Function: "atan2":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "atanh":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "cacos":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cacosh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "casin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casinh":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+
+Function: Imaginary part of "casinh":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "catanh":
+double: 4
+idouble: 4
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "catanh":
+ildouble: 1
+ldouble: 1
+
+Function: "cbrt":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccos":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccosh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cexp":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cexp":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog10":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "clog10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "cos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cpow":
+double: 2
+float: 4
+idouble: 2
+ifloat: 4
+ildouble: 10
+ldouble: 10
+
+Function: Imaginary part of "cpow":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csinh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "csqrt":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csqrt":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ctan":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctan":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+
+Function: Real part of "ctanh":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctanh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "erf":
+double: 1
+idouble: 1
+
+Function: "erfc":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: "exp10":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "exp2":
+ildouble: 2
+ldouble: 2
+
+Function: "expm1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "gamma":
+ildouble: 1
+ldouble: 1
+
+Function: "hypot":
+float: 1
+ifloat: 1
+
+Function: "j0":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+
+Function: "j1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 4
+ldouble: 4
+
+Function: "jn":
+double: 4
+float: 4
+idouble: 4
+ifloat: 4
+ildouble: 4
+ldouble: 4
+
+Function: "lgamma":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log10":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log1p":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "log2":
+ildouble: 1
+ldouble: 1
+
+Function: "sincos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sqrt":
+ildouble: 1
+ldouble: 1
+
+Function: "tan":
+double: 1
+idouble: 1
+
+Function: "tanh":
+ildouble: 1
+ldouble: 1
+
+Function: "tgamma":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "y0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: "y1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "yn":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 5
+ldouble: 5
+
+# end of automatic generation
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/mips64/n64/libm-test-ulps ports/sysdeps/mips/mips64/n64/libm-test-ulps
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/mips64/n64/libm-test-ulps	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/mips/mips64/n64/libm-test-ulps	2006-07-24 17:51:50.000000000 +0200
@@ -0,0 +1,1245 @@
+# Begin of automatic generation
+
+# atan2
+Test "atan2 (-0.00756827042671106339, -.001792735857538728036) == -1.80338464113663849327153994379639112":
+ildouble: 1
+ldouble: 1
+Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# atanh
+Test "atanh (0.75) == 0.972955074527656652552676371721589865":
+float: 1
+ifloat: 1
+
+# cacos
+Test "Imaginary part of: cacos (0.75 + 1.25 i) == 1.11752014915610270578240049553777969 - 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+
+# cacosh
+Test "Imaginary part of: cacosh (-2 - 3 i) == 1.9833870299165354323470769028940395 - 2.1414491111159960199416055713254211 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# casin
+Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+ildouble: 1
+ldouble: 1
+
+# casinh
+Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# catan
+Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
+ildouble: 1
+ldouble: 1
+
+# catanh
+Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+double: 4
+idouble: 4
+Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+ildouble: 1
+ldouble: 1
+
+# cbrt
+Test "cbrt (-0.001) == -0.1":
+ildouble: 1
+ldouble: 1
+Test "cbrt (-27.0) == -3.0":
+double: 1
+idouble: 1
+Test "cbrt (0.75) == 0.908560296416069829445605878163630251":
+double: 1
+idouble: 1
+Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
+double: 1
+idouble: 1
+
+# ccos
+Test "Real part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.18962569096880723013255501961597373 - 9.10922789375533659797919726277886212 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+float: 1
+ifloat: 1
+
+# ccosh
+Test "Real part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.72454550491532256547397070325597253 + 0.511822569987384608834463849801875634 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+float: 1
+ifloat: 1
+
+# cexp
+Test "Real part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+ildouble: 1
+ldouble: 1
+
+# clog
+Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# clog10
+Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.556971676153418384603252578971164214 - 0.937554462986374708541507952140189646 i":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + inf i) == inf + 3/4 pi*log10(e) i":
+double: 1
+idouble: 1
+Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# cos
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# cpow
+Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 4
+ldouble: 4
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 2
+ldouble: 2
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 1.0 + 0.0 i) == 0.75 + 1.25 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+ildouble: 10
+ldouble: 10
+Test "Real part of: cpow (2 + 0 i, 10 + 0 i) == 1024.0 + 0.0 i":
+ildouble: 2
+ldouble: 2
+Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+ildouble: 3
+ldouble: 3
+Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+float: 2
+ifloat: 2
+Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# csin
+Test "Imaginary part of: csin (-2 - 3 i) == -9.15449914691142957346729954460983256 + 4.16890695996656435075481305885375484 i":
+ildouble: 1
+ldouble: 1
+Test "Real part of: csin (0.75 + 1.25 i) == 1.28722291002649188575873510790565441 + 1.17210635989270256101081285116138863 i":
+ildouble: 1
+ldouble: 1
+
+# csinh
+Test "Real part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.59056458998577995201256544779481679 - 0.530921086248519805267040090660676560 i":
+double: 1
+idouble: 1
+Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+
+# csqrt
+Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: csqrt (0.75 + 1.25 i) == 1.05065169626078392338656675760808326 + 0.594868882070379067881984030639932657 i":
+ildouble: 1
+ldouble: 1
+
+# ctan
+Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+
+# ctanh
+Test "Real part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (-2 - 3 i) == -0.965385879022133124278480269394560686 + 0.988437503832249372031403430350121098e-2 i":
+ildouble: 1
+ldouble: 1
+Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
+float: 1
+ifloat: 1
+Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+double: 1
+idouble: 1
+
+# erf
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+idouble: 1
+
+# erfc
+Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
+double: 1
+idouble: 1
+Test "erfc (27.0) == 0.523704892378925568501606768284954709e-318":
+ildouble: 1
+ldouble: 1
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+idouble: 1
+
+# exp10
+Test "exp10 (-1) == 0.1":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "exp10 (3) == 1000":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# exp2
+Test "exp2 (10) == 1024":
+ildouble: 2
+ldouble: 2
+
+# expm1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+idouble: 1
+Test "expm1 (1) == M_El - 1.0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# gamma
+Test "gamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+
+# hypot
+Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+
+# j0
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "j0 (2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# j1
+Test "j1 (-1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "j1 (1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 0.75) == 0.864242275166648623555731103820923211":
+float: 1
+ifloat: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (0, 2.0) == 0.223890779141235668051827454649948626":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (1, -1.0) == -0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 0.75) == 0.349243602174862192523281016426251335":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 1.0) == 0.440050585744933515959682203718914913":
+ildouble: 1
+ldouble: 1
+Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+ildouble: 4
+ldouble: 4
+Test "jn (10, -1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "jn (10, 1.0) == 0.263061512368745320699785368779050294e-9":
+ildouble: 1
+ldouble: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+double: 4
+float: 3
+idouble: 4
+ifloat: 3
+ildouble: 2
+ldouble: 2
+Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
+float: 4
+ifloat: 4
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# lgamma
+Test "lgamma (-0.5) == log(2*sqrt(pi))":
+ildouble: 1
+ldouble: 1
+Test "lgamma (0.7) == 0.260867246531666514385732417016759578":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "lgamma (1.2) == -0.853740900033158497197028392998854470e-1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "log10 (e) == log10(e)":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+# log1p
+Test "log1p (-0.25) == -0.287682072451780927439219005993827432":
+float: 1
+ifloat: 1
+
+# log2
+Test "log2 (0.75) == -.415037499278843818546261056052183492":
+ildouble: 1
+ldouble: 1
+
+# sincos
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
+float: 1
+ifloat: 1
+
+# sqrt
+Test "sqrt (2) == M_SQRT2l":
+ildouble: 1
+ldouble: 1
+
+# tanh
+Test "tanh (-0.75) == -0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (-1.0) == -0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+Test "tanh (0.75) == 0.635148952387287319214434357312496495":
+ildouble: 1
+ldouble: 1
+Test "tanh (1.0) == 0.7615941559557648881194582826047935904":
+ildouble: 1
+ldouble: 1
+
+# tgamma
+Test "tgamma (-0.5) == -2 sqrt (pi)":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "tgamma (0.5) == sqrt (pi)":
+float: 1
+ifloat: 1
+Test "tgamma (0.7) == 1.29805533264755778568117117915281162":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "tgamma (4) == 6":
+ildouble: 1
+ldouble: 1
+
+# y0
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+# y1
+Test "y1 (0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "y1 (0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "y1 (1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+# yn
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
+float: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 3
+ldouble: 3
+Test "yn (1, 0.125) == -5.19993611253477499595928744876579921":
+double: 1
+idouble: 1
+Test "yn (1, 0.75) == -1.03759455076928541973767132140642198":
+ildouble: 1
+ldouble: 1
+Test "yn (1, 1.5) == -0.412308626973911295952829820633445323":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+Test "yn (10, 0.125) == -127057845771019398.252538486899753195":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 5
+ldouble: 5
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 2
+idouble: 2
+ildouble: 2
+ldouble: 2
+Test "yn (3, 0.125) == -2612.69757350066712600220955744091741":
+double: 1
+idouble: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 2
+ldouble: 2
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+idouble: 1
+
+# Maximal error of functions:
+Function: "atan2":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "atanh":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "cacos":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cacosh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "casin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "casinh":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+ildouble: 4
+ldouble: 4
+
+Function: Imaginary part of "casinh":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+ildouble: 2
+ldouble: 2
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "catanh":
+double: 4
+idouble: 4
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "catanh":
+ildouble: 1
+ldouble: 1
+
+Function: "cbrt":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccos":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ccosh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cexp":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "cexp":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "clog10":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "clog10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "cos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "cpow":
+double: 2
+float: 4
+idouble: 2
+ifloat: 4
+ildouble: 10
+ldouble: 10
+
+Function: Imaginary part of "cpow":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csin":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "csinh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "csqrt":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "csqrt":
+ildouble: 1
+ldouble: 1
+
+Function: Real part of "ctan":
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctan":
+double: 1
+idouble: 1
+ildouble: 2
+ldouble: 2
+
+Function: Real part of "ctanh":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: Imaginary part of "ctanh":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "erf":
+double: 1
+idouble: 1
+
+Function: "erfc":
+double: 1
+idouble: 1
+ildouble: 1
+ldouble: 1
+
+Function: "exp10":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "exp2":
+ildouble: 2
+ldouble: 2
+
+Function: "expm1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "gamma":
+ildouble: 1
+ldouble: 1
+
+Function: "hypot":
+float: 1
+ifloat: 1
+
+Function: "j0":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+ildouble: 2
+ldouble: 2
+
+Function: "j1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 4
+ldouble: 4
+
+Function: "jn":
+double: 4
+float: 4
+idouble: 4
+ifloat: 4
+ildouble: 4
+ldouble: 4
+
+Function: "lgamma":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log10":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "log1p":
+float: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "log2":
+ildouble: 1
+ldouble: 1
+
+Function: "sincos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "sqrt":
+ildouble: 1
+ldouble: 1
+
+Function: "tan":
+double: 1
+idouble: 1
+
+Function: "tanh":
+ildouble: 1
+ldouble: 1
+
+Function: "tgamma":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+ildouble: 1
+ldouble: 1
+
+Function: "y0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+ildouble: 3
+ldouble: 3
+
+Function: "y1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 1
+ldouble: 1
+
+Function: "yn":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+ildouble: 5
+ldouble: 5
+
+# end of automatic generation
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/tst-audit.h ports/sysdeps/mips/tst-audit.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/mips/tst-audit.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/mips/tst-audit.h	2006-05-08 21:19:56.000000000 +0200
@@ -0,0 +1,40 @@
+/* Definitions for testing PLT entry/exit auditing.  ARM version.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sgidefs.h>
+
+#if _MIPS_SIM == _ABIO32
+#define pltenter la_mips_o32_gnu_pltenter
+#define pltexit la_mips_o32_gnu_pltexit
+#define La_regs La_mips_32_regs
+#define La_retval La_mips_32_retval
+#else
+#if _MIPS_SIM == _ABIN32
+#define pltenter la_mips_n32_gnu_pltenter
+#define pltexit la_mips_n32_gnu_pltexit
+#else
+#define pltenter la_mips_n64_gnu_pltenter
+#define pltexit la_mips_n64_gnu_pltexit
+#endif
+#define La_regs La_mips_64_regs
+#define La_retval La_mips_64_retval
+#endif
+#define int_retval lrv_v0
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/bits/fcntl.h ports/sysdeps/unix/sysv/linux/arm/bits/fcntl.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/bits/fcntl.h	2004-08-23 09:28:44.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/arm/bits/fcntl.h	2006-06-08 19:16:08.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 1995-1998, 2000, 2004 Free Software Foundation, Inc.
+   Copyright (C) 1995-1998, 2000, 2004, 2006 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,35 +21,34 @@
 # error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
 #endif
 
-
 #include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
 
 /* open/fcntl - O_SYNC is only implemented on blocks devices and on files
    located on an ext2 file system */
-#define O_ACCMODE	  0003
-#define O_RDONLY	    00
-#define O_WRONLY	    01
-#define O_RDWR		    02
-#define O_CREAT		  0100	/* not fcntl */
-#define O_EXCL		  0200	/* not fcntl */
-#define O_NOCTTY	  0400	/* not fcntl */
-#define O_TRUNC		 01000	/* not fcntl */
-#define O_APPEND	 02000
-#define O_NONBLOCK	 04000
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
 #define O_NDELAY	O_NONBLOCK
-#define O_SYNC		010000
-#define O_FSYNC		O_SYNC
-#define O_ASYNC		020000
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
 
 #ifdef __USE_GNU
-# define O_DIRECTORY	040000	/* Must be a directory.	 */
+# define O_DIRECTORY	 040000	/* Must be a directory.	 */
 # define O_NOFOLLOW	0100000	/* Do not follow links.	 */
 # define O_DIRECT	0200000	/* Direct disk access.	*/
-# define O_NOATIME	01000000 /* Do not set atime.  */
-#endif
-
-#ifdef __USE_LARGEFILE64
-# define O_LARGEFILE	0400000
+# define O_NOATIME     01000000 /* Do not set atime.  */
 #endif
 
 /* For now Linux has synchronisity options for data and read operations.
@@ -60,13 +59,16 @@
 # define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
 #endif
 
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0400000
+#endif
+
 /* Values for the second argument to `fcntl'.  */
 #define F_DUPFD		0	/* Duplicate file descriptor.  */
 #define F_GETFD		1	/* Get file descriptor flags.  */
 #define F_SETFD		2	/* Set file descriptor flags.  */
 #define F_GETFL		3	/* Get file status flags.  */
 #define F_SETFL		4	/* Set file status flags.  */
-
 #ifndef __USE_FILE_OFFSET64
 # define F_GETLK	5	/* Get record locking info.  */
 # define F_SETLK	6	/* Set record locking info (non-blocking).  */
@@ -104,12 +106,12 @@
 #define F_WRLCK		1	/* Write lock.	*/
 #define F_UNLCK		2	/* Remove lock.	 */
 
-/* for old implementation of bsd flock () */
+/* For old implementation of bsd flock().  */
 #define F_EXLCK		4	/* or 3 */
 #define F_SHLCK		8	/* or 4 */
 
 #ifdef __USE_BSD
-/* Operations for bsd flock(), also used by the kernel implementation */
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
 # define LOCK_SH	1	/* shared lock */
 # define LOCK_EX	2	/* exclusive lock */
 # define LOCK_NB	4	/* or'd with one of the above to prevent
@@ -180,10 +182,54 @@
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
 
+
+#ifdef __USE_GNU
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
 __BEGIN_DECLS
 
+#ifdef __USE_GNU
+
 /* Provide kernel hint to read ahead.  */
 extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
     __THROW;
 
+
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+
+/* Splice address range into a pipe.  */
+extern int vmsplice (int __fdout, const struct iovec *__iov, size_t __count,
+		     unsigned int __flags);
+
+/* Splice two files together.  */
+extern int splice (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern int tee (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+
+#endif
+
 __END_DECLS
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/bits/mman.h ports/sysdeps/unix/sysv/linux/arm/bits/mman.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/bits/mman.h	2005-10-31 21:41:32.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/bits/mman.h	2006-05-05 16:17:13.000000000 +0200
@@ -1,5 +1,5 @@
 /* Definitions for POSIX memory map interface.  Linux/ARM version.
-   Copyright (C) 1997, 2000, 2003, 2005 Free Software Foundation, Inc.
+   Copyright (C) 1997, 2000, 2003, 2005, 2006 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,7 +18,7 @@
    02111-1307 USA.  */
 
 #ifndef _SYS_MMAN_H
-# error "Never include this file directly.  Use <sys/mman.h> instead"
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
 #endif
 
 /* The following definitions basically come from the kernel headers.
@@ -88,6 +88,9 @@
 # define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
 # define MADV_WILLNEED	 3	/* Will need these pages.  */
 # define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_REMOVE	 9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	 11	/* Do inherit across fork.  */
 #endif
 
 /* The POSIX people had to invent similar names for the same things.  */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/linuxthreads/sysdep-cancel.h ports/sysdeps/unix/sysv/linux/arm/eabi/linuxthreads/sysdep-cancel.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/linuxthreads/sysdep-cancel.h	2005-11-16 19:08:53.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/eabi/linuxthreads/sysdep-cancel.h	2006-03-21 21:54:56.000000000 +0100
@@ -53,9 +53,9 @@
     UNDOARGS_##args;							\
     cmn r0, $4096;
 
-/* DOARGS pushes four bytes on the stack for five arguments, and nothing
-   otherwise.  In order to preserve doubleword alignment, sometimes we must
-   save an extra register.  */
+/* DOARGS pushes four bytes on the stack for five arguments, eight bytes for
+   six arguments, and nothing for fewer.  In order to preserve doubleword
+   alignment, sometimes we must save an extra register.  */
 
 # define DOCARGS_0	stmfd sp!, {r7, lr}
 # define UNDOCARGS_0
@@ -81,6 +81,10 @@
 # define UNDOCARGS_5	ldmfd sp!, {r0, r1, r2, r3}
 # define RESTORE_LR_5	ldmfd sp!, {r4, r7, lr}
 
+# define DOCARGS_6	stmfd sp!, {r0, r1, r2, r3, r7, lr}
+# define UNDOCARGS_6	ldmfd sp!, {r0, r1, r2, r3}
+# define RESTORE_LR_6	RESTORE_LR_0
+
 # ifdef IS_IN_libpthread
 #  define CENABLE	bl PLTJMP(__pthread_enable_asynccancel)
 #  define CDISABLE	bl PLTJMP(__pthread_disable_asynccancel)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/nptl/sysdep-cancel.h ports/sysdeps/unix/sysv/linux/arm/eabi/nptl/sysdep-cancel.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/nptl/sysdep-cancel.h	2005-11-16 20:03:42.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/eabi/nptl/sysdep-cancel.h	2006-03-21 21:54:56.000000000 +0100
@@ -64,9 +64,9 @@
     UNDOARGS_##args;							\
     cmn r0, $4096;
 
-/* DOARGS pushes four bytes on the stack for five arguments, and nothing
-   otherwise.  In order to preserve doubleword alignment, sometimes we must
-   save an extra register.  */
+/* DOARGS pushes four bytes on the stack for five arguments, eight bytes for
+   six arguments, and nothing for fewer.  In order to preserve doubleword
+   alignment, sometimes we must save an extra register.  */
 
 # define RESTART_UNWIND .fnend; .fnstart; .save {r7, lr}
 
@@ -94,6 +94,10 @@
 # define UNDOCARGS_5	ldmfd sp!, {r0, r1, r2, r3}; .fnend; .fnstart; .save {r4}; .save {r7, lr}; .pad #4
 # define RESTORE_LR_5	ldmfd sp!, {r4, r7, lr}
 
+# define DOCARGS_6	.save {r4, r5}; stmfd sp!, {r0, r1, r2, r3, r7, lr}; .save {r7, lr}; .pad #20
+# define UNDOCARGS_6	ldmfd sp!, {r0, r1, r2, r3}; .fnend; .fnstart; .save {r4, r5}; .save {r7, lr}
+# define RESTORE_LR_6	RESTORE_LR_0
+
 # ifdef IS_IN_libpthread
 #  define CENABLE	bl PLTJMP(__pthread_enable_asynccancel)
 #  define CDISABLE	bl PLTJMP(__pthread_disable_asynccancel)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/socket.S ports/sysdeps/unix/sysv/linux/arm/eabi/socket.S
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/socket.S	2005-11-16 20:03:42.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/eabi/socket.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-/* Copyright (C) 1995, 1996, 1997, 1998, 2003, 2005
-   Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep-cancel.h>
-#include <socketcall.h>
-
-#define P(a, b) P2(a, b)
-#define P2(a, b) a##b
-
-	.text
-/* The socket-oriented system calls are handled unusally in Linux.
-   They are all gated through the single `socketcall' system call number.
-   `socketcall' takes two arguments: the first is the subcode, specifying
-   which socket function is being called; and the second is a pointer to
-   the arguments to the specific function.
-
-   The .S files for the other calls just #define socket and #include this.  */
-
-#ifndef __socket
-# ifndef NO_WEAK_ALIAS
-#  define __socket P(__,socket)
-# else
-#  define __socket socket
-# endif
-#endif
-
-#define PUSHARGS_1	str a1, [sp, $-8]!; .pad #8
-#define PUSHARGS_2	stmfd sp!, {a1, a2}; .pad #8
-#define PUSHARGS_3	stmfd sp!, {a1, a2, a3, a4}; .pad #16	/* a4 pushed for padding */
-#define PUSHARGS_4	stmfd sp!, {a1, a2, a3, a4}; .pad #16
-#define PUSHARGS_5	stmfd sp!, {a1, a2, a3, a4}; .pad #16	/* Caller has already pushed arg 5 */
-#define PUSHARGS_6	stmfd sp!, {a1, a2, a3, a4}; .pad #16
-
-#define POPARGS_1	add sp, sp, #8
-#define POPARGS_2	add sp, sp, #8
-#define POPARGS_3	add sp, sp, #16
-#define POPARGS_4	add sp, sp, #16
-#define POPARGS_5	add sp, sp, #16
-#define POPARGS_6	add sp, sp, #16
-
-#ifndef NARGS
-#define NARGS 3			/* If we were called with no wrapper, this is really socket() */
-#endif
-
-#if defined NEED_CANCELLATION && defined CENABLE
-	PSEUDO_PROLOGUE
-#endif
-
-.globl __socket
-ENTRY (__socket)
-	.fnstart
-
-	/* This code previously moved sp into ip and stored the args using
-	   stmdb ip!, {a1-a4}.  It did not modify sp, so the stack never had
-	   to be restored after the syscall completed.  It saved an
-	   instruction and meant no stack cleanup work was required.
-
-	   This will not work in the case of a socket call being interrupted
-	   by a signal.  If the signal handler uses any stack the arguments
-	   to socket will be trashed.  The results of a restart of any
-	   socket call are then unpredictable. */
-
-	/* Push args onto the stack.  */
-	P(PUSHARGS_,NARGS)
-
-#if defined NEED_CANCELLATION && defined CENABLE
-	SINGLE_THREAD_P
-	bne 1f
-#endif
-
-        /* Do the system call trap.  */
-	mov a1, $P(SOCKOP_,socket)
-	mov a2, sp
-	DO_CALL (socketcall, 0)
-
-	/* Pop args off the stack */
-	P(POPARGS_,NARGS)
-
-	/* r0 is < 0 if there was an error.  */
-	cmn r0, $124
-	RETINSTR(cc, r14)
-	b PLTJMP(SYSCALL_ERROR)
-
-#if defined NEED_CANCELLATION && defined CENABLE
-1:
-	stmfd sp!, {r7, lr}
-	.save {r7, lr}
-	CENABLE
-	mov ip, r0
-
-	mov r0, #P(SOCKOP_,socket)
-	add r1, sp, #8
-	mov r7, #SYS_ify(socketcall)
-	swi 0x0
-
-	mov r7, r0
-	mov r0, ip
-	CDISABLE
-	mov r0, r7
-	ldmfd sp!, {r7, lr}
-
-	P(POPARGS_,NARGS)
-
-	/* r0 is < 0 if there was an error.  */
-	cmn r0, $124
-	RETINSTR(cc, r14)
-	b PLTJMP(SYSCALL_ERROR)
-#endif
-
-	.fnend
-PSEUDO_END (__socket)
-
-#ifndef NO_WEAK_ALIAS
-weak_alias (__socket, socket)
-#endif
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/syscalls.list ports/sysdeps/unix/sysv/linux/arm/eabi/syscalls.list
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/syscalls.list	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/eabi/syscalls.list	2006-03-21 21:54:56.000000000 +0100
@@ -0,0 +1,34 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+# semaphore and shm system calls
+msgctl		-	msgctl		i:iip	__msgctl	msgctl
+msgget		-	msgget		i:ii	__msgget	msgget
+msgrcv		-	msgrcv		Ci:ibnii __msgrcv	msgrcv
+msgsnd		-	msgsnd		Ci:ibni	__msgsnd	msgsnd
+shmat		-	shmat		i:ipi	__shmat		shmat
+shmctl		-	shmctl		i:iip	__shmctl	shmctl
+shmdt		-	shmdt		i:s	__shmdt		shmdt
+shmget		-	shmget		i:iii	__shmget	shmget
+semop		-	semop		i:ipi	__semop		semop
+semtimedop	-	semtimedop	i:ipip	semtimedop
+semget		-	semget		i:iii	__semget	semget
+semctl		-	semctl		i:iiii	__semctl	semctl
+
+# proper socket implementations:
+accept		-	accept		Ci:iBN	__libc_accept	__accept accept
+bind		-	bind		i:ipi	__bind		bind
+connect		-	connect		Ci:ipi	__libc_connect	__connect_internal __connect connect
+getpeername	-	getpeername	i:ipp	__getpeername	getpeername
+getsockname	-	getsockname	i:ipp	__getsockname	getsockname
+getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
+listen		-	listen		i:ii	__listen	listen
+recv		-	recv		Ci:ibni	__libc_recv	__recv recv
+recvfrom	-	recvfrom	Ci:ibniBN	__libc_recvfrom	__recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		Ci:ibni	__libc_send	__send send
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn	__libc_sendto	__sendto sendto
+setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
+shutdown	-	shutdown	i:ii	__shutdown	shutdown
+socket		-	socket		i:iii	__socket	socket
+socketpair	-	socketpair	i:iiif	__socketpair	socketpair
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/sysdep.h ports/sysdeps/unix/sysv/linux/arm/eabi/sysdep.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/sysdep.h	2005-11-16 20:03:42.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/eabi/sysdep.h	2006-03-21 21:54:56.000000000 +0100
@@ -1,4 +1,4 @@
-/* Copyright (C) 2005
+/* Copyright (C) 2005, 2006
    Free Software Foundation, Inc.
 
    This file is part of the GNU C Library.
@@ -29,6 +29,12 @@
 # error Kernel headers are too old
 #endif
 
+/* Don't use stime, even if the kernel headers define it.  We have
+   settimeofday, and some EABI kernels have removed stime.  Similarly
+   use setitimer to implement alarm.  */
+#undef __NR_stime
+#undef __NR_alarm
+
 /* The ARM EABI user interface passes the syscall number in r7, instead
    of in the swi.  This is more efficient, because the kernel does not need
    to fetch the swi from memory to find out the number; which can be painful
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/umount.c ports/sysdeps/unix/sysv/linux/arm/eabi/umount.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/eabi/umount.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/eabi/umount.c	2006-03-21 21:54:56.000000000 +0100
@@ -0,0 +1,31 @@
+/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by David Huggins-Daines <dhd@debian.org>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Since we don't have an oldumount system call, do what the kernel
+   does down here.  */
+
+extern long int __umount2 (const char *name, int flags);
+
+long int
+__umount (const char *name)
+{
+  return __umount2 (name, 0);
+}
+
+weak_alias (__umount, umount);
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/kernel-features.h ports/sysdeps/unix/sysv/linux/arm/kernel-features.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/kernel-features.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/kernel-features.h	2006-05-30 17:12:30.000000000 +0200
@@ -0,0 +1,49 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* The utimes syscall was added before 2.6.1.  */
+#if __LINUX_KERNEL_VERSION >= 132609
+# define __ASSUME_UTIMES	1
+#endif
+
+/* The new getrlimit syscall was added sometime before 2.4.6.  */
+#if __LINUX_KERNEL_VERSION >= 132102
+#define __ASSUME_NEW_GETRLIMIT_SYSCALL	1
+#endif
+
+/* On ARM the truncate64/ftruncate64/mmap2/stat64/lstat64/fstat64
+   syscalls were introduced in 2.3.35.  */
+#if __LINUX_KERNEL_VERSION >= 131875
+# define __ASSUME_TRUNCATE64_SYSCALL	1
+# define __ASSUME_MMAP2_SYSCALL		1
+# define __ASSUME_STAT64_SYSCALL	1
+#endif
+
+/* Arm got fcntl64 in 2.4.4.  */
+#if __LINUX_KERNEL_VERSION >= 132100
+# define __ASSUME_FCNTL64		1
+#endif
+
+/* The vfork syscall on arm was definitely available in 2.4.  */
+#if __LINUX_KERNEL_VERSION >= 132097 && defined __i386__
+# define __ASSUME_VFORK_SYSCALL		1
+#endif
+
+#include_next <kernel-features.h>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/sigaction.c ports/sysdeps/unix/sysv/linux/arm/sigaction.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/sigaction.c	2005-11-16 20:03:42.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/arm/sigaction.c	2006-07-24 17:43:02.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2005
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2005, 2006
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -151,6 +151,10 @@
 }
 libc_hidden_def (__libc_sigaction)
 
+#ifdef WRAPPER_INCLUDE
+# include WRAPPER_INCLUDE
+#endif
+
 #ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction)
 libc_hidden_weak (__sigaction)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/sys/ucontext.h ports/sysdeps/unix/sysv/linux/arm/sys/ucontext.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/arm/sys/ucontext.h	2001-07-06 06:56:13.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/arm/sys/ucontext.h	2006-07-05 18:58:01.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 1999, 2001, 2006 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,10 +25,14 @@
 #include <signal.h>
 #include <sys/procfs.h>
 
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
 typedef int greg_t;
 
 /* Number of general registers.  */
-#define NGREG	16
+#define NGREG	18
 
 /* Container for all general registers.  */
 typedef elf_gregset_t gregset_t;
@@ -73,22 +77,21 @@
 /* Structure to describe FPU registers.  */
 typedef elf_fpregset_t	fpregset_t;
 
-/* Context to describe whole processor state.  */
-typedef struct
-  {
-    gregset_t gregs;
-    fpregset_t fpregs;
-  } mcontext_t;
+/* Context to describe whole processor state.  This only describes
+   the core registers; coprocessor registers get saved elsewhere
+   (e.g. in uc_regspace, or somewhere unspecified on the stack
+   during non-RT signal handlers).  */
+typedef struct sigcontext mcontext_t;
 
 /* Userlevel context.  */
 typedef struct ucontext
   {
-    unsigned long int uc_flags;
+    unsigned long uc_flags;
     struct ucontext *uc_link;
-    __sigset_t uc_sigmask;
     stack_t uc_stack;
     mcontext_t uc_mcontext;
-    long int uc_filler[5];
+    __sigset_t uc_sigmask;
+    unsigned long uc_regspace[128] __attribute__((__aligned__(8)));
   } ucontext_t;
 
 #endif /* sys/ucontext.h */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/bits/atomic.h ports/sysdeps/unix/sysv/linux/hppa/bits/atomic.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/bits/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/bits/atomic.h	2006-06-09 03:25:30.000000000 +0200
@@ -0,0 +1,120 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@baldric.uwo.ca>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+#include <sysdep.h>
+#include <abort-instr.h>
+#include <kernel-features.h>
+
+/* We need EFAULT, ENONSYS, and EAGAIN */
+#if !defined EFAULT && !defined ENOSYS && !defined EAGAIN
+#undef EFAULT
+#undef ENOSYS
+#undef EAGAIN
+#define EFAULT	14
+#define ENOSYS	251
+#define EAGAIN	11
+#endif
+
+#ifndef _BITS_ATOMIC_H
+#define _BITS_ATOMIC_H	1
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+/* prev = *addr;
+   if (prev == old)
+     *addr = new;
+   return prev; */
+
+/* Use the kernel atomic light weight syscalls on hppa */ 
+#define LWS "0xb0"
+#define LWS_CAS 0x0
+/* Note r31 is the link register */
+#define LWS_CLOBBER "r1", "r26", "r25", "r24", "r23", "r22", "r21", "r20", "r28", "r31", "memory"
+#define ASM_EAGAIN "11"
+
+#if __ASSUME_LWS_CAS
+/* The only basic operation needed is compare and exchange.  */
+# define atomic_compare_and_exchange_val_acq(mem, newval, oldval) 	\
+  ({									\
+     volatile int lws_errno = EFAULT;					\
+     volatile int lws_ret = 0xdeadbeef;					\
+     asm volatile(							\
+	"0:					\n\t"			\
+	"copy	%3, %%r26			\n\t"			\
+	"copy	%4, %%r25			\n\t"			\
+	"copy	%5, %%r24			\n\t"			\
+	"ble	" LWS "(%%sr2, %%r0)		\n\t"			\
+	"ldi	0, %%r20			\n\t"			\
+	"cmpib,=,n " ASM_EAGAIN ",%%r21,0	\n\t"			\
+	"nop					\n\t"			\
+	"stw	%%r28, %0			\n\t"			\
+        "sub	%%r0, %%r21, %%r21		\n\t"			\
+	"stw	%%r21, %1			\n\t"			\
+	: "=m" (lws_ret), "=m" (lws_errno), "=m" (*mem)			\
+        : "r" (mem), "r" (oldval), "r" (newval)				\
+	: LWS_CLOBBER							\
+     );									\
+    									\
+     if(lws_errno == EFAULT || lws_errno == ENOSYS)			\
+     	ABORT_INSTRUCTION;						\
+    									\
+     lws_ret;								\
+   })
+
+# define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) 	\
+  ({									\
+     int ret;								\
+     ret = atomic_compare_and_exchange_val_acq(mem, newval, oldval);	\
+     /* Return 1 if it was already acquired */				\
+     (ret != oldval);							\
+   })
+#else
+/* Non-atomic primitives. */
+# define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+  ({ __typeof (mem) __gmemp = (mem);				      \
+     __typeof (*mem) __gret = *__gmemp;				      \
+     __typeof (*mem) __gnewval = (newval);			      \
+								      \
+     if (__gret == (oldval))					      \
+       *__gmemp = __gnewval;					      \
+     __gret; })
+
+# define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
+  ({ __typeof (mem) __gmemp = (mem);				      \
+     __typeof (*mem) __gnewval = (newval);			      \
+								      \
+     *__gmemp == (oldval) ? (*__gmemp = __gnewval, 0) : 1; })
+#endif
+
+#endif	/* bits/atomic.h */
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/bits/fcntl.h ports/sysdeps/unix/sysv/linux/hppa/bits/fcntl.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/bits/fcntl.h	2004-08-23 09:28:44.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/hppa/bits/fcntl.h	2006-06-09 02:48:17.000000000 +0200
@@ -23,7 +23,9 @@
 #endif
 
 #include <sys/types.h>
-
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
 
 /* open/fcntl - O_SYNC is only implemented on blocks devices and on files
    located on an ext2 file system */
@@ -44,10 +46,10 @@
 
 
 #ifdef __USE_GNU
-# define O_DIRECT	00040000 /* direct disk access hint - currently ignored */
-# define O_DIRECTORY	00010000 /* must be a directory */
-# define O_NOFOLLOW	00000200 /* don't follow links */
-# define O_NOATIME	04000000 /* Do not set atime.  */
+# define O_DIRECT	00040000 /* Direct disk access. */
+# define O_DIRECTORY	00010000 /* Must be a directory. */
+# define O_NOFOLLOW	00000200 /* Do not follow links. */
+# define O_NOATIME	04000000 /* Do not set atime. */
 #endif
 
 #ifdef __USE_LARGEFILE64
@@ -74,7 +76,6 @@
 # define F_SETLK	F_SETLK64 /* Set record locking info (non-blocking). */
 # define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
 #endif
-
 #define F_GETLK64	8	/* Get record locking info.  */
 #define F_SETLK64	9	/* Set record locking info (non-blocking).  */
 #define F_SETLKW64	10	/* Set record locking info (blocking).  */
@@ -172,10 +173,50 @@
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
 
+#ifdef __USE_GNU
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
 __BEGIN_DECLS
 
+#ifdef __USE_GNU
+
 /* Provide kernel hint to read ahead.  */
 extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
     __THROW;
 
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+/* Splice address range into a pipe.  */
+extern int vmsplice (int __fdout, const struct iovec *__iov, size_t __count,
+		     unsigned int __flags);
+
+/* Splice two files together.  */
+extern int splice (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern int tee (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+    
+#endif
+    
 __END_DECLS
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/bits/mman.h ports/sysdeps/unix/sysv/linux/hppa/bits/mman.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/bits/mman.h	2003-09-25 18:39:38.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/hppa/bits/mman.h	2006-05-24 17:31:25.000000000 +0200
@@ -53,14 +53,20 @@
 #define MCL_CURRENT	1		/* lock all current mappings */
 #define MCL_FUTURE	2		/* lock all future mappings */
 
-#define MADV_NORMAL     0               /* no further special treatment */
-#define MADV_RANDOM     1               /* expect random page references */
-#define MADV_SEQUENTIAL 2               /* expect sequential page references */
-#define MADV_WILLNEED   3               /* will need these pages */
-#define MADV_DONTNEED   4               /* dont need these pages */
-#define MADV_SPACEAVAIL 5               /* insure that resources are reserved */
-#define MADV_VPS_PURGE  6               /* Purge pages from VM page cache */
-#define MADV_VPS_INHERIT 7              /* Inherit parents page size */
+/* Advice to "madvise" */
+#ifdef __USE_BSD
+# define MADV_NORMAL	  0	/* no further special treatment */
+# define MADV_RANDOM	  1	/* expect random page references */
+# define MADV_SEQUENTIAL  2	/* expect sequential page references */
+# define MADV_WILLNEED	  3	/* will need these pages */
+# define MADV_DONTNEED	  4	/* dont need these pages */
+# define MADV_SPACEAVAIL  5	/* insure that resources are reserved */
+# define MADV_VPS_PURGE	  6	/* Purge pages from VM page cache */
+# define MADV_VPS_INHERIT 7	/* Inherit parents page size */
+# define MADV_REMOVE	  9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	 11	/* Do inherit across fork.  */
+#endif
 
 /* The range 12-64 is reserved for page size specification. */
 #define MADV_4K_PAGES   12              /* Use 4K pages  */
@@ -80,4 +86,7 @@
 /* Flags for `mremap'.  */
 #ifdef __USE_GNU
 # define MREMAP_MAYMOVE 1
+# define MREMAP_FIXED	2
 #endif
+
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/clone.S ports/sysdeps/unix/sysv/linux/hppa/clone.S
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/clone.S	2005-05-26 16:30:47.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/hppa/clone.S	2006-05-24 17:33:28.000000000 +0200
@@ -26,35 +26,62 @@
 #define _ERRNO_H	1
 #include <bits/errno.h>
 
-/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg) */
+/* Non-thread code calls __clone with the following parameters:
+   int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg)
+   
+   NPTL Code will call __clone with the following parameters:
+   int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     int *parent_tidptr, struct user_desc *newtls, int *child_pidptr)
+	
+   The code should not mangle the extra input registers.
+   Syscall expects:				Input to __clone:
+	4(r25) - function pointer 		(r26, arg0) 
+	0(r25) - argument			(r23, arg3)
+	r26 - clone flags.			(r24, arg2)
+	r25+64 - user stack pointer.		(r25, arg1)
+	r24 - parent tid pointer.		(stack - 52)
+	r23 - struct user_desc newtls pointer.	(stack - 56)
+	r22 - child tid pointer.		(stack - 60)
+	r20 - clone syscall number		(constant)
+ */
 
         .text
 ENTRY(__clone)
-	/* FIXME: I have no idea how profiling works on hppa. */
 
 	/* Sanity check arguments.  */
-	comib,=  0,%arg0,.Lerror        /* no NULL function pointers */
 	ldi     -EINVAL,%ret0
-	comib,=  0,%arg1,.Lerror        /* no NULL stack pointers */
-	nop
+	comib,=,n  0,%arg0,.Lerror        /* no NULL function pointers */
+	comib,=,n  0,%arg1,.Lerror        /* no NULL stack pointers */
 
 	/* Save the fn ptr and arg on the new stack.  */
-	stwm    %arg0,64(%arg1)
-	stw	%arg3,-60(%arg1)
+	stwm    %r26,64(%r25)
+	stw	%r23,-60(%r25)
+	/* Clone arguments are (int flags, void * child_stack) */
+	copy	%r24,%r26	/* flags are first */
+	/* User stack pointer is in the correct register already */
+
+	/* Load args from stack... */
+	ldw	-52(%sp), %r24	/* Load parent_tidptr */
+	ldw	-56(%sp), %r23 	/* Load newtls */
+	ldw	-60(%sp), %r22	/* Load child_tidptr */
+
+	/* Create frame to get r3 free */
+	copy	%sp, %r21
+	stwm	%r3, 64(%sp)
+	stw	%r21, -4(%sp)
 
 	/* Save the PIC register. */
 #ifdef PIC
-	stw	%r19,-32(%sr0, %sp)	/* parent */
+	copy	%r19, %r3		/* parent */
 #endif
 
 	/* Do the system call */
-	copy	%arg2,%arg0
 	ble     0x100(%sr2,%r0)
 	ldi	__NR_clone,%r20
 
 	ldi	-4096,%r1
 	comclr,>>= %r1,%ret0,%r0	/* Note: unsigned compare. */
-	b,n	.Lerror
+	b,n	.LerrorRest
 
 	comib,=,n 0,%ret0,thread_start
 
@@ -63,18 +90,25 @@
 	   since we return immediately. */
 
 	bv	%r0(%rp)
-	nop
-
-	/* Something bad happened -- no child created */
-.Lerror:
+	ldwm	-64(%sp), %r3
 
+.LerrorRest:
 	/* Restore the PIC register on error */
 #ifdef PIC
-	ldw	-32(%sr0, %sp), %r19	/* parent */
+	copy	%r3, %r19		/* parent */ 
 #endif
 
+	/* Something bad happened -- no child created */
+.Lerror:
+
+	/* Set errno, save ret0 so we return with that value. */
+	copy	%ret0, %r3
 	b	__syscall_error
 	sub     %r0,%ret0,%arg0
+	copy	%r3, %ret0
+	/* Return after setting errno, and restoring ret0 */
+	bv	%r0(%rp)
+	ldwm	-64(%sp), %r3
 
 thread_start:
 
@@ -92,7 +126,7 @@
 	copy	%ret0,%arg0
 
 	/* Die horribly.  */
-	iitlbp	%r0,(%r0)
+	iitlbp	%r0,(%sr0,%r0)
 
 PSEUDO_END(__clone)
 
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/fxstatat.c ports/sysdeps/unix/sysv/linux/hppa/fxstatat.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/fxstatat.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/fxstatat.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstatat.c>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/fxstat.c ports/sysdeps/unix/sysv/linux/hppa/fxstat.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/fxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/fxstat.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstat.c>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/kernel-features.h ports/sysdeps/unix/sysv/linux/hppa/kernel-features.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/kernel-features.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/kernel-features.h	2006-06-09 03:25:30.000000000 +0200
@@ -0,0 +1,39 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* There are an infinite number of PA-RISC kernel versions numbered
+   2.4.0.  But they've not really been released as such.  We require
+   and expect the final version here.  */
+#define __ASSUME_32BITUIDS		1
+#define __ASSUME_TRUNCATE64_SYSCALL	1
+#define __ASSUME_MMAP2_SYSCALL		1
+#define __ASSUME_STAT64_SYSCALL		1
+#define __ASSUME_IPC64			1
+#define __ASSUME_ST_INO_64_BIT		1
+#define __ASSUME_FCNTL64		1
+#define __ASSUME_GETDENTS64_SYSCALL	1
+
+/* PA-RISC 2.6.9 kernels had the first LWS CAS support */
+#if __LINUX_KERNEL_VERSION >= 0x020609
+# define __ASSUME_LWS_CAS		1
+#endif
+
+#include_next <kernel-features.h>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,33 @@
+#include <shlib-compat.h>
+
+#define aio_cancel64 XXX
+#include <aio.h>
+#undef aio_cancel64
+#include <errno.h>
+
+extern __typeof (aio_cancel) __new_aio_cancel;
+extern __typeof (aio_cancel) __old_aio_cancel;
+
+#define aio_cancel	__new_aio_cancel
+
+#include <sysdeps/pthread/aio_cancel.c>
+
+#undef aio_cancel
+strong_alias (__new_aio_cancel, __new_aio_cancel64);
+versioned_symbol (librt, __new_aio_cancel, aio_cancel, GLIBC_2_3);
+versioned_symbol (librt, __new_aio_cancel64, aio_cancel64, GLIBC_2_3);
+
+#if SHLIB_COMPAT (librt, GLIBC_2_1, GLIBC_2_3)
+
+#undef ECANCELED
+#define aio_cancel	__old_aio_cancel
+#define ECANCELED	125
+
+#include <sysdeps/pthread/aio_cancel.c>
+
+#undef aio_cancel
+strong_alias (__old_aio_cancel, __old_aio_cancel64);
+compat_symbol (librt, __old_aio_cancel, aio_cancel, GLIBC_2_1);
+compat_symbol (librt, __old_aio_cancel64, aio_cancel64, GLIBC_2_1);
+
+#endif
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,41 @@
+/* PA-RISC specific definitions for spinlock initializers.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Initial value of a spinlock.  PA-RISC only implements atomic load
+   and clear so this must be non-zero. */
+#define __LT_SPINLOCK_INIT ((__atomic_lock_t) { { 1, 1, 1, 1 } })
+
+/* Initialize global spinlocks without cast, generally macro wrapped */
+#define __LT_SPINLOCK_ALT_INIT { { 1, 1, 1, 1 } }
+
+/* Macros for lock initializers, not using the above definition.
+   The above definition is not used in the case that static initializers
+   use this value. */
+#define __LOCK_ALT_INITIALIZER { __LT_SPINLOCK_ALT_INIT, 0 }
+
+/* Used to initialize _pthread_fastlock's in non-static case */
+#define __LOCK_INITIALIZER ((struct _pthread_fastlock){ __LT_SPINLOCK_INIT, 0 })
+
+/* Used in pthread_atomic initialization */
+#define __ATOMIC_INITIALIZER { 0, __LT_SPINLOCK_ALT_INIT }
+
+/* Tell the rest of the code that the initializer is non-zero without
+   explaining it's internal structure */
+#define __LT_INITIALIZER_NOT_ZERO
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,160 @@
+/* Linuxthreads - a simple clone()-based implementation of Posix        */
+/* threads for Linux.                                                   */
+/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
+/*                                                                      */
+/* This program is free software; you can redistribute it and/or        */
+/* modify it under the terms of the GNU Library General Public License  */
+/* as published by the Free Software Foundation; either version 2       */
+/* of the License, or (at your option) any later version.               */
+/*                                                                      */
+/* This program is distributed in the hope that it will be useful,      */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
+/* GNU Library General Public License for more details.                 */
+
+#if !defined _BITS_TYPES_H && !defined _PTHREAD_H
+# error "Never include <bits/pthreadtypes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#define __need_schedparam
+#include <bits/sched.h>
+
+/* We need 128-bit alignment for the ldcw semaphore.  At most, we are
+   assured of 64-bit alignment for stack locals and malloc'd data.  Thus,
+   we use a struct with four ints for the atomic lock type.  The locking
+   code will figure out which of the four to use for the ldcw semaphore.  */
+typedef volatile struct {
+  int lock[4];
+} __attribute__ ((aligned(16))) __atomic_lock_t;
+
+/* Fast locks (not abstract because mutexes and conditions aren't abstract). */
+struct _pthread_fastlock
+{
+  __atomic_lock_t __spinlock;	/* Used by compare_and_swap emulation.  Also,
+				   adaptive SMP lock stores spin count here. */
+  long int __status;		/* "Free" or "taken" or head of waiting list */
+};
+
+#ifndef _PTHREAD_DESCR_DEFINED
+/* Thread descriptors */
+typedef struct _pthread_descr_struct *_pthread_descr;
+# define _PTHREAD_DESCR_DEFINED
+#endif
+
+
+/* Attributes for threads.  */
+typedef struct __pthread_attr_s
+{
+  int __detachstate;
+  int __schedpolicy;
+  struct __sched_param __schedparam;
+  int __inheritsched;
+  int __scope;
+  size_t __guardsize;
+  int __stackaddr_set;
+  void *__stackaddr;
+  size_t __stacksize;
+} pthread_attr_t;
+
+
+/* Conditions (not abstract because of PTHREAD_COND_INITIALIZER */
+
+#ifdef __GLIBC_HAVE_LONG_LONG
+__extension__ typedef long long __pthread_cond_align_t;
+#else
+typedef long __pthread_cond_align_t;
+#endif
+
+typedef struct
+{
+  struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
+  _pthread_descr __c_waiting;        /* Threads waiting on this condition */
+  char __padding[48 - sizeof (struct _pthread_fastlock)
+		 - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
+  __pthread_cond_align_t __align;
+} pthread_cond_t;
+
+
+/* Attribute for conditionally variables.  */
+typedef struct
+{
+  int __dummy;
+} pthread_condattr_t;
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Mutexes (not abstract because of PTHREAD_MUTEX_INITIALIZER).  */
+/* (The layout is unnatural to maintain binary compatibility
+    with earlier releases of LinuxThreads.) */
+typedef struct
+{
+  int __m_reserved;               /* Reserved for future use */
+  int __m_count;                  /* Depth of recursive locking */
+  _pthread_descr __m_owner;       /* Owner thread (if recursive or errcheck) */
+  int __m_kind;                   /* Mutex kind: fast, recursive or errcheck */
+  struct _pthread_fastlock __m_lock; /* Underlying fast lock */
+} pthread_mutex_t;
+
+
+/* Attribute for mutex.  */
+typedef struct
+{
+  int __mutexkind;
+} pthread_mutexattr_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#ifdef __USE_UNIX98
+/* Read-write locks.  */
+typedef struct _pthread_rwlock_t
+{
+  struct _pthread_fastlock __rw_lock; /* Lock to guarantee mutual exclusion */
+  int __rw_readers;                   /* Number of readers */
+  _pthread_descr __rw_writer;         /* Identity of writer, or NULL if none */
+  _pthread_descr __rw_read_waiting;   /* Threads waiting for reading */
+  _pthread_descr __rw_write_waiting;  /* Threads waiting for writing */
+  int __rw_kind;                      /* Reader/Writer preference selection */
+  int __rw_pshared;                   /* Shared between processes or not */
+} pthread_rwlock_t;
+
+
+/* Attribute for read-write locks.  */
+typedef struct
+{
+  int __lockkind;
+  int __pshared;
+} pthread_rwlockattr_t;
+#endif
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef __atomic_lock_t pthread_spinlock_t;
+
+/* POSIX barrier. */
+typedef struct {
+  struct _pthread_fastlock __ba_lock; /* Lock to guarantee mutual exclusion */
+  int __ba_required;                  /* Threads needed for completion */
+  int __ba_present;                   /* Threads waiting */
+  _pthread_descr __ba_waiting;        /* Queue of waiting threads */
+} pthread_barrier_t;
+
+/* barrier attribute */
+typedef struct {
+  int __pshared;
+} pthread_barrierattr_t;
+
+#endif
+
+
+/* Thread identifiers */
+typedef unsigned long int pthread_t;
+
+#endif	/* bits/pthreadtypes.h */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,73 @@
+/* HP-PARISC macro definitions for mutexes, thread-specific data 
+   and parameters for malloc.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@baldric.uwo.ca>, 2003.
+   
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MALLOC_MACHINE_H
+#define _MALLOC_MACHINE_H
+
+#undef thread_atfork_static
+
+#include <atomic.h>
+#include <bits/libc-lock.h>
+
+__libc_lock_define (typedef, mutex_t)
+
+/* Since our lock structure does not tolerate being initialized to zero, we must
+   modify the standard function calls made by malloc */
+#  define mutex_init(m)		\
+	__libc_maybe_call (__pthread_mutex_init, (m, NULL), \
+		(((m)->__m_lock.__spinlock = __LT_SPINLOCK_INIT),(*(int *)(m))) )
+#  define mutex_lock(m)		\
+	__libc_maybe_call (__pthread_mutex_lock, (m), \
+			(__load_and_clear(&((m)->__m_lock.__spinlock)), 0))
+#  define mutex_trylock(m)	\
+	__libc_maybe_call (__pthread_mutex_trylock, (m), \
+			(*(int *)(m) ? 1 : (__load_and_clear(&((m)->__m_lock.__spinlock)), 0)))
+#  define mutex_unlock(m)	\
+	__libc_maybe_call (__pthread_mutex_unlock, (m), \
+			(((m)->__m_lock.__spinlock = __LT_SPINLOCK_INIT), (*(int *)(m))) )
+	
+/* This is defined by newer gcc version unique for each module.  */
+extern void *__dso_handle __attribute__ ((__weak__));
+
+#include <fork.h>
+
+#ifdef SHARED
+# define thread_atfork(prepare, parent, child) \
+   __register_atfork (prepare, parent, child, __dso_handle)
+#else
+# define thread_atfork(prepare, parent, child) \
+   __register_atfork (prepare, parent, child,				      \
+		      &__dso_handle == NULL ? NULL : __dso_handle)
+#endif
+
+/* thread specific data for glibc */
+
+#include <bits/libc-tsd.h>
+
+typedef int tsd_key_t[1];	/* no key data structure, libc magic does it */
+__libc_tsd_define (static, MALLOC)	/* declaration/common definition */
+#define tsd_key_create(key, destr)	((void) (key))
+#define tsd_setspecific(key, data)	__libc_tsd_set (MALLOC, (data))
+#define tsd_getspecific(key, vptr)	((vptr) = __libc_tsd_get (MALLOC))
+
+#include <sysdeps/generic/malloc-machine.h>
+
+#endif /* !defined(_MALLOC_MACHINE_H) */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,109 @@
+/* Special .init and .fini section support for HPPA.  Linuxthreads version.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file.  (The Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   The GNU C Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This file is compiled into assembly code which is then munged by a sed
+   script into two files: crti.s and crtn.s.
+
+   * crti.s puts a function prologue at the beginning of the
+   .init and .fini sections and defines global symbols for
+   those addresses, so they can be called as functions.
+
+   * crtn.s puts the corresponding function epilogues
+   in the .init and .fini sections. */
+
+/* If we use the standard C version, the linkage table pointer won't
+   be properly preserved due to the splitting up of function prologues
+   and epilogues.  Therefore we write these in assembly to make sure
+   they do the right thing.  */
+
+__asm__ (
+"#include \"defs.h\"\n"
+"\n"
+"/*@HEADER_ENDS*/\n"
+"\n"
+"/*@_init_PROLOG_BEGINS*/\n"
+"	.section .init\n"
+"	.align 4\n"
+"	.globl _init\n"
+"	.type _init,@function\n"
+"_init:\n"
+"	stw	%rp,-20(%sp)\n"
+"	stwm	%r4,64(%sp)\n"
+"	stw	%r19,-32(%sp)\n"
+"	bl	__pthread_initialize_minimal,%rp\n"
+"	copy	%r19,%r4	/* delay slot */\n"
+"	copy	%r4,%r19\n"
+"/*@_init_PROLOG_ENDS*/\n"
+"\n"
+"/*@_init_EPILOG_BEGINS*/\n"
+"/* Here is the tail end of _init.  */\n"
+"	.section .init\n"
+"	ldw	-84(%sp),%rp\n"
+"	copy	%r4,%r19\n"
+"	bv	%r0(%rp)\n"
+"_end_init:\n"
+"	ldwm	-64(%sp),%r4\n"
+"\n"
+"/* Our very own unwind info, because the assembler can't handle\n"
+"   functions split into two or more pieces.  */\n"
+"	.section .PARISC.unwind,\"a\",@progbits\n"
+"	.extern _init\n"
+"	.word	_init, _end_init\n"
+"	.byte	0x08, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08\n"
+"\n"
+"/*@_init_EPILOG_ENDS*/\n"
+"\n"
+"/*@_fini_PROLOG_BEGINS*/\n"
+"	.section .fini\n"
+"	.align 4\n"
+"	.globl _fini\n"
+"	.type _fini,@function\n"
+"_fini:\n"
+"	stw	%rp,-20(%sp)\n"
+"	stwm	%r4,64(%sp)\n"
+"	stw	%r19,-32(%sp)\n"
+"	copy	%r19,%r4\n"
+"/*@_fini_PROLOG_ENDS*/\n"
+"\n"
+"/*@_fini_EPILOG_BEGINS*/\n"
+"	.section .fini\n"
+"	ldw	-84(%sp),%rp\n"
+"	copy	%r4,%r19\n"
+"	bv	%r0(%rp)\n"
+"_end_fini:\n"
+"	ldwm	-64(%sp),%r4\n"
+"\n"
+"	.section .PARISC.unwind,\"a\",@progbits\n"
+"	.extern _fini\n"
+"	.word	_fini, _end_fini\n"
+"	.byte	0x08, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08\n"
+"\n"
+"/*@_fini_EPILOG_ENDS*/\n"
+"\n"
+"/*@TRAILER_BEGINS*/\n"
+);
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,238 @@
+/* cancellable system calls for Linux/HPPA.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@baldric.uwo.ca>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <linuxthreads/internals.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# ifndef NO_ERROR
+#  define NO_ERROR -0x1000
+# endif
+
+/* The syscall cancellation mechanism requires userspace
+   assistance, the following code does roughly this:
+
+   	do arguments (read arg5 and arg6 to registers)
+	setup frame
+	
+	check if there are threads, yes jump to pseudo_cancel
+	
+	unthreaded:
+		syscall
+		check syscall return (jump to pre_end)
+		set errno
+		set return to -1
+		(jump to pre_end)
+		
+	pseudo_cancel:
+		cenable
+		syscall
+		cdisable
+		check syscall return (jump to pre_end)
+		set errno
+		set return to -1
+		
+	pre_end
+		restore stack
+	
+	It is expected that 'ret' and 'END' macros will
+	append an 'undo arguments' and 'return' to the 
+	this PSEUDO macro. */
+   
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				\
+	ENTRY (name)							\
+	DOARGS_##args					ASM_LINE_SEP	\
+	copy TREG, %r1					ASM_LINE_SEP	\
+	copy %sp, TREG					ASM_LINE_SEP	\
+	stwm %r1, 64(%sp)				ASM_LINE_SEP	\
+	stw %rp, -20(%sp)				ASM_LINE_SEP	\
+	stw TREG, -4(%sp)				ASM_LINE_SEP	\
+	/* Done setting up frame, continue... */	ASM_LINE_SEP	\
+	SINGLE_THREAD_P					ASM_LINE_SEP	\
+	cmpib,<>,n 0,%ret0,L(pseudo_cancel)		ASM_LINE_SEP	\
+L(unthreaded):						ASM_LINE_SEP	\
+	/* Save r19 */					ASM_LINE_SEP	\
+	SAVE_PIC(TREG)					ASM_LINE_SEP	\
+	/* Do syscall, delay loads # */			ASM_LINE_SEP	\
+	ble  0x100(%sr2,%r0)				ASM_LINE_SEP	\
+	ldi SYS_ify (syscall_name), %r20 /* delay */	ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1				ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)			ASM_LINE_SEP	\
+	/* Restore r19 from TREG */			ASM_LINE_SEP	\
+	LOAD_PIC(TREG) /* delay */			ASM_LINE_SEP	\
+	SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
+	/* Use TREG for temp storage */			ASM_LINE_SEP	\
+	copy %ret0, TREG /* delay */			ASM_LINE_SEP	\
+	/* OPTIMIZE: Don't reload r19 */		ASM_LINE_SEP	\
+	/* do a -1*syscall_ret0 */			ASM_LINE_SEP	\
+	sub %r0, TREG, TREG				ASM_LINE_SEP	\
+	/* Store into errno location */			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)				ASM_LINE_SEP	\
+	b L(pre_end)					ASM_LINE_SEP	\
+	/* return -1 as error */			ASM_LINE_SEP	\
+	ldo -1(%r0), %ret0 /* delay */			ASM_LINE_SEP	\
+L(pseudo_cancel):					ASM_LINE_SEP	\
+	PUSHARGS_##args /* Save args */			ASM_LINE_SEP	\
+	/* Save r19 into TREG */			ASM_LINE_SEP	\
+	CENABLE /* FUNC CALL */				ASM_LINE_SEP	\
+	SAVE_PIC(TREG) /* delay */			ASM_LINE_SEP	\
+	/* restore syscall args */			ASM_LINE_SEP	\
+	POPARGS_##args					ASM_LINE_SEP	\
+	/* save mask from cenable (use stub rp slot) */	ASM_LINE_SEP	\
+	stw %ret0, -24(%sp)				ASM_LINE_SEP	\
+	/* ... SYSCALL ... */				ASM_LINE_SEP	\
+	ble 0x100(%sr2,%r0)				ASM_LINE_SEP    \
+	ldi SYS_ify (syscall_name), %r20 /* delay */	ASM_LINE_SEP	\
+	/* ............... */				ASM_LINE_SEP	\
+	LOAD_PIC(TREG)					ASM_LINE_SEP	\
+	/* pass mask as arg0 to cdisable */		ASM_LINE_SEP	\
+	ldw -24(%sp), %r26				ASM_LINE_SEP	\
+	CDISABLE					ASM_LINE_SEP	\
+	stw %ret0, -24(%sp) /* delay */			ASM_LINE_SEP	\
+	/* Restore syscall return */			ASM_LINE_SEP	\
+	ldw -24(%sp), %ret0				ASM_LINE_SEP	\
+	/* compare error */				ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1				ASM_LINE_SEP	\
+	/* branch if no error */			ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)			ASM_LINE_SEP	\
+	LOAD_PIC(TREG)	/* cond. nullify */		ASM_LINE_SEP	\
+	copy %ret0, TREG /* save syscall return */	ASM_LINE_SEP	\
+	SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
+	/* make syscall res value positive */		ASM_LINE_SEP	\
+	sub %r0, TREG, TREG	/* delay */		ASM_LINE_SEP	\
+	/* No need to LOAD_PIC */			ASM_LINE_SEP	\
+	/* store into errno location */			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)				ASM_LINE_SEP	\
+	/* return -1 */					ASM_LINE_SEP	\
+	ldo -1(%r0), %ret0				ASM_LINE_SEP	\
+L(pre_end):						ASM_LINE_SEP	\
+	/* Restore rp before exit */			ASM_LINE_SEP	\
+	ldw -84(%sr0,%sp), %rp				ASM_LINE_SEP	\
+	/* Undo frame */				ASM_LINE_SEP	\
+	ldwm -64(%sp),TREG				ASM_LINE_SEP	\
+	/* No need to LOAD_PIC */			ASM_LINE_SEP
+
+/* Save arguments into our frame */
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 stw %r26, -36(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_2	PUSHARGS_1 stw %r25, -40(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_3	PUSHARGS_2 stw %r24, -44(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_4	PUSHARGS_3 stw %r23, -48(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_5	PUSHARGS_4 stw %r22, -52(%sr0,%sp)	ASM_LINE_SEP 
+# define PUSHARGS_6	PUSHARGS_5 stw %r21, -56(%sr0,%sp)	ASM_LINE_SEP
+
+/* Bring them back from the stack */
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 ldw -36(%sr0,%sp), %r26	ASM_LINE_SEP
+# define POPARGS_2	POPARGS_1 ldw -40(%sr0,%sp), %r25	ASM_LINE_SEP
+# define POPARGS_3	POPARGS_2 ldw -44(%sr0,%sp), %r24	ASM_LINE_SEP
+# define POPARGS_4	POPARGS_3 ldw -48(%sr0,%sp), %r23	ASM_LINE_SEP
+# define POPARGS_5	POPARGS_4 ldw -52(%sr0,%sp), %r22	ASM_LINE_SEP
+# define POPARGS_6	POPARGS_5 ldw -56(%sr0,%sp), %r21	ASM_LINE_SEP
+
+# ifdef IS_IN_libpthread
+#  ifdef PIC
+#   define CENABLE .import __pthread_enable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __pthread_disable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __pthread_enable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __pthread_disable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# elif !defined NOT_IN_libc
+#  ifdef PIC
+#   define CENABLE .import __libc_enable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE	.import __libc_disable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __libc_enable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE	.import __libc_disable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# else
+#  ifdef PIC
+#   define CENABLE .import __librt_enable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __librt_disable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __librt_enable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __librt_disable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# endif
+
+/* p_header.multiple_threads is +12 from the pthread_descr struct start,
+   We could have called __get_cr27() but we really want less overhead */
+# define MULTIPLE_THREADS_OFFSET 0xC
+
+/* cr27 has been initialized to 0x0 by kernel */
+# define NO_THREAD_CR27 0x0
+
+# ifdef IS_IN_libpthread
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  define __local_multiple_threads __libc_multiple_threads
+# else
+#  define __local_multiple_threads __librt_multiple_threads
+# endif
+
+# ifndef __ASSEMBLER__
+ extern int __local_multiple_threads attribute_hidden;
+#  define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
+# else
+/* This ALT version requires newer kernel support */
+#  define SINGLE_THREAD_P_MFCTL						\
+	mfctl %cr27, %ret0					ASM_LINE_SEP	\
+	cmpib,= NO_THREAD_CR27,%ret0,L(stp)			ASM_LINE_SEP	\
+	nop							ASM_LINE_SEP	\
+	ldw MULTIPLE_THREADS_OFFSET(%sr0,%ret0),%ret0		ASM_LINE_SEP	\
+L(stp):								ASM_LINE_SEP
+#  ifdef PIC
+/* Slower version uses GOT to get value of __local_multiple_threads */
+#   define SINGLE_THREAD_P							\
+	addil LT%__local_multiple_threads, %r19			ASM_LINE_SEP	\
+	ldw RT%__local_multiple_threads(%sr0,%r1), %ret0	ASM_LINE_SEP	\
+	ldw 0(%sr0,%ret0), %ret0 				ASM_LINE_SEP
+#  else
+/* Slow non-pic version using DP */
+#   define SINGLE_THREAD_P								\
+	addil LR%__local_multiple_threads-$global$,%r27  		ASM_LINE_SEP	\
+	ldw RR%__local_multiple_threads-$global$(%sr0,%r1),%ret0	ASM_LINE_SEP
+#  endif
+# endif
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+
+#endif
+/* !defined NOT_IN_libc || defined IS_IN_libpthread */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/lxstat.c ports/sysdeps/unix/sysv/linux/hppa/lxstat.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/lxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/lxstat.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lxstat.c>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/bits/pthreadtypes.h ports/sysdeps/unix/sysv/linux/hppa/nptl/bits/pthreadtypes.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/bits/pthreadtypes.h	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,192 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+/* Linuxthread type sizes:
+   sizeof(pthread_attr_t) = 0x24 (36)
+   sizeof(pthread_mutex_t) = 0x30 (48)
+   sizeof(pthread_mutexattr_t) = 0x4 (4)
+   sizeof(pthread_cond_t) = 0x30 (48)
+   No pthread_cond_compat_t ...
+   sizeof(pthread_condattr_t) = 0x4 (4)
+   sizeof(pthread_rwlock_t) = 0x40 (64)
+   sizeof(pthread_rwlockattr_t) = 0x8 (8)
+   sizeof(pthread_barrier_t) = 0x30 (48)
+   sizeof(pthread_barrierattr_t) = 0x4 (4) */
+
+#define __SIZEOF_PTHREAD_ATTR_T 36
+#define __SIZEOF_PTHREAD_MUTEX_T 48 
+#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#define __SIZEOF_PTHREAD_COND_T 48
+#define __SIZEOF_PTHREAD_COND_COMPAT_T 12
+#define __SIZEOF_PTHREAD_CONDATTR_T 4
+#define __SIZEOF_PTHREAD_RWLOCK_T 64
+#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#define __SIZEOF_PTHREAD_BARRIER_T 48
+#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+
+#define __PAD_ATOMIC_LOCK_T 12
+
+/* Thread identifiers.  The structure of the attribute type is not
+   exposed on purpose.  */
+typedef unsigned long int pthread_t;
+
+/* Our old basic lock type, listed here for posterity.
+   We needed self-aligning locks for linuxthreads LDCW 
+   implementation. For NPTL we use LWS Compare and 
+   Exchange to implement primitives. */
+#if 0
+typedef struct {
+	int lock[4];
+} __atomic_lock_t;
+#endif
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+} pthread_attr_t;
+
+
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is not exposed on purpose.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    char __size[__PAD_ATOMIC_LOCK_T];
+    unsigned int __count;
+    int __owner;
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  long int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    char __size[__PAD_ATOMIC_LOCK_T];
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  long int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    char __size[__PAD_ATOMIC_LOCK_T];
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+    int __writer;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/bits/semaphore.h ports/sysdeps/unix/sysv/linux/hppa/nptl/bits/semaphore.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/bits/semaphore.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/bits/semaphore.h	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,39 @@
+/* Copyright (C) 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+
+#define __SIZEOF_SEM_T	16
+
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+/* Maximum value the semaphore can have.  */
+#define SEM_VALUE_MAX   ((int) ((~0u) >> 1))
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/createthread.c ports/sysdeps/unix/sysv/linux/hppa/nptl/createthread.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/createthread.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/createthread.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,23 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+#define TLS_VALUE (pd + 1)
+
+/* Get the real implementation.	 */
+#include <nptl/sysdeps/pthread/createthread.c>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/fork.c ports/sysdeps/unix/sysv/linux/hppa/nptl/fork.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/fork.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/fork.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,34 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sched.h>
+#include <signal.h>
+#include <sysdep.h>
+#include <tls.h>
+
+/* Argument 1 - Clone flags.
+            2 - Child stack pointer.
+	    3 - Parent tid pointer.
+	    4 - New TLS area pointer.
+	    5 - Child tid pointer. */
+#define ARCH_FORK() \
+  INLINE_SYSCALL (clone, 5,						\
+		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD,	\
+                  NULL, NULL, NULL, &THREAD_SELF->tid)
+
+#include <nptl/sysdeps/unix/sysv/linux/fork.c>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/internaltypes.h ports/sysdeps/unix/sysv/linux/hppa/nptl/internaltypes.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/internaltypes.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/internaltypes.h	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,153 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _INTERNALTYPES_H
+#define _INTERNALTYPES_H	1
+
+#include <stdint.h>
+
+
+struct pthread_attr
+{
+  /* Scheduler parameters and priority.  */
+  struct sched_param schedparam;
+  int schedpolicy;
+  /* Various flags like detachstate, scope, etc.  */
+  int flags;
+  /* Size of guard area.  */
+  size_t guardsize;
+  /* Stack handling.  */
+  void *stackaddr;
+  size_t stacksize;
+  /* Affinity map.  */
+  cpu_set_t *cpuset;
+  size_t cpusetsize;
+};
+
+#define ATTR_FLAG_DETACHSTATE		0x0001
+#define ATTR_FLAG_NOTINHERITSCHED	0x0002
+#define ATTR_FLAG_SCOPEPROCESS		0x0004
+#define ATTR_FLAG_STACKADDR		0x0008
+#define ATTR_FLAG_OLDATTR		0x0010
+#define ATTR_FLAG_SCHED_SET		0x0020
+#define ATTR_FLAG_POLICY_SET		0x0040
+
+
+/* Mutex attribute data structure.  */
+struct pthread_mutexattr
+{
+  /* Identifier for the kind of mutex.
+
+     Bit 31 is set if the mutex is to be shared between processes.
+
+     Bit 0 to 30 contain one of the PTHREAD_MUTEX_ values to identify
+     the type of the mutex.  */
+  int mutexkind;
+};
+
+
+/* Conditional variable attribute data structure.  */
+struct pthread_condattr
+{
+  /* Combination of values:
+
+     Bit 0  : flag whether coditional variable will be shareable between
+	      processes.
+
+     Bit 1-7: clock ID.  */
+  int value;
+};
+
+
+/* The __NWAITERS field is used as a counter and to house the number
+   of bits which represent the clock.  COND_CLOCK_BITS is the number
+   of bits reserved for the clock.  */
+#define COND_CLOCK_BITS	1
+
+
+/* Read-write lock variable attribute data structure.  */
+struct pthread_rwlockattr
+{
+  int lockkind;
+  int pshared;
+};
+
+
+/* Barrier data structure.  */
+struct pthread_barrier
+{
+  unsigned int curr_event;
+  int lock;
+  unsigned int left;
+  unsigned int init_count;
+};
+
+
+/* Barrier variable attribute data structure.  */
+struct pthread_barrierattr
+{
+  int pshared;
+};
+
+
+/* Thread-local data handling.  */
+struct pthread_key_struct
+{
+  /* Sequence numbers.  Even numbers indicated vacant entries.  Note
+     that zero is even.  We use uintptr_t to not require padding on
+     32- and 64-bit machines.  On 64-bit machines it helps to avoid
+     wrapping, too.  */
+  uintptr_t seq;
+
+  /* Destructor for the data.  */
+  void (*destr) (void *);
+};
+
+/* Check whether an entry is unused.  */
+#define KEY_UNUSED(p) (((p) & 1) == 0)
+/* Check whether a key is usable.  We cannot reuse an allocated key if
+   the sequence counter would overflow after the next destroy call.
+   This would mean that we potentially free memory for a key with the
+   same sequence.  This is *very* unlikely to happen, A program would
+   have to create and destroy a key 2^31 times (on 32-bit platforms,
+   on 64-bit platforms that would be 2^63).  If it should happen we
+   simply don't use this specific key anymore.  */
+#define KEY_USABLE(p) (((uintptr_t) (p)) < ((uintptr_t) ((p) + 2)))
+
+
+/* Handling of read-write lock data.  */
+// XXX For now there is only one flag.  Maybe more in future.
+#define RWLOCK_RECURSIVE(rwlock) ((rwlock)->__data.__flags != 0)
+
+
+/* Semaphore variable structure.  */
+struct sem
+{
+  unsigned int count;
+};
+
+
+/* Compatibility type for old conditional variable interfaces.  */
+typedef struct
+{
+  pthread_cond_t *cond;
+} pthread_cond_2_0_t;
+
+#endif	/* internaltypes.h */
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/libc-lowlevellock.c ports/sysdeps/unix/sysv/linux/hppa/nptl/libc-lowlevellock.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/libc-lowlevellock.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/libc-lowlevellock.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,21 @@
+/* low level locking for pthread library.  Generic futex-using version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "lowlevellock.c"
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.c ports/sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,130 @@
+/* low level locking for pthread library.  Generic futex-using version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <lowlevellock.h>
+#include <sys/time.h>
+
+
+void
+__lll_lock_wait (lll_lock_t *futex)
+{
+  do
+    {
+      int oldval = atomic_compare_and_exchange_val_acq (futex, 2, 1);
+      if (oldval != 0)
+	lll_futex_wait (futex, 2);
+    }
+  while (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0);
+}
+
+
+int
+__lll_timedlock_wait (lll_lock_t *futex, const struct timespec *abstime)
+{
+  /* Reject invalid timeouts.  */
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+    return EINVAL;
+
+  do
+    {
+      struct timeval tv;
+      struct timespec rt;
+
+      /* Get the current time.  */
+      (void) __gettimeofday (&tv, NULL);
+
+      /* Compute relative timeout.  */
+      rt.tv_sec = abstime->tv_sec - tv.tv_sec;
+      rt.tv_nsec = abstime->tv_nsec - tv.tv_usec * 1000;
+      if (rt.tv_nsec < 0)
+	{
+	  rt.tv_nsec += 1000000000;
+	  --rt.tv_sec;
+	}
+
+      /* Already timed out?  */
+      if (rt.tv_sec < 0)
+	return ETIMEDOUT;
+
+      /* Wait.  */
+      int oldval = atomic_compare_and_exchange_val_acq (futex, 2, 1);
+      if (oldval != 0)
+	lll_futex_timed_wait (futex, 2, &rt);
+    }
+  while (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0);
+  return 0;
+}
+
+
+/* These don't get included in libc.so  */
+#ifdef IS_IN_libpthread
+int
+lll_unlock_wake_cb (lll_lock_t *futex)
+{
+  int val = atomic_exchange_rel (futex, 0);
+
+  if (__builtin_expect (val > 1, 0))
+    lll_futex_wake (futex, 1);
+  return 0;
+}
+
+
+int
+__lll_timedwait_tid (int *tidp, const struct timespec *abstime)
+{
+  int tid;
+
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+    return EINVAL;
+
+  /* Repeat until thread terminated.  */
+  while ((tid = *tidp) != 0)
+    {
+      struct timeval tv;
+      struct timespec rt;
+
+      /* Get the current time.  */
+      (void) __gettimeofday (&tv, NULL);
+
+      /* Compute relative timeout.  */
+      rt.tv_sec = abstime->tv_sec - tv.tv_sec;
+      rt.tv_nsec = abstime->tv_nsec - tv.tv_usec * 1000;
+      if (rt.tv_nsec < 0)
+	{
+	  rt.tv_nsec += 1000000000;
+	  --rt.tv_sec;
+	}
+
+      /* Already timed out?  */
+      if (rt.tv_sec < 0)
+	return ETIMEDOUT;
+
+      /* Wait until thread terminates.  */
+      if (lll_futex_timed_wait (tidp, tid, &rt) == -ETIMEDOUT)
+	return ETIMEDOUT;
+    }
+
+  return 0;
+}
+
+#endif
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.h ports/sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.h	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,336 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <sysdep.h>
+#include <atomic.h>
+
+#if 0
+/* The hppa only has one atomic read and modify memory operation,
+   load and clear, so hppa spinlocks must use zero to signify that
+   someone is holding the lock.  The address used for the ldcw
+   semaphore must be 16-byte aligned.  */
+#define __ldcw(a) \
+({ 									\
+  unsigned int __ret;							\
+  __asm__ __volatile__("ldcw 0(%1),%0"					\
+                      : "=r" (__ret) : "r" (a) : "memory");		\
+  __ret;								\
+})
+
+/* Because malloc only guarantees 8-byte alignment for malloc'd data,
+   and GCC only guarantees 8-byte alignment for stack locals, we can't
+   be assured of 16-byte alignment for atomic lock data even if we
+   specify "__attribute ((aligned(16)))" in the type declaration.  So,
+   we use a struct containing an array of four ints for the atomic lock
+   type and dynamically select the 16-byte aligned int from the array
+   for the semaphore.  */
+#define __PA_LDCW_ALIGNMENT 16
+#define __ldcw_align(a) ({ \
+  volatile unsigned int __ret = (unsigned int) a;			\
+  if ((__ret & ~(__PA_LDCW_ALIGNMENT - 1)) < (unsigned int) a)		\
+    __ret = (__ret & ~(__PA_LDCW_ALIGNMENT - 1)) + __PA_LDCW_ALIGNMENT; \
+  (unsigned int *) __ret;						\
+})
+#endif
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+
+/* Initializer for compatibility lock.	*/
+#if 0
+#define LLL_INITIALIZER_NOT_ZERO
+#define LLL_MUTEX_LOCK_INITIALIZER ((__atomic_lock_t){ { 1, 1, 1, 1 } })
+#endif
+#define LLL_MUTEX_LOCK_INITIALIZER (0)
+
+
+/* Type for lock object.  */
+typedef int lll_lock_t;
+
+
+#define lll_futex_wait(futexp, val) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (futexp), FUTEX_WAIT, (val), 0);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_futex_timed_wait(futexp, val, timespec) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (futexp), FUTEX_WAIT, (val), (timespec));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_futex_wake(futexp, nr) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (futexp), FUTEX_WAKE, (nr), 0);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err) ? -__ret : __ret;		      \
+  })
+
+#define lll_robust_mutex_dead(futexv) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1);					      \
+    }									      \
+  while (0)
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6,				      \
+			      (futexp), FUTEX_CMP_REQUEUE, (nr_wake),	      \
+			      (nr_move), (mutex), (val));		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6,				      \
+			      (futexp), FUTEX_WAKE_OP, (nr_wake),	      \
+			      (nr_wake2), (futexp2),			      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    __ret;								      \
+  })
+
+static inline int __attribute__((always_inline))
+__lll_mutex_trylock(lll_lock_t *futex)
+{
+  return atomic_compare_and_exchange_val_acq (futex, 1, 0) != 0;
+}
+#define lll_mutex_trylock(lock)	__lll_mutex_trylock (&(lock))
+
+static inline int __attribute__((always_inline))
+__lll_robust_mutex_trylock(int *futex, int id)
+{
+  return atomic_compare_and_exchange_val_acq (futex, id, 0) != 0;
+}
+#define lll_robust_mutex_trylock(lock, id) \
+  __lll_robust_mutex_trylock (&(lock), id)
+
+
+static inline int __attribute__((always_inline))
+__lll_mutex_cond_trylock(lll_lock_t *futex)
+{
+  return atomic_compare_and_exchange_val_acq (futex, 2, 0) != 0;
+}
+#define lll_mutex_cond_trylock(lock)	__lll_mutex_cond_trylock (&(lock))
+
+
+extern void __lll_lock_wait (lll_lock_t *futex) attribute_hidden;
+
+static inline void __attribute__((always_inline))
+__lll_mutex_lock(lll_lock_t *futex)
+{
+  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
+    __lll_lock_wait (futex);
+}
+#define lll_mutex_lock(futex) __lll_mutex_lock (&(futex))
+
+extern int __lll_robust_lock_wait (int *futex) attribute_hidden;
+
+static inline int __attribute__ ((always_inline))
+__lll_robust_mutex_lock (int *futex, int id)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, id, 0) != 0)
+    result = __lll_robust_lock_wait (futex);
+  return result;
+}
+#define lll_robust_mutex_lock(futex, id) \
+  __lll_robust_mutex_lock (&(futex), id)
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_cond_lock (lll_lock_t *futex)
+{
+  if (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0)
+    __lll_lock_wait (futex);
+}
+#define lll_mutex_cond_lock(futex) __lll_mutex_cond_lock (&(futex))
+
+
+#define lll_robust_mutex_cond_lock(futex, id) \
+  __lll_robust_mutex_lock (&(futex), (id) | FUTEX_WAITERS)
+
+
+extern int __lll_timedlock_wait (lll_lock_t *futex, const struct timespec *)
+	attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *)
+	attribute_hidden;
+
+static inline int __attribute__ ((always_inline))
+__lll_mutex_timedlock (lll_lock_t *futex, const struct timespec *abstime)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
+    result = __lll_timedlock_wait (futex, abstime);
+  return result;
+}
+#define lll_mutex_timedlock(futex, abstime) \
+  __lll_mutex_timedlock (&(futex), abstime)
+
+static inline int __attribute__ ((always_inline))
+__lll_robust_mutex_timedlock (int *futex, const struct timespec *abstime,
+			      int id)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, id, 0) != 0)
+    result = __lll_robust_timedlock_wait (futex, abstime);
+  return result;
+}
+#define lll_robust_mutex_timedlock(futex, abstime, id) \
+  __lll_robust_mutex_timedlock (&(futex), abstime, id)
+
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_unlock (lll_lock_t *futex)
+{
+  int val = atomic_exchange_rel (futex, 0);
+  if (__builtin_expect (val > 1, 0))
+    lll_futex_wake (futex, 1);
+}
+#define lll_mutex_unlock(futex) __lll_mutex_unlock(&(futex))
+
+
+static inline void __attribute__ ((always_inline))
+__lll_robust_mutex_unlock (int *futex, int mask)
+{
+  int val = atomic_exchange_rel (futex, 0);
+  if (__builtin_expect (val & mask, 0))
+    lll_futex_wake (futex, 1);
+}
+#define lll_robust_mutex_unlock(futex) \
+  __lll_robust_mutex_unlock(&(futex), FUTEX_WAITERS)
+
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_unlock_force (lll_lock_t *futex)
+{
+  (void) atomic_exchange_rel (futex, 0);
+  lll_futex_wake (futex, 1);
+}
+#define lll_mutex_unlock_force(futex) __lll_mutex_unlock_force(&(futex))
+
+
+static inline int __attribute__ ((always_inline))
+__lll_mutex_islocked (lll_lock_t *futex)
+{
+  return (*futex != 0);
+}
+#define lll_mutex_islocked(futex) __lll_mutex_islocked(&(futex))
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Initializers for lock.  */
+#if 0
+#define LLL_LOCK_INITIALIZER		((__atomic_lock_t){ { 1, 1, 1, 1 } })
+#define LLL_LOCK_INITIALIZER_CONST	{ { 1, 1, 1, 1 } }
+#define LLL_LOCK_INITIALIZER_LOCKED	((__atomic_lock_t){ { 0, 0, 0, 0 } })
+#endif
+
+#define LLL_LOCK_INITIALIZER (0)
+#define LLL_LOCK_INITIALIZER_CONST (0)
+#define LLL_LOCK_INITIALIZER_LOCKED (1)
+
+
+#define THREAD_INIT_LOCK(PD, LOCK) \
+  (PD)->LOCK = LLL_LOCK_INITIALIZER
+
+extern int lll_unlock_wake_cb (lll_lock_t *__futex) attribute_hidden;
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+#define lll_trylock(lock)	lll_mutex_trylock (lock)
+#define lll_lock(lock)		lll_mutex_lock (lock)
+#define lll_unlock(lock)	lll_mutex_unlock (lock)
+#define lll_islocked(lock)	lll_mutex_islocked (lock)
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {					\
+    __typeof (tid) __tid;		\
+    while ((__tid = (tid)) != 0)	\
+      lll_futex_wait (&(tid), __tid);	\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+
+/* Conditional variable handling.  */
+
+extern void __lll_cond_wait (pthread_cond_t *cond)
+     attribute_hidden;
+extern int __lll_cond_timedwait (pthread_cond_t *cond,
+				 const struct timespec *abstime)
+     attribute_hidden;
+extern void __lll_cond_wake (pthread_cond_t *cond)
+     attribute_hidden;
+extern void __lll_cond_broadcast (pthread_cond_t *cond)
+     attribute_hidden;
+
+#define lll_cond_wait(cond) \
+  __lll_cond_wait (cond)
+#define lll_cond_timedwait(cond, abstime) \
+  __lll_cond_timedwait (cond, abstime)
+#define lll_cond_wake(cond) \
+  __lll_cond_wake (cond)
+#define lll_cond_broadcast(cond) \
+  __lll_cond_broadcast (cond)
+
+#endif	/* lowlevellock.h */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/pthread_once.c ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_once.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/pthread_once.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/pthread_once.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,94 @@
+/* Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+
+unsigned long int __fork_generation attribute_hidden;
+
+
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
+
+  *once_control = 0;
+  lll_futex_wake (once_control, INT_MAX);
+}
+
+
+int
+__pthread_once (once_control, init_routine)
+     pthread_once_t *once_control;
+     void (*init_routine) (void);
+{
+  while (1)
+    {
+      int oldval, val, newval;
+
+      val = *once_control;
+      do
+	{
+	  /* Check if the initialized has already been done.  */
+	  if ((val & 2) != 0)
+	    return 0;
+
+	  oldval = val;
+	  newval = (oldval & 3) | __fork_generation | 1;
+	  val = atomic_compare_and_exchange_val_acq (once_control, newval,
+						     oldval);
+	}
+      while (__builtin_expect (val != oldval, 0));
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) != 0)
+	{
+	  /* Check whether the initializer execution was interrupted
+	     by a fork.	 */
+	  if (((oldval ^ newval) & -4) == 0)
+	    {
+	      /* Same generation, some other thread was faster. Wait.  */
+	      lll_futex_wait (once_control, newval);
+	      continue;
+	    }
+	}
+
+      /* This thread is the first here.  Do the initialization.
+	 Register a cleanup handler so that in case the thread gets
+	 interrupted the initialization can be restarted.  */
+      pthread_cleanup_push (clear_once_control, once_control);
+
+      init_routine ();
+
+      pthread_cleanup_pop (0);
+
+
+      /* Add one to *once_control.  */
+      atomic_increment (once_control);
+
+      /* Wake up all other threads.  */
+      lll_futex_wake (once_control, INT_MAX);
+      break;
+    }
+
+  return 0;
+}
+weak_alias (__pthread_once, pthread_once)
+strong_alias (__pthread_once, __pthread_once_internal)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/pt-initfini.c ports/sysdeps/unix/sysv/linux/hppa/nptl/pt-initfini.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/pt-initfini.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/pt-initfini.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,109 @@
+/* Special .init and .fini section support for HPPA.  NPTL version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file.  (The Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   The GNU C Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This file is compiled into assembly code which is then munged by a sed
+   script into two files: crti.s and crtn.s.
+
+   * crti.s puts a function prologue at the beginning of the
+   .init and .fini sections and defines global symbols for
+   those addresses, so they can be called as functions.
+
+   * crtn.s puts the corresponding function epilogues
+   in the .init and .fini sections. */
+
+/* If we use the standard C version, the linkage table pointer won't
+   be properly preserved due to the splitting up of function prologues
+   and epilogues.  Therefore we write these in assembly to make sure
+   they do the right thing.  */
+
+__asm__ (
+"#include \"defs.h\"\n"
+"\n"
+"/*@HEADER_ENDS*/\n"
+"\n"
+"/*@_init_PROLOG_BEGINS*/\n"
+"	.section .init\n"
+"	.align 4\n"
+"	.globl _init\n"
+"	.type _init,@function\n"
+"_init:\n"
+"	stw	%rp,-20(%sp)\n"
+"	stwm	%r4,64(%sp)\n"
+"	stw	%r19,-32(%sp)\n"
+"	bl	__pthread_initialize_minimal_internal,%rp\n"
+"	copy	%r19,%r4	/* delay slot */\n"
+"	copy	%r4,%r19\n"
+"/*@_init_PROLOG_ENDS*/\n"
+"\n"
+"/*@_init_EPILOG_BEGINS*/\n"
+"/* Here is the tail end of _init.  */\n"
+"	.section .init\n"
+"	ldw	-84(%sp),%rp\n"
+"	copy	%r4,%r19\n"
+"	bv	%r0(%rp)\n"
+"_end_init:\n"
+"	ldwm	-64(%sp),%r4\n"
+"\n"
+"/* Our very own unwind info, because the assembler can't handle\n"
+"   functions split into two or more pieces.  */\n"
+"	.section .PARISC.unwind,\"a\",@progbits\n"
+"	.extern _init\n"
+"	.word	_init, _end_init\n"
+"	.byte	0x08, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08\n"
+"\n"
+"/*@_init_EPILOG_ENDS*/\n"
+"\n"
+"/*@_fini_PROLOG_BEGINS*/\n"
+"	.section .fini\n"
+"	.align 4\n"
+"	.globl _fini\n"
+"	.type _fini,@function\n"
+"_fini:\n"
+"	stw	%rp,-20(%sp)\n"
+"	stwm	%r4,64(%sp)\n"
+"	stw	%r19,-32(%sp)\n"
+"	copy	%r19,%r4\n"
+"/*@_fini_PROLOG_ENDS*/\n"
+"\n"
+"/*@_fini_EPILOG_BEGINS*/\n"
+"	.section .fini\n"
+"	ldw	-84(%sp),%rp\n"
+"	copy	%r4,%r19\n"
+"	bv	%r0(%rp)\n"
+"_end_fini:\n"
+"	ldwm	-64(%sp),%r4\n"
+"\n"
+"	.section .PARISC.unwind,\"a\",@progbits\n"
+"	.extern _fini\n"
+"	.word	_fini, _end_fini\n"
+"	.byte	0x08, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08\n"
+"\n"
+"/*@_fini_EPILOG_ENDS*/\n"
+"\n"
+"/*@TRAILER_BEGINS*/\n"
+);
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/pt-vfork.S ports/sysdeps/unix/sysv/linux/hppa/nptl/pt-vfork.S
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/pt-vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/pt-vfork.S	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,90 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#define _ERRNO_H        1
+#include <bits/errno.h>
+#include <tcb-offsets.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+/* Load the thread register.
+   Load the saved PID value.
+   Negate the value.
+   Store the temporary PID. */
+#define SAVE_PID							\
+	mfctl %cr27, %r26				ASM_LINE_SEP	\
+	ldw PID_THREAD_OFFSET(%r26),%r1			ASM_LINE_SEP    \
+	sub %r0,%r1,%r1					ASM_LINE_SEP    \
+	stw %r1,PID_THREAD_OFFSET(%r26)			ASM_LINE_SEP
+/* If we are the parent...
+   Get the thread pointer.
+   Load the saved PID.
+   Negate the value (got back original)
+   Restore the PID. */
+#define RESTORE_PID							\
+	cmpb,=,n %r0,%ret0,.Lthread_start		ASM_LINE_SEP	\
+	mfctl %cr27, %r26				ASM_LINE_SEP	\
+	ldw PID_THREAD_OFFSET(%r26),%r1			ASM_LINE_SEP	\
+	sub %r0,%r1,%r1					ASM_LINE_SEP	\
+	stw %r1,PID_THREAD_OFFSET(%r26)			ASM_LINE_SEP	\
+.Lthread_start:						ASM_LINE_SEP
+
+	/* r26, r25, r24, r23 are free since vfork has no arguments */
+ENTRY(__vfork)
+
+	/* Save the PIC register. */
+#ifdef PIC
+	copy	%r19, %r25	/* parent */
+#endif
+
+	/* Save the process PID */
+	SAVE_PID
+
+	/* Syscall saves and restores all register states */
+	ble	0x100(%sr2,%r0)
+	ldi	__NR_vfork,%r20
+
+	/* Conditionally restore the PID */
+	RESTORE_PID
+
+	/* Check for error */
+	ldi	-4096,%r1
+	comclr,>>= %r1,%ret0,%r0        /* Note: unsigned compare. */
+	b,n	.Lerror
+
+	/* Return, no need to restore the PIC register. */
+	bv,n	%r0(%rp)
+
+.Lerror:
+	SYSCALL_ERROR_HANDLER
+	/* Restore the PIC register (in delay slot) on error */
+#ifdef PIC
+	copy	%r25, %r19    /* parent */
+#else
+	nop
+#endif
+	sub	%r0,%ret0,%arg0
+	/* Return error */
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+weak_alias (__vfork, vfork)
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/sysdep-cancel.h ports/sysdeps/unix/sysv/linux/hppa/nptl/sysdep-cancel.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/sysdep-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/sysdep-cancel.h	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,217 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sysdeps/generic/sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# ifndef NO_ERROR
+#  define NO_ERROR -0x1000
+# endif
+
+/* The syscall cancellation mechanism requires userspace
+   assistance, the following code does roughly this:
+
+   	do arguments (read arg5 and arg6 to registers)
+	setup frame
+	
+	check if there are threads, yes jump to pseudo_cancel
+	
+	unthreaded:
+		syscall
+		check syscall return (jump to pre_end)
+		set errno
+		set return to -1
+		(jump to pre_end)
+		
+	pseudo_cancel:
+		cenable
+		syscall
+		cdisable
+		check syscall return (jump to pre_end)
+		set errno
+		set return to -1
+		
+	pre_end
+		restore stack
+	
+	It is expected that 'ret' and 'END' macros will
+	append an 'undo arguments' and 'return' to the 
+	this PSEUDO macro. */
+   
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				\
+	ENTRY (name)							\
+	DOARGS_##args					ASM_LINE_SEP	\
+	copy TREG, %r1					ASM_LINE_SEP	\
+	copy %sp, TREG					ASM_LINE_SEP	\
+	stwm %r1, 64(%sp)				ASM_LINE_SEP	\
+	stw %rp, -20(%sp)				ASM_LINE_SEP	\
+	stw TREG, -4(%sp)				ASM_LINE_SEP	\
+	/* Done setting up frame, continue... */	ASM_LINE_SEP	\
+	SINGLE_THREAD_P					ASM_LINE_SEP	\
+	cmpib,<>,n 0,%ret0,L(pseudo_cancel)		ASM_LINE_SEP	\
+L(unthreaded):						ASM_LINE_SEP	\
+	/* Save r19 */					ASM_LINE_SEP	\
+	SAVE_PIC(TREG)					ASM_LINE_SEP	\
+	/* Do syscall, delay loads # */			ASM_LINE_SEP	\
+	ble  0x100(%sr2,%r0)				ASM_LINE_SEP	\
+	ldi SYS_ify (syscall_name), %r20 /* delay */	ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1				ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)			ASM_LINE_SEP	\
+	/* Restore r19 from TREG */			ASM_LINE_SEP	\
+	LOAD_PIC(TREG) /* delay */			ASM_LINE_SEP	\
+	SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
+	/* Use TREG for temp storage */			ASM_LINE_SEP	\
+	copy %ret0, TREG /* delay */			ASM_LINE_SEP	\
+	/* OPTIMIZE: Don't reload r19 */		ASM_LINE_SEP	\
+	/* do a -1*syscall_ret0 */			ASM_LINE_SEP	\
+	sub %r0, TREG, TREG				ASM_LINE_SEP	\
+	/* Store into errno location */			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)				ASM_LINE_SEP	\
+	b L(pre_end)					ASM_LINE_SEP	\
+	/* return -1 as error */			ASM_LINE_SEP	\
+	ldo -1(%r0), %ret0 /* delay */			ASM_LINE_SEP	\
+L(pseudo_cancel):					ASM_LINE_SEP	\
+	PUSHARGS_##args /* Save args */			ASM_LINE_SEP	\
+	/* Save r19 into TREG */			ASM_LINE_SEP	\
+	CENABLE /* FUNC CALL */				ASM_LINE_SEP	\
+	SAVE_PIC(TREG) /* delay */			ASM_LINE_SEP	\
+	/* restore syscall args */			ASM_LINE_SEP	\
+	POPARGS_##args					ASM_LINE_SEP	\
+	/* save mask from cenable (use stub rp slot) */	ASM_LINE_SEP	\
+	stw %ret0, -24(%sp)				ASM_LINE_SEP	\
+	/* ... SYSCALL ... */				ASM_LINE_SEP	\
+	ble 0x100(%sr2,%r0)				ASM_LINE_SEP    \
+	ldi SYS_ify (syscall_name), %r20 /* delay */	ASM_LINE_SEP	\
+	/* ............... */				ASM_LINE_SEP	\
+	LOAD_PIC(TREG)					ASM_LINE_SEP	\
+	/* pass mask as arg0 to cdisable */		ASM_LINE_SEP	\
+	ldw -24(%sp), %r26				ASM_LINE_SEP	\
+	CDISABLE					ASM_LINE_SEP	\
+	stw %ret0, -24(%sp) /* delay */			ASM_LINE_SEP	\
+	/* Restore syscall return */			ASM_LINE_SEP	\
+	ldw -24(%sp), %ret0				ASM_LINE_SEP	\
+	/* compare error */				ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1				ASM_LINE_SEP	\
+	/* branch if no error */			ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)			ASM_LINE_SEP	\
+	LOAD_PIC(TREG)	/* cond. nullify */		ASM_LINE_SEP	\
+	copy %ret0, TREG /* save syscall return */	ASM_LINE_SEP	\
+	SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
+	/* make syscall res value positive */		ASM_LINE_SEP	\
+	sub %r0, TREG, TREG	/* delay */		ASM_LINE_SEP	\
+	/* No need to LOAD_PIC */			ASM_LINE_SEP	\
+	/* store into errno location */			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)				ASM_LINE_SEP	\
+	/* return -1 */					ASM_LINE_SEP	\
+	ldo -1(%r0), %ret0				ASM_LINE_SEP	\
+L(pre_end):						ASM_LINE_SEP	\
+	/* Restore rp before exit */			ASM_LINE_SEP	\
+	ldw -84(%sr0,%sp), %rp				ASM_LINE_SEP	\
+	/* Undo frame */				ASM_LINE_SEP	\
+	ldwm -64(%sp),TREG				ASM_LINE_SEP	\
+	/* No need to LOAD_PIC */			ASM_LINE_SEP
+
+/* Save arguments into our frame */
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 stw %r26, -36(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_2	PUSHARGS_1 stw %r25, -40(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_3	PUSHARGS_2 stw %r24, -44(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_4	PUSHARGS_3 stw %r23, -48(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_5	PUSHARGS_4 stw %r22, -52(%sr0,%sp)	ASM_LINE_SEP 
+# define PUSHARGS_6	PUSHARGS_5 stw %r21, -56(%sr0,%sp)	ASM_LINE_SEP
+
+/* Bring them back from the stack */
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 ldw -36(%sr0,%sp), %r26	ASM_LINE_SEP
+# define POPARGS_2	POPARGS_1 ldw -40(%sr0,%sp), %r25	ASM_LINE_SEP
+# define POPARGS_3	POPARGS_2 ldw -44(%sr0,%sp), %r24	ASM_LINE_SEP
+# define POPARGS_4	POPARGS_3 ldw -48(%sr0,%sp), %r23	ASM_LINE_SEP
+# define POPARGS_5	POPARGS_4 ldw -52(%sr0,%sp), %r22	ASM_LINE_SEP
+# define POPARGS_6	POPARGS_5 ldw -56(%sr0,%sp), %r21	ASM_LINE_SEP
+
+# ifdef IS_IN_libpthread
+#  ifdef PIC
+#   define CENABLE .import __pthread_enable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __pthread_disable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __pthread_enable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __pthread_disable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# elif !defined NOT_IN_libc
+#  ifdef PIC
+#   define CENABLE .import __libc_enable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE	.import __libc_disable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __libc_enable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE	.import __libc_disable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# else
+#  ifdef PIC
+#   define CENABLE .import __librt_enable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __librt_disable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __librt_enable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __librt_disable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# endif
+
+# ifdef IS_IN_libpthread
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  define __local_multiple_threads __libc_multiple_threads
+# else
+#  define __local_multiple_threads __librt_multiple_threads
+# endif
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+# else
+/* Read the value of header.multiple_threads from the thread pointer */
+#  define SINGLE_THREAD_P 							\
+	mfctl %cr27, %ret0					ASM_LINE_SEP	\
+	ldw MULTIPLE_THREADS_THREAD_OFFSET(%sr0,%ret0),%ret0	ASM_LINE_SEP
+# endif
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+# define NO_CANCELLATION 1
+
+#endif
+/* !defined NOT_IN_libc || defined IS_IN_libpthread */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/unwind-forcedunwind.c ports/sysdeps/unix/sysv/linux/hppa/nptl/unwind-forcedunwind.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/unwind-forcedunwind.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/unwind-forcedunwind.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,21 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define LIBGCC_S_SO "libgcc_s.so.2"
+#include <sysdeps/pthread/unwind-forcedunwind.c>
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/unwind-resume.c ports/sysdeps/unix/sysv/linux/hppa/nptl/unwind-resume.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/nptl/unwind-resume.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/nptl/unwind-resume.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1,21 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define LIBGCC_S_SO "libgcc_s.so.2"
+#include <sysdeps/pthread/unwind-resume.c>
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/sysdep.c ports/sysdeps/unix/sysv/linux/hppa/sysdep.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/sysdep.c	2003-10-15 07:45:16.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/hppa/sysdep.c	2006-05-15 02:44:14.000000000 +0200
@@ -16,12 +16,12 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <stdarg.h>
 #include <sysdep.h>
 #include <errno.h>
 
 extern int __syscall_error(int err_no);
-extern int syscall (int sysnum, int arg0, int arg1, int arg2,
-		    int arg3, int arg4, int arg5);
+extern long int syscall (long int __sysno, ...) __THROW;
 
 /* This routine is jumped to by all the syscall handlers, to stash
    an error number into errno.  */
@@ -37,22 +37,35 @@
    typically be in syscall.S. Also note that we have INLINE_SYSCALL,
    INTERNAL_SYSCALL, and all the generated pure assembly syscall wrappers.
    How often the function is used is unknown. */
-int
-syscall (int sysnum, int arg0, int arg1, int arg2, int arg3, int arg4,
-	 int arg5)
+
+long int 
+syscall (long int __sysno, ...) 
 {
   /* FIXME: Keep this matching INLINE_SYSCALL for hppa */
+  va_list args;
+  long int arg0, arg1, arg2, arg3, arg4, arg5;
   long int __sys_res;
+
+  /* Load varargs */
+  va_start (args, __sysno);
+  arg0 = va_arg (args, long int);
+  arg1 = va_arg (args, long int);
+  arg2 = va_arg (args, long int);
+  arg3 = va_arg (args, long int);
+  arg4 = va_arg (args, long int);
+  arg5 = va_arg (args, long int);
+  va_end (args);
+  
   {
     register unsigned long int __res asm("r28");
     LOAD_ARGS_6 (arg0, arg1, arg2, arg3, arg4, arg5)
-    asm volatile (STW_ASM_PIC
+    asm volatile (SAVE_ASM_PIC
 		  "	ble  0x100(%%sr2, %%r0)	\n"
 		  "	copy %1, %%r20		\n"
-		  LDW_ASM_PIC
+		  LOAD_ASM_PIC
 		  : "=r" (__res)
-		  : "r" (sysnum) ASM_ARGS_6
-		  : CALL_CLOB_REGS CLOB_ARGS_6);
+		  : "r" (__sysno) ASM_ARGS_6
+		  : "memory", CALL_CLOB_REGS CLOB_ARGS_6);
     __sys_res = __res;
   }
   if ((unsigned long int) __sys_res >= (unsigned long int) -4095)
@@ -62,3 +75,4 @@
     }
   return __sys_res;
 }
+
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/sysdep.h ports/sysdeps/unix/sysv/linux/hppa/sysdep.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/sysdep.h	2003-11-03 18:18:38.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/sysdep.h	2006-05-15 02:44:14.000000000 +0200
@@ -22,28 +22,34 @@
 #include <asm/unistd.h>
 #include <sysdeps/generic/sysdep.h>
 #include <sys/syscall.h>
-#include "config.h"
 
-#ifndef ASM_LINE_SEP
-# define ASM_LINE_SEP ;
-#endif
+#undef ASM_LINE_SEP
+#define ASM_LINE_SEP ! 
 
 #undef SYS_ify
 #define SYS_ify(syscall_name)	(__NR_##syscall_name)
 
+/* WARNING: TREG must be a callee saves register so 
+   that it doesn't have to be restored after a call 
+   to another function */
 #ifdef PIC
-/* WARNING: CANNOT BE USED IN A NOP! */
-# define STW_PIC stw %r19, -32(%sr0, %sp) ASM_LINE_SEP
-# define LDW_PIC ldw -32(%sr0, %sp), %r19 ASM_LINE_SEP
-# define STW_ASM_PIC	"       copy %%r19, %%r4\n"
-# define LDW_ASM_PIC	"       copy %%r4, %%r19\n"
-# define USING_GR4	"%r4",
+# define TREG %r3
+# define SAVE_PIC(SREG) copy %r19, SREG ASM_LINE_SEP
+# define LOAD_PIC(LREG) copy LREG, %r19 ASM_LINE_SEP
+/* Inline assembly defines */
+# define TREG_ASM "%r4" /* Cant clobber r3, it holds framemarker */
+# define SAVE_ASM_PIC	"       copy %%r19, %" TREG_ASM "\n"
+# define LOAD_ASM_PIC	"       copy %" TREG_ASM ", %%r19\n"
+# define USING_TREG	TREG_ASM,
 #else
-# define STW_PIC ASM_LINE_SEP
-# define LDW_PIC ASM_LINE_SEP
-# define STW_ASM_PIC	" \n"
-# define LDW_ASM_PIC	" \n"
-# define USING_GR4
+# define TREG %r3
+# define SAVE_PIC(SREG) nop ASM_LINE_SEP
+# define LOAD_PIC(LREG) nop ASM_LINE_SEP
+/* Inline assembly defines */
+# define TREG_ASM 
+# define SAVE_ASM_PIC	"nop \n"
+# define LOAD_ASM_PIC	"nop \n"
+# define USING_TREG
 #endif
 
 #ifdef __ASSEMBLER__
@@ -76,31 +82,73 @@
 
 /* We don't want the label for the error handle to be global when we define
    it here.  */
-#ifdef PIC
+/*#ifdef PIC
 # define SYSCALL_ERROR_LABEL 0f
 #else
 # define SYSCALL_ERROR_LABEL syscall_error
-#endif
+#endif*/
+
+/* Argument manipulation from the stack for preparing to
+   make a syscall */
+
+#define DOARGS_0 /* nothing */
+#define DOARGS_1 /* nothing */
+#define DOARGS_2 /* nothing */
+#define DOARGS_3 /* nothing */
+#define DOARGS_4 /* nothing */
+#define DOARGS_5 ldw -52(%sp), %r22		ASM_LINE_SEP
+#define DOARGS_6 DOARGS_5 ldw -56(%sp), %r21	ASM_LINE_SEP
+
+#define UNDOARGS_0 /* nothing */
+#define UNDOARGS_1 /* nothing */
+#define UNDOARGS_2 /* nothing */
+#define UNDOARGS_3 /* nothing */
+#define UNDOARGS_4 /* nothing */
+#define UNDOARGS_5 /* nothing */
+#define UNDOARGS_6 /* nothing */
 
 /* Define an entry point visible from C.
 
    There is currently a bug in gdb which prevents us from specifying
    incomplete stabs information.  Fake some entries here which specify
    the current source file.  */
-#define	ENTRY(name)						\
-	.text					ASM_LINE_SEP	\
-	.export C_SYMBOL_NAME(name)		ASM_LINE_SEP	\
-	.type	C_SYMBOL_NAME(name),@function	ASM_LINE_SEP	\
-	C_LABEL(name)				ASM_LINE_SEP	\
-	CALL_MCOUNT				ASM_LINE_SEP
+#define	ENTRY(name)							\
+	.text						ASM_LINE_SEP	\
+	.align ALIGNARG(4)				ASM_LINE_SEP	\
+	.export C_SYMBOL_NAME(name)			ASM_LINE_SEP	\
+	.type	C_SYMBOL_NAME(name),@function		ASM_LINE_SEP	\
+	C_LABEL(name)					ASM_LINE_SEP	\
+	.PROC						ASM_LINE_SEP	\
+	.CALLINFO FRAME=64,CALLS,SAVE_RP,ENTRY_GR=3	ASM_LINE_SEP	\
+	.ENTRY						ASM_LINE_SEP	\
+	/* SAVE_RP says we do */			ASM_LINE_SEP	\
+	stw %rp, -20(%sr0,%sp)				ASM_LINE_SEP	\
+	/*FIXME: Call mcount? (carefull with stack!) */
+
+/* Some syscall wrappers do not call other functions, and
+   hence are classified as leaf, so add NO_CALLS for gdb */
+#define	ENTRY_LEAF(name)						\
+	.text						ASM_LINE_SEP	\
+	.align ALIGNARG(4)				ASM_LINE_SEP	\
+	.export C_SYMBOL_NAME(name)			ASM_LINE_SEP	\
+	.type	C_SYMBOL_NAME(name),@function		ASM_LINE_SEP	\
+	C_LABEL(name)					ASM_LINE_SEP	\
+	.PROC						ASM_LINE_SEP	\
+	.CALLINFO FRAME=64,NO_CALLS,SAVE_RP,ENTRY_GR=3	ASM_LINE_SEP	\
+	.ENTRY						ASM_LINE_SEP	\
+	/* SAVE_RP says we do */			ASM_LINE_SEP	\
+	stw %rp, -20(%sr0,%sp)				ASM_LINE_SEP	\
+	/*FIXME: Call mcount? (carefull with stack!) */
 
 #undef	END
 #define END(name)							\
-1:							ASM_LINE_SEP	\
-.size	C_SYMBOL_NAME(name),1b-C_SYMBOL_NAME(name)	ASM_LINE_SEP
-
-/* If compiled for profiling, call `mcount' at the start of each function.  */
-/* No, don't bother.  gcc will put the call in for us.  */
+  	.EXIT						ASM_LINE_SEP	\
+	.PROCEND					ASM_LINE_SEP	\
+.size	C_SYMBOL_NAME(name), .-C_SYMBOL_NAME(name)	ASM_LINE_SEP
+
+/* If compiled for profiling, call `mcount' at the start 
+   of each function. No, don't bother.  gcc will put the 
+   call in for us.  */
 #define CALL_MCOUNT		/* Do nothing.  */
 
 /* syscall wrappers consist of
@@ -118,14 +166,16 @@
 */
 
 #define	PSEUDO(name, syscall_name, args)			\
-  ENTRY (name)							\
-  DO_CALL(syscall_name, args)			ASM_LINE_SEP	\
+  ENTRY (name)					ASM_LINE_SEP	\
+  /* If necc. load args from stack */		ASM_LINE_SEP	\
+  DOARGS_##args					ASM_LINE_SEP	\
+  DO_CALL (syscall_name, args)			ASM_LINE_SEP	\
+  UNDOARGS_##args				ASM_LINE_SEP	\
   nop						ASM_LINE_SEP
 
 #define ret \
-	/* Return value set by ERRNO code */	ASM_LINE_SEP	\
-	bv 0(2)					ASM_LINE_SEP	\
-	nop					ASM_LINE_SEP
+  /* Return value set by ERRNO code */		ASM_LINE_SEP	\
+  bv,n 0(2)					ASM_LINE_SEP
 
 #undef	PSEUDO_END
 #define	PSEUDO_END(name)					\
@@ -133,8 +183,10 @@
 
 /* We don't set the errno on the return from the syscall */
 #define	PSEUDO_NOERRNO(name, syscall_name, args)		\
-  ENTRY (name)							\
-  DO_CALL_NOERRNO(syscall_name, args)		ASM_LINE_SEP	\
+  ENTRY_LEAF (name)				ASM_LINE_SEP	\
+  DOARGS_##args					ASM_LINE_SEP	\
+  DO_CALL_NOERRNO (syscall_name, args)		ASM_LINE_SEP	\
+  UNDOARGS_##args				ASM_LINE_SEP	\
   nop						ASM_LINE_SEP
 
 #define ret_NOERRNO ret
@@ -146,9 +198,11 @@
 /* This has to return the error value */
 #undef  PSEUDO_ERRVAL
 #define PSEUDO_ERRVAL(name, syscall_name, args)			\
-	ENTRY(name)						\
-	DO_CALL_ERRVAL(syscall_name, args)	ASM_LINE_SEP	\
-	nop					ASM_LINE_SEP
+  ENTRY_LEAF (name)				ASM_LINE_SEP	\
+  DOARGS_##args					ASM_LINE_SEP	\
+  DO_CALL_ERRVAL (syscall_name, args)		ASM_LINE_SEP	\
+  UNDOARGS_##args				ASM_LINE_SEP	\
+  nop						ASM_LINE_SEP
 
 #define ret_ERRVAL ret
 
@@ -161,7 +215,8 @@
 #define SYSCALL_PIC_SETUP	/* Nothing.  */
 
 
-/* All the syscall assembly macros rely on finding the approriate
+/* FIXME: This comment is not true.
+ * All the syscall assembly macros rely on finding the approriate
    SYSCALL_ERROR_LABEL or rather HANDLER. */
 
 /* int * __errno_location(void) so you have to store your value
@@ -209,8 +264,8 @@
 	arg 2		gr25
 	arg 3		gr24
 	arg 4		gr23
-	arg 5		-52(gr30)
-	arg 6		-56(gr30)
+	arg 5		-52(sp)
+	arg 6		-56(sp)
 
    gr22 and gr21 are caller-saves, so we can just load the arguments
    there and generally be happy. */
@@ -219,46 +274,48 @@
  * is intended to mimic the if (__sys_res...)
  * code inside INLINE_SYSCALL
  */
+#define NO_ERROR -0x1000
 
 #undef	DO_CALL
 #define DO_CALL(syscall_name, args)				\
-	DOARGS_##args				ASM_LINE_SEP	\
-	STW_PIC					ASM_LINE_SEP	\
+  	copy TREG,%r1				ASM_LINE_SEP	\
+	copy %sp,TREG				ASM_LINE_SEP	\
+	/* Create a frame */			ASM_LINE_SEP	\
+	stwm %r1, 64(%sp)			ASM_LINE_SEP	\
+	stw %rp, -20(%sp)			ASM_LINE_SEP	\
+	stw TREG, -4(%sp)			ASM_LINE_SEP	\
+	/* Save r19 */				ASM_LINE_SEP	\
+	SAVE_PIC(TREG)				ASM_LINE_SEP	\
 	/* Do syscall, delay loads # */		ASM_LINE_SEP	\
 	ble  0x100(%sr2,%r0)			ASM_LINE_SEP	\
 	ldi SYS_ify (syscall_name), %r20	ASM_LINE_SEP	\
-	ldi -0x1000,%r1				ASM_LINE_SEP	\
-	cmpb,>>=,n %r1,%ret0,0f			ASM_LINE_SEP	\
-	/* save rp or we get lost */		ASM_LINE_SEP	\
-	stw %rp, -20(%sr0,%sp)			ASM_LINE_SEP	\
-	/* Restore r19 from frame */		ASM_LINE_SEP	\
-	LDW_PIC					ASM_LINE_SEP	\
-	stw %ret0, -24(%sr0,%sp)		ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1			ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)		ASM_LINE_SEP	\
+	/* Restore r19 from TREG */		ASM_LINE_SEP	\
+	LOAD_PIC(TREG) /* delay */		ASM_LINE_SEP	\
 	SYSCALL_ERROR_HANDLER			ASM_LINE_SEP	\
-	/* create frame */			ASM_LINE_SEP	\
-	ldo 64(%sp), %sp			ASM_LINE_SEP	\
-	ldo -64(%sp), %sp			ASM_LINE_SEP	\
+	/* Use TREG for temp storage */		ASM_LINE_SEP	\
+	copy %ret0, TREG /* delay */		ASM_LINE_SEP	\
 	/* OPTIMIZE: Don't reload r19 */	ASM_LINE_SEP	\
 	/* do a -1*syscall_ret0 */		ASM_LINE_SEP	\
-	ldw -24(%sr0,%sp), %r26			ASM_LINE_SEP	\
-	sub %r0, %r26, %r26			ASM_LINE_SEP	\
+	sub %r0, TREG, TREG			ASM_LINE_SEP	\
 	/* Store into errno location */		ASM_LINE_SEP	\
-	stw %r26, 0(%sr0,%ret0)			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)			ASM_LINE_SEP	\
 	/* return -1 as error */		ASM_LINE_SEP	\
 	ldo -1(%r0), %ret0			ASM_LINE_SEP	\
-	ldw -20(%sr0,%sp), %rp			ASM_LINE_SEP	\
-0:						ASM_LINE_SEP	\
-	UNDOARGS_##args				ASM_LINE_SEP
+L(pre_end):					ASM_LINE_SEP	\
+	/* Restore return pointer */		ASM_LINE_SEP	\
+	ldw -84(%sp),%rp			ASM_LINE_SEP	\
+	/* Restore our frame, restoring TREG */	ASM_LINE_SEP	\
+	ldwm -64(%sp), TREG			ASM_LINE_SEP
 
 /* We do nothing with the return, except hand it back to someone else */
 #undef  DO_CALL_NOERRNO
 #define DO_CALL_NOERRNO(syscall_name, args)			\
-	DOARGS_##args                                           \
 	/* No need to store r19 */		ASM_LINE_SEP	\
 	ble  0x100(%sr2,%r0)                    ASM_LINE_SEP    \
 	ldi SYS_ify (syscall_name), %r20        ASM_LINE_SEP    \
-	/* Caller will restore r19 */		ASM_LINE_SEP	\
-	UNDOARGS_##args
+	/* Caller will restore r19 */		ASM_LINE_SEP
 
 /* Here, we return the ERRVAL in assembly, note we don't call the
    error handler function, but we do 'negate' the return _IF_
@@ -266,35 +323,16 @@
 
 #undef	DO_CALL_ERRVAL
 #define DO_CALL_ERRVAL(syscall_name, args)			\
-	DOARGS_##args				ASM_LINE_SEP	\
 	/* No need to store r19 */		ASM_LINE_SEP	\
 	ble  0x100(%sr2,%r0)			ASM_LINE_SEP	\
 	ldi SYS_ify (syscall_name), %r20	ASM_LINE_SEP	\
 	/* Caller will restore r19 */		ASM_LINE_SEP	\
-	ldi -0x1000,%r1				ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1			ASM_LINE_SEP	\
 	cmpb,>>=,n %r1,%ret0,0f			ASM_LINE_SEP	\
 	sub %r0, %ret0, %ret0			ASM_LINE_SEP	\
-0:						ASM_LINE_SEP	\
-	UNDOARGS_##args				ASM_LINE_SEP
-
-#define DOARGS_0 /* nothing */
-#define DOARGS_1 /* nothing */
-#define DOARGS_2 /* nothing */
-#define DOARGS_3 /* nothing */
-#define DOARGS_4 /* nothing */
-#define DOARGS_5 ldw -52(%r30), %r22		ASM_LINE_SEP
-#define DOARGS_6 ldw -52(%r30), %r22		ASM_LINE_SEP	\
-		 ldw -56(%r30), %r21		ASM_LINE_SEP
+0:						ASM_LINE_SEP
 
 
-#define UNDOARGS_0 /* nothing */
-#define UNDOARGS_1 /* nothing */
-#define UNDOARGS_2 /* nothing */
-#define UNDOARGS_3 /* nothing */
-#define UNDOARGS_4 /* nothing */
-#define UNDOARGS_5 /* nothing */
-#define UNDOARGS_6 /* nothing */
-
 #else
 
 /* GCC has to be warned that a syscall may clobber all the ABI
@@ -305,27 +343,28 @@
    registers r20 -> r26 will conflict with the list so they
    are treated specially. Although r19 is clobbered by the syscall
    we cannot say this because it would violate ABI, thus we say
-   r4 is clobbered and use that register to save/restore r19
+   TREG is clobbered and use that register to save/restore r19
    across the syscall. */
 
-#define CALL_CLOB_REGS	"%r1", "%r2", USING_GR4 \
+#define CALL_CLOB_REGS	"%r1", "%r2", USING_TREG \
 		 	"%r20", "%r29", "%r31"
 
 #undef INLINE_SYSCALL
-#define INLINE_SYSCALL(name, nr, args...)	({			\
+#define INLINE_SYSCALL(name, nr, args...)				\
+({									\
 	long __sys_res;							\
 	{								\
 		register unsigned long __res asm("r28");		\
 		LOAD_ARGS_##nr(args)					\
-		/* FIXME: HACK stw/ldw r19 around syscall */		\
+		/* FIXME: HACK save/load r19 around syscall */		\
 		asm volatile(						\
-			STW_ASM_PIC					\
+			SAVE_ASM_PIC					\
 			"	ble  0x100(%%sr2, %%r0)\n"		\
 			"	ldi %1, %%r20\n"			\
-			LDW_ASM_PIC					\
+			LOAD_ASM_PIC					\
 			: "=r" (__res)					\
 			: "i" (SYS_ify(name)) ASM_ARGS_##nr		\
-			: CALL_CLOB_REGS CLOB_ARGS_##nr			\
+			: "memory", CALL_CLOB_REGS CLOB_ARGS_##nr	\
 		);							\
 		__sys_res = (long)__res;				\
 	}								\
@@ -339,13 +378,13 @@
 /* INTERNAL_SYSCALL_DECL - Allows us to setup some function static
    value to use within the context of the syscall
    INTERNAL_SYSCALL_ERROR_P - Returns 0 if it wasn't an error, 1 otherwise
-   You are allowed to use the syscall result (val) and the DECL error variable
-   to determine what went wrong.
+   You are allowed to use the syscall result (val) and the DECL error 
+   variable to determine what went wrong.
    INTERLAL_SYSCALL_ERRNO - Munges the val/err pair into the error number.
    In our case we just flip the sign. */
 
 #undef INTERNAL_SYSCALL_DECL
-#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+#define INTERNAL_SYSCALL_DECL(err) 
 
 /* Equivalent to  (val < 0)&&(val > -4095) which is what we want */
 #undef INTERNAL_SYSCALL_ERROR_P
@@ -357,46 +396,72 @@
 
 /* Similar to INLINE_SYSCALL but we don't set errno */
 #undef INTERNAL_SYSCALL
-#define INTERNAL_SYSCALL(name, err, nr, args...) 		\
-({								\
-	long __sys_res;						\
-	{							\
-		register unsigned long __res asm("r28");	\
-		LOAD_ARGS_##nr(args)				\
-		/* FIXME: HACK stw/ldw r19 around syscall */	\
-		asm volatile(					\
-			STW_ASM_PIC				\
-			"	ble  0x100(%%sr2, %%r0)\n"	\
-			"	ldi %1, %%r20\n"		\
-			LDW_ASM_PIC				\
-			: "=r" (__res)				\
-			: "i" (SYS_ify(name)) ASM_ARGS_##nr	\
-			: CALL_CLOB_REGS CLOB_ARGS_##nr		\
-		);						\
-		__sys_res = (long)__res;			\
-	}							\
-	__sys_res;						\
+#define INTERNAL_SYSCALL(name, err, nr, args...) 			\
+({									\
+	long __sys_res;							\
+	{								\
+		register unsigned long __res asm("r28");		\
+		LOAD_ARGS_##nr(args)					\
+		/* FIXME: HACK save/load r19 around syscall */		\
+		asm volatile(						\
+			SAVE_ASM_PIC					\
+			"	ble  0x100(%%sr2, %%r0)\n"		\
+			"	ldi %1, %%r20\n"			\
+			LOAD_ASM_PIC					\
+			: "=r" (__res)					\
+			: "i" (SYS_ify(name)) ASM_ARGS_##nr		\
+			: "memory", CALL_CLOB_REGS CLOB_ARGS_##nr	\
+		);							\
+		__sys_res = (long)__res;				\
+	}								\
+	__sys_res;							\
  })
 
+
+/* The _NCS variant allows non-constant syscall numbers.  */
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...) 			\
+({									\
+	long __sys_res;							\
+	{								\
+		register unsigned long __res asm("r28");		\
+		LOAD_ARGS_##nr(args)					\
+		/* FIXME: HACK save/load r19 around syscall */		\
+		asm volatile(						\
+			SAVE_ASM_PIC					\
+			"	ble  0x100(%%sr2, %%r0)\n"		\
+			"	copy %1, %%r20\n"			\
+			LOAD_ASM_PIC					\
+			: "=r" (__res)					\
+			: "r" (name) ASM_ARGS_##nr			\
+			: "memory", CALL_CLOB_REGS CLOB_ARGS_##nr	\
+		);							\
+		__sys_res = (long)__res;				\
+	}								\
+	__sys_res;							\
+ })
+
+
+
 #define LOAD_ARGS_0()
-#define LOAD_ARGS_1(r26)					\
-	register unsigned long __r26 __asm__("r26") = (unsigned long)(r26);   \
-	LOAD_ARGS_0()
-#define LOAD_ARGS_2(r26,r25)					\
-	register unsigned long __r25 __asm__("r25") = (unsigned long)(r25);   \
-	LOAD_ARGS_1(r26)
-#define LOAD_ARGS_3(r26,r25,r24)				\
-	register unsigned long __r24 __asm__("r24") = (unsigned long)(r24);   \
-	LOAD_ARGS_2(r26,r25)
-#define LOAD_ARGS_4(r26,r25,r24,r23)				\
-	register unsigned long __r23 __asm__("r23") = (unsigned long)(r23);   \
-	LOAD_ARGS_3(r26,r25,r24)
-#define LOAD_ARGS_5(r26,r25,r24,r23,r22)			\
-	register unsigned long __r22 __asm__("r22") = (unsigned long)(r22);   \
-	LOAD_ARGS_4(r26,r25,r24,r23)
-#define LOAD_ARGS_6(r26,r25,r24,r23,r22,r21)			\
-	register unsigned long __r21 __asm__("r21") = (unsigned long)(r21);   \
-	LOAD_ARGS_5(r26,r25,r24,r23,r22)
+#define LOAD_ARGS_1(r26)						\
+  register unsigned long __r26 __asm__("r26") = (unsigned long)(r26);	\
+  LOAD_ARGS_0()
+#define LOAD_ARGS_2(r26,r25)						\
+  register unsigned long __r25 __asm__("r25") = (unsigned long)(r25);	\
+  LOAD_ARGS_1(r26)
+#define LOAD_ARGS_3(r26,r25,r24)					\
+  register unsigned long __r24 __asm__("r24") = (unsigned long)(r24);	\
+  LOAD_ARGS_2(r26,r25)
+#define LOAD_ARGS_4(r26,r25,r24,r23)					\
+  register unsigned long __r23 __asm__("r23") = (unsigned long)(r23);	\
+  LOAD_ARGS_3(r26,r25,r24)
+#define LOAD_ARGS_5(r26,r25,r24,r23,r22)				\
+  register unsigned long __r22 __asm__("r22") = (unsigned long)(r22);	\
+  LOAD_ARGS_4(r26,r25,r24,r23)
+#define LOAD_ARGS_6(r26,r25,r24,r23,r22,r21)				\
+  register unsigned long __r21 __asm__("r21") = (unsigned long)(r21);	\
+  LOAD_ARGS_5(r26,r25,r24,r23,r22)
 
 /* Even with zero args we use r20 for the syscall number */
 #define ASM_ARGS_0
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/Versions ports/sysdeps/unix/sysv/linux/hppa/Versions
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/Versions	2002-08-29 01:55:01.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/hppa/Versions	2006-07-13 18:24:19.000000000 +0200
@@ -16,6 +16,9 @@
     #errlist-compat	254
     _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
   }
+  GLIBC_2.4 {
+    #errlist-compat	256
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
 }
 librt {
   GLIBC_2.3 {
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/xstat.c ports/sysdeps/unix/sysv/linux/hppa/xstat.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/hppa/xstat.c	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/hppa/xstat.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/xstat.c>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/fcntl.h ports/sysdeps/unix/sysv/linux/mips/bits/fcntl.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/fcntl.h	2004-11-24 05:37:34.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/bits/fcntl.h	2006-06-08 19:16:29.000000000 +0200
@@ -1,5 +1,5 @@
 /* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2002, 2003, 2004, 2006
 	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -18,32 +18,33 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-#ifndef _FCNTL_H
+#ifndef	_FCNTL_H
 # error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
 #endif
 
 #include <sgidefs.h>
 #include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
 
 /* open/fcntl - O_SYNC is only implemented on blocks devices and on files
    located on an ext2 file system */
-#define O_ACCMODE	0x0003
-#define O_RDONLY	0x0000
-#define O_WRONLY	0x0001
-#define O_RDWR		0x0002
-#define O_APPEND	0x0008
-#define O_SYNC		0x0010
-#define O_NONBLOCK	0x0080
-#define O_CREAT		0x0100	/* not fcntl */
-#define O_TRUNC		0x0200	/* not fcntl */
-#define O_EXCL		0x0400	/* not fcntl */
-#define O_NOCTTY	0x0800	/* not fcntl */
-#define O_FSYNC		O_SYNC
-#define O_ASYNC		0x1000
-
-#ifdef __USE_LARGEFILE64
-# define O_LARGEFILE	0x2000	/* Allow large file opens.  */
-#endif
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_APPEND	 0x0008
+#define O_SYNC		 0x0010
+#define O_NONBLOCK	 0x0080
+#define O_NDELAY	O_NONBLOCK
+#define O_CREAT		 0x0100	/* not fcntl */
+#define O_TRUNC		 0x0200	/* not fcntl */
+#define O_EXCL		 0x0400	/* not fcntl */
+#define O_NOCTTY	 0x0800	/* not fcntl */
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 0x1000
 
 #ifdef __USE_GNU
 # define O_NOFOLLOW	0x20000	/* Do not follow links.	 */
@@ -52,16 +53,18 @@
 # define O_NOATIME	0x40000	/* Do not set atime.  */
 #endif
 
-#define O_NDELAY	O_NONBLOCK
-
-/* For now Linux has no synchronisity options for data and read
-   operations.	We define the symbols here but let them do the same as
-   O_SYNC since this is a superset.  */
+/* For now Linux has no synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
 #if defined __USE_POSIX199309 || defined __USE_UNIX98
 # define O_DSYNC	O_SYNC	/* Synchronize data.  */
 # define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
 #endif
 
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0x2000	/* Allow large file opens.  */
+#endif
+
 /* Values for the second argument to `fcntl'.  */
 #define F_DUPFD		0	/* Duplicate file descriptor.  */
 #define F_GETFD		1	/* Get file descriptor flags.  */
@@ -98,7 +101,7 @@
 # define F_NOTIFY	1026	/* Request notfications on a directory.	 */
 #endif
 
-/* for F_[GET|SET]FL */
+/* For F_[GET|SET]FL.  */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
 /* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
@@ -106,12 +109,12 @@
 #define F_WRLCK		1	/* Write lock.	*/
 #define F_UNLCK		2	/* Remove lock.	 */
 
-/* for old implementation of bsd flock () */
+/* For old implementation of bsd flock().  */
 #define F_EXLCK		4	/* or 3 */
 #define F_SHLCK		8	/* or 4 */
 
 #ifdef __USE_BSD
-/* Operations for bsd flock(), also used by the kernel implementation */
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
 # define LOCK_SH	1	/* shared lock */
 # define LOCK_EX	2	/* exclusive lock */
 # define LOCK_NB	4	/* or'd with one of the above to prevent
@@ -137,7 +140,7 @@
 # define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
 #endif
 
-typedef struct flock
+struct flock
   {
     short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
     short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
@@ -159,7 +162,8 @@
        flock in o32 and n32, never has this field.  */
     long int pad[4];
 #endif
-} flock_t;
+  };
+typedef struct flock flock_t;
 
 #ifdef __USE_LARGEFILE64
 struct flock64
@@ -172,7 +176,6 @@
   };
 #endif
 
-
 /* Define some more compatibility macros to be backward compatible with
    BSD systems which did not managed to hide these kernel macros.  */
 #ifdef	__USE_BSD
@@ -192,3 +195,55 @@
 # define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
+
+
+#ifdef __USE_GNU
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+
+/* Splice address range into a pipe.  */
+extern int vmsplice (int __fdout, const struct iovec *__iov, size_t __count,
+		     unsigned int __flags);
+
+/* Splice two files together.  */
+extern int splice (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern int tee (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+
+#endif
+
+__END_DECLS
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/mman.h ports/sysdeps/unix/sysv/linux/mips/bits/mman.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/mman.h	2006-01-31 02:26:05.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/bits/mman.h	2006-05-05 16:17:22.000000000 +0200
@@ -50,7 +50,7 @@
 /* Other flags.  */
 #define MAP_FIXED	0x10		/* Interpret addr exactly.  */
 #ifdef __USE_MISC
-# define MAP_FILE	0x00
+# define MAP_FILE	0
 # define MAP_ANONYMOUS	0x0800		/* Don't use a file.  */
 # define MAP_ANON	MAP_ANONYMOUS
 # define MAP_RENAME	MAP_ANONYMOUS
@@ -70,26 +70,37 @@
 
 /* Flags to `msync'.  */
 #define MS_ASYNC	1		/* Sync memory asynchronously.  */
-#define MS_INVALIDATE	2		/* Invalidate the caches.  */
 #define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
 
 /* Flags for `mlockall'.  */
 #define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
 #define MCL_FUTURE	2		/* Lock all additions to address
 					   space.  */
 
-/* Advice to `madvise'.  */
-#ifdef __USE_BSD
-#define MADV_NORMAL	0		/* default page-in behavior */
-#define MADV_RANDOM	1		/* page-in minimum required */
-#define MADV_SEQUENTIAL	2		/* read-ahead aggressively */
-#define MADV_WILLNEED	3		/* pre-fault pages */
-#define MADV_DONTNEED	4		/* discard these pages */
-#define MADV_REMOVE	5		/* remove these pages & resources */
-#endif
-
 /* Flags for `mremap'.  */
 #ifdef __USE_GNU
 # define MREMAP_MAYMOVE	1
 # define MREMAP_FIXED	2
 #endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_REMOVE	 9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	 11	/* Do inherit across fork.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/poll.h ports/sysdeps/unix/sysv/linux/mips/bits/poll.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/poll.h	2001-07-31 09:46:05.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/mips/bits/poll.h	2006-03-28 06:25:50.000000000 +0200
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 2001, 2006 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -36,8 +36,10 @@
 #endif
 
 #ifdef __USE_GNU
-/* This is an extension for Linux.  */
+/* These are extensions for Linux.  */
 # define POLLMSG	0x400
+# define POLLREMOVE	0x1000
+# define POLLRDHUP	0x2000
 #endif
 
 /* Event types always implicitly polled for.  These bits need not be set in
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/resource.h ports/sysdeps/unix/sysv/linux/mips/bits/resource.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/resource.h	2005-06-20 17:07:34.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/mips/bits/resource.h	2006-06-02 17:37:27.000000000 +0200
@@ -1,5 +1,5 @@
 /* Bit values & structures for resource limits.  Linux/MIPS version.
-   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004, 2005
+   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004, 2005, 2006
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -98,7 +98,7 @@
   /* Maximum realtime priority allowed for non-priviledged
      processes.  */
   __RLIMIT_RTPRIO = 14,
-#define RLIMIT_RTPRIO _RLIMIT_RTPRIO
+#define RLIMIT_RTPRIO __RLIMIT_RTPRIO
 
   __RLIMIT_NLIMITS = 15,
   __RLIM_NLIMITS = __RLIMIT_NLIMITS
@@ -107,14 +107,22 @@
 };
 
 /* Value to indicate that there is no limit.  */
-#ifndef __USE_FILE_OFFSET64
-# define RLIM_INFINITY ((long int)(~0UL >> 1))
+#if _MIPS_SIM == _ABI64
+/* The N64 syscall uses this value.  */
+# define RLIM_INFINITY 0xffffffffffffffffUL
+# ifdef __USE_LARGEFILE64
+#  define RLIM64_INFINITY 0xffffffffffffffffUL
+# endif
 #else
-# define RLIM_INFINITY 0x7fffffffffffffffLL
-#endif
-
-#ifdef __USE_LARGEFILE64
-# define RLIM64_INFINITY 0x7fffffffffffffffLL
+/* The O32 and N32 syscalls use 0x7fffffff.  */
+# ifndef __USE_FILE_OFFSET64
+#  define RLIM_INFINITY ((long int)(~0UL >> 1))
+# else
+#  define RLIM_INFINITY 0x7fffffffffffffffULL
+# endif
+# ifdef __USE_LARGEFILE64
+#  define RLIM64_INFINITY 0x7fffffffffffffffULL
+# endif
 #endif
 
 /* We can represent all limits.  */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/sigcontext.h ports/sysdeps/unix/sysv/linux/mips/bits/sigcontext.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/sigcontext.h	2004-11-24 05:37:34.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/bits/sigcontext.h	2006-05-10 20:57:03.000000000 +0200
@@ -1,5 +1,5 @@
-/* Copyright (C) 1996, 1997, 1998, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004, 2006 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -16,90 +16,69 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H 1
+
 #if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
 # error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
 #endif
 
 #include <sgidefs.h>
 
-#ifndef sigcontext_struct
-/* Kernel headers before 2.1.1 define a struct sigcontext_struct, but
-   we need sigcontext.  */
-# define sigcontext_struct sigcontext
-
-/* # include <asm/sigcontext.h> */
-/* Instead of including the kernel header, that will vary depending on
-   whether the 32- or the 64-bit kernel is installed, we paste the
-   contents here.  In case you're wondering about the different
-   licenses, the fact that the file is pasted, instead of included,
-   doesn't really make any difference for the program that includes
-   this header.  */
 #if _MIPS_SIM == _ABIO32
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1996, 1997, 2000 by Ralf Baechle
- */
-#ifndef _ASM_SIGCONTEXT_H
-#define _ASM_SIGCONTEXT_H
-
-/*
- * Keep this struct definition in sync with the sigcontext fragment
- * in arch/mips/tools/offset.c
- */
-struct sigcontext {
-	unsigned int       sc_regmask;		/* Unused */
-	unsigned int       sc_status;
-	unsigned long long sc_pc;
-	unsigned long long sc_regs[32];
-	unsigned long long sc_fpregs[32];
-	unsigned int       sc_ownedfp;		/* Unused */
-	unsigned int       sc_fpc_csr;
-	unsigned int       sc_fpc_eir;		/* Unused */
-	unsigned int       sc_used_math;
-	unsigned int       sc_ssflags;		/* Unused */
-	unsigned long long sc_mdhi;
-	unsigned long long sc_mdlo;
 
-	unsigned int       sc_cause;		/* Unused */
-	unsigned int       sc_badvaddr;		/* Unused */
+/* Certain unused fields were replaced with new ones in 2.6.12-rc4.
+   The changes were as follows:
+
+   sc_cause -> sc_hi1
+   sc_badvaddr -> sc_lo1
+   sc_sigset[0] -> sc_hi2
+   sc_sigset[1] -> sc_lo2
+   sc_sigset[2] -> sc_hi3
+   sc_sigset[3] -> sc_lo3
 
-	unsigned long      sc_sigset[4];	/* kernel's sigset_t */
+   sc_regmask, sc_ownedfp and sc_fpc_eir are not used.  */
+struct sigcontext {
+  unsigned int sc_regmask;
+  unsigned int sc_status;
+  unsigned long long sc_pc;
+  unsigned long long sc_regs[32];
+  unsigned long long sc_fpregs[32];
+  unsigned int sc_ownedfp;
+  unsigned int sc_fpc_csr;
+  unsigned int sc_fpc_eir;
+  unsigned int sc_used_math;
+  unsigned int sc_dsp;
+  unsigned long long sc_mdhi;
+  unsigned long long sc_mdlo;
+  unsigned long sc_hi1;
+  unsigned long sc_lo1;
+  unsigned long sc_hi2;
+  unsigned long sc_lo2;
+  unsigned long sc_hi3;
+  unsigned long sc_lo3;
 };
 
-#endif /* _ASM_SIGCONTEXT_H */
-#else /* _MIPS_SIM != _ABIO32 */
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1996, 1997, 1999 by Ralf Baechle
- * Copyright (C) 1999 Silicon Graphics, Inc.
- */
-#ifndef _ASM_SIGCONTEXT_H
-#define _ASM_SIGCONTEXT_H
-
-/*
- * Keep this struct definition in sync with the sigcontext fragment
- * in arch/mips/tools/offset.c
- */
+#else
+
+/* This structure changed in 2.6.12-rc4 when DSP support was added.  */
 struct sigcontext {
-	unsigned long long sc_regs[32];
-	unsigned long long sc_fpregs[32];
-	unsigned long long sc_mdhi;
-	unsigned long long sc_mdlo;
-	unsigned long long sc_pc;
-	unsigned int       sc_status;
-	unsigned int       sc_fpc_csr;
-	unsigned int       sc_fpc_eir;
-	unsigned int       sc_used_math;
-	unsigned int       sc_cause;
-	unsigned int       sc_badvaddr;
+  unsigned long long sc_regs[32];
+  unsigned long long sc_fpregs[32];
+  unsigned long long sc_mdhi;
+  unsigned long long sc_hi1;
+  unsigned long long sc_hi2;
+  unsigned long long sc_hi3;
+  unsigned long long sc_mdlo;
+  unsigned long long sc_lo1;
+  unsigned long long sc_lo2;
+  unsigned long long sc_lo3;
+  unsigned long long sc_pc;
+  unsigned int sc_fpc_csr;
+  unsigned int sc_used_math;
+  unsigned int sc_dsp;
+  unsigned int sc_reserved;
 };
 
-#endif /* _ASM_SIGCONTEXT_H */
 #endif /* _MIPS_SIM != _ABIO32 */
 #endif
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/stat.h ports/sysdeps/unix/sysv/linux/mips/bits/stat.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/bits/stat.h	2004-11-24 05:37:34.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/bits/stat.h	2006-05-08 21:23:37.000000000 +0200
@@ -61,16 +61,27 @@
     long int st_pad2[3];
     __off64_t st_size;		/* Size of file, in bytes.  */
 #endif
-    /*
-     * Actually this should be timestruc_t st_atime, st_mtime and
-     * st_ctime but we don't have it under Linux.
-     */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;            /* Time of last access.  */
+    struct timespec st_mtim;            /* Time of last modification.  */
+    struct timespec st_ctim;            /* Time of last status change.  */
+# define st_atime st_atim.tv_sec        /* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;		/* Time of last access.  */
     long int __reserved0;
     __time_t st_mtime;		/* Time of last modification.  */
     long int __reserved1;
     __time_t st_ctime;		/* Time of last status change.  */
     long int __reserved2;
+#endif
     __blksize_t st_blksize;	/* Optimal block size for I/O.  */
 #ifndef __USE_FILE_OFFSET64
     __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
@@ -94,16 +105,24 @@
     unsigned long int st_rdev;	/* Device number, if device.  */
     long int st_pad2[3];
     __off64_t st_size;		/* Size of file, in bytes.  */
-    /*
-     * Actually this should be timestruc_t st_atime, st_mtime and
-     * st_ctime but we don't have it under Linux.
-     */
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;            /* Time of last access.  */
+    struct timespec st_mtim;            /* Time of last modification.  */
+    struct timespec st_ctim;            /* Time of last status change.  */
+#else
     __time_t st_atime;		/* Time of last access.  */
     long int __reserved0;
     __time_t st_mtime;		/* Time of last modification.  */
     long int __reserved1;
     __time_t st_ctime;		/* Time of last status change.  */
     long int __reserved2;
+#endif
     __blksize_t st_blksize;	/* Optimal block size for I/O.  */
     long int st_pad3;
     __blkcnt64_t st_blocks;	/* Number of 512-byte blocks allocated.  */
@@ -133,12 +152,27 @@
     unsigned int st_pad2[3];	/* Reserved for st_rdev expansion  */
     __off64_t st_size;
 #endif
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;            /* Time of last access.  */
+    struct timespec st_mtim;            /* Time of last modification.  */
+    struct timespec st_ctim;            /* Time of last status change.  */
+# define st_atime st_atim.tv_sec        /* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
     __time_t st_atime;
     int __reserved0;
     __time_t st_mtime;
     int __reserved1;
     __time_t st_ctime;
     int __reserved2;
+#endif
     __blksize_t st_blksize;
     unsigned int st_pad4;
 #ifndef __USE_FILE_OFFSET64
@@ -162,12 +196,24 @@
     __dev_t st_rdev;
     unsigned int st_pad2[3];	/* Reserved for st_rdev expansion  */
     __off64_t st_size;
+#ifdef __USE_MISC
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;            /* Time of last access.  */
+    struct timespec st_mtim;            /* Time of last modification.  */
+    struct timespec st_ctim;            /* Time of last status change.  */
+#else
     __time_t st_atime;
     int __reserved0;
     __time_t st_mtime;
     int __reserved1;
     __time_t st_ctime;
     int __reserved2;
+#endif
     __blksize_t st_blksize;
     unsigned int st_pad3;
     __blkcnt64_t st_blocks;
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/configure ports/sysdeps/unix/sysv/linux/mips/configure
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/configure	2006-03-06 12:11:40.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/configure	2006-03-11 17:18:41.000000000 +0100
@@ -76,3 +76,37 @@
   echo '#include <asm/unistd.h>' > asm-unistd.h
   ;;
 esac
+
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  mips/mips64/n64/* )
+    libc_cv_slibdir="/lib64"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib64';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.0
+  libc_cv_gcc_unwind_find_fde=yes
+fi
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/configure.in ports/sysdeps/unix/sysv/linux/mips/configure.in
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/configure.in	2005-02-25 16:18:06.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/configure.in	2006-03-11 17:18:41.000000000 +0100
@@ -76,3 +76,37 @@
   echo '#include <asm/unistd.h>' > asm-unistd.h
   ;;
 esac
+
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  mips/mips64/n64/* )
+    libc_cv_slibdir="/lib64"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib64';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.0
+  libc_cv_gcc_unwind_find_fde=yes
+fi
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/kernel_stat.h ports/sysdeps/unix/sysv/linux/mips/kernel_stat.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/kernel_stat.h	2004-11-24 05:37:35.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/kernel_stat.h	2006-06-02 17:29:03.000000000 +0200
@@ -16,12 +16,12 @@
     unsigned int st_rdev;
     unsigned int __pad2[3];
     long long st_size;
-    unsigned int st_atime;
-    unsigned int __unused1;
-    unsigned int st_mtime;
-    unsigned int __unused2;
-    unsigned int st_ctime;
-    unsigned int __unused3;
+    unsigned int st_atime_sec;
+    unsigned int st_atime_nsec;
+    unsigned int st_mtime_sec;
+    unsigned int st_mtime_nsec;
+    unsigned int st_ctime_sec;
+    unsigned int st_ctime_nsec;
     unsigned int st_blksize;
     unsigned int __pad3;
     unsigned long long st_blocks;
@@ -40,12 +40,12 @@
     long int __pad2[2];
     long int st_size;
     long int __pad3;
-    long int st_atime;
-    long int __unused1;
-    long int st_mtime;
-    long int __unused2;
-    long int st_ctime;
-    long int __unused3;
+    unsigned int st_atime_sec;
+    unsigned int st_atime_nsec;
+    unsigned int st_mtime_sec;
+    unsigned int st_mtime_nsec;
+    unsigned int st_ctime_sec;
+    unsigned int st_ctime_nsec;
     long int st_blksize;
     long int st_blocks;
     char st_fstype[16];			/* Filesystem type name, unsupported */
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/mips64/configure ports/sysdeps/unix/sysv/linux/mips/mips64/configure
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/mips64/configure	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/mips64/configure	2006-03-11 17:18:41.000000000 +0100
@@ -0,0 +1,4 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/sysv/linux/mips/mips64.
+
+ldd_rewrite_script=$dest/ldd-rewrite.sed
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/mips64/configure.in ports/sysdeps/unix/sysv/linux/mips/mips64/configure.in
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/mips64/configure.in	1970-01-01 01:00:00.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/mips64/configure.in	2006-03-11 17:18:41.000000000 +0100
@@ -0,0 +1,5 @@
+sinclude(./aclocal.m4)dnl Autoconf lossage
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/mips/mips64.
+
+ldd_rewrite_script=$dest/ldd-rewrite.sed
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/nptl/fork.c ports/sysdeps/unix/sysv/linux/mips/nptl/fork.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/nptl/fork.c	2005-03-28 11:21:52.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/mips/nptl/fork.c	2006-03-11 17:20:03.000000000 +0100
@@ -1 +1 @@
-#include "../i386/fork.c"
+#include <sysdeps/unix/sysv/linux/i386/fork.c>
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/register-dump.h ports/sysdeps/unix/sysv/linux/mips/register-dump.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/register-dump.h	2002-07-13 01:25:56.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/mips/register-dump.h	2006-05-10 20:57:03.000000000 +0200
@@ -1,5 +1,5 @@
 /* Dump registers.
-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2006 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Andreas Jaeger <aj@suse.de>, 2000.
 
@@ -27,8 +27,8 @@
  R8   XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
  R16  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
  R24  XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
-           pc    cause  status   badvaddr       lo       hi
-      XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
+            pc       lo       hi
+      XXXXXXXX XXXXXXXX XXXXXXXX
  The FPU registers will not be printed.
 */
 
@@ -61,11 +61,8 @@
   for (i = 0; i < 32; i++)
     hexvalue (ctx->sc_regs[i], regs[i], 8);
   hexvalue (ctx->sc_pc, regs[32], 8);
-  hexvalue (ctx->sc_cause, regs[33], 8);
-  hexvalue (ctx->sc_status, regs[34], 8);
-  hexvalue (ctx->sc_badvaddr, regs[35], 8);
-  hexvalue (ctx->sc_mdhi, regs[36], 8);
-  hexvalue (ctx->sc_mdlo, regs[37], 8);
+  hexvalue (ctx->sc_mdhi, regs[33], 8);
+  hexvalue (ctx->sc_mdlo, regs[34], 8);
 
   /* Generate the output.  */
   ADD_STRING ("Register dump:\n\n R0   ");
@@ -92,8 +89,8 @@
       ADD_MEM (regs[i], 8);
       ADD_STRING (" ");
     }
-  ADD_STRING ("\n           pc    cause  status   badvaddr       lo       hi\n      ");
-  for (i = 32; i < 38; i++)
+  ADD_STRING ("\n            pc       lo       hi\n      ");
+  for (i = 32; i < 35; i++)
     {
       ADD_MEM (regs[i], 8);
       ADD_STRING (" ");
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/sigaction.c ports/sysdeps/unix/sysv/linux/mips/sigaction.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/sigaction.c	2006-01-08 09:21:17.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/sigaction.c	2006-07-24 17:42:07.000000000 +0200
@@ -153,6 +153,10 @@
 }
 libc_hidden_def (__libc_sigaction)
 
+#ifdef WRAPPER_INCLUDE
+# include WRAPPER_INCLUDE
+#endif
+
 #ifndef LIBC_SIGACTION
 weak_alias (__libc_sigaction, __sigaction)
 libc_hidden_weak (__sigaction)
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/sys/ucontext.h ports/sysdeps/unix/sysv/linux/mips/sys/ucontext.h
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/sys/ucontext.h	2004-11-24 05:36:11.000000000 +0100
+++ ports/sysdeps/unix/sysv/linux/mips/sys/ucontext.h	2006-05-10 20:57:03.000000000 +0200
@@ -1,5 +1,5 @@
-/* Copyright (C) 1997, 1998, 2000, 2003, 2004 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
+/* Copyright (C) 1997, 1998, 2000, 2003, 2004, 2006 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -73,11 +73,15 @@
     unsigned int fpc_csr;
     unsigned int fpc_eir;
     unsigned int used_math;
-    unsigned int ssflags;
+    unsigned int dsp;
     greg_t mdhi;
     greg_t mdlo;
-    unsigned int cause;
-    unsigned int badvaddr;
+    unsigned long hi1;
+    unsigned long lo1;
+    unsigned long hi2;
+    unsigned long lo2;
+    unsigned long hi3;
+    unsigned long lo3;
   } mcontext_t;
 #else
 typedef struct
@@ -85,14 +89,18 @@
     gregset_t gregs;
     fpregset_t fpregs;
     greg_t mdhi;
+    greg_t hi1;
+    greg_t hi2;
+    greg_t hi3;
     greg_t mdlo;
+    greg_t lo1;
+    greg_t lo2;
+    greg_t lo3;
     greg_t pc;
-    unsigned int status;
     unsigned int fpc_csr;
-    unsigned int fpc_eir;
     unsigned int used_math;
-    unsigned int cause;
-    unsigned int badvaddr;
+    unsigned int dsp;
+    unsigned int reserved;
   } mcontext_t;
 #endif
 
diff -x .cvs -x .svn -x CVS -urN /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/xstatconv.c ports/sysdeps/unix/sysv/linux/mips/xstatconv.c
--- /home/rsc/svn/oselas/toolchain/build-cross/glibc-ports-2.4/sysdeps/unix/sysv/linux/mips/xstatconv.c	2003-06-30 11:33:13.000000000 +0200
+++ ports/sysdeps/unix/sysv/linux/mips/xstatconv.c	2006-06-02 17:29:03.000000000 +0200
@@ -62,9 +62,12 @@
 	buf->st_blksize = kbuf->st_blksize;
 	buf->st_blocks = kbuf->st_blocks;
 
-	buf->st_atime = kbuf->st_atime; buf->__reserved0 = 0;
-	buf->st_mtime = kbuf->st_mtime; buf->__reserved1 = 0;
-	buf->st_ctime = kbuf->st_ctime; buf->__reserved2 = 0;
+	buf->st_atim.tv_sec = kbuf->st_atime_sec;
+	buf->st_atim.tv_nsec = kbuf->st_atime_nsec;
+	buf->st_mtim.tv_sec = kbuf->st_mtime_sec;
+	buf->st_mtim.tv_nsec = kbuf->st_mtime_nsec;
+	buf->st_ctim.tv_sec = kbuf->st_ctime_sec;
+	buf->st_ctim.tv_nsec = kbuf->st_ctime_nsec;
 
 	buf->st_pad5[0] = 0; buf->st_pad5[1] = 0;
 	buf->st_pad5[2] = 0; buf->st_pad5[3] = 0;
@@ -107,9 +110,12 @@
 	buf->st_blksize = kbuf->st_blksize;
 	buf->st_blocks = kbuf->st_blocks;
 
-	buf->st_atime = kbuf->st_atime; buf->__reserved0 = 0;
-	buf->st_mtime = kbuf->st_mtime; buf->__reserved1 = 0;
-	buf->st_ctime = kbuf->st_ctime; buf->__reserved2 = 0;
+	buf->st_atim.tv_sec = kbuf->st_atime_sec;
+	buf->st_atim.tv_nsec = kbuf->st_atime_nsec;
+	buf->st_mtim.tv_sec = kbuf->st_mtime_sec;
+	buf->st_mtim.tv_nsec = kbuf->st_mtime_nsec;
+	buf->st_ctim.tv_sec = kbuf->st_ctime_sec;
+	buf->st_ctim.tv_nsec = kbuf->st_ctime_nsec;
 
 	buf->st_pad4[0] = 0; buf->st_pad4[1] = 0;
 	buf->st_pad4[2] = 0; buf->st_pad4[3] = 0;
