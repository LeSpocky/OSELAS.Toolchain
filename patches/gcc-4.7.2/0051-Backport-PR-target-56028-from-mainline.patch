From: uros <uros@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Sun, 27 Jan 2013 14:28:19 +0000
Subject: [PATCH] Backport PR target/56028 from mainline

Backport from mainline 2013-01-22 Uros Bizjak <ubizjak@gmail.com>

	PR target/56028
	* config/i386/i386.md (*movti_internal_rex64): Change (o,riF)
	alternative to (o,r).
	(*movdi_internal_rex64): Remove (!o,n) alternative.
	(DImode immediate->memory splitter): Remove.
	(DImode immediate->memory peephole2): Remove.
	(movtf): Enable for TARGET_64BIT || TARGET_SSE.
	(*movtf_internal_rex64): Rename from *movtf_internal. Change (!o,F*r)
	alternative to (!o,*r).
	(*movtf_internal_sse): New pattern.
	(*movxf_internal_rex64): New pattern.
	(*movxf_internal): Disable for TARGET_64BIT.
	(*movdf_internal_rex64): Remove (!o,F) alternative.

	2013-01-23  Uros Bizjak  <ubizjak@gmail.com>

	* config/i386/i386.md (*movdf_internal_rex64): Disparage alternatives
	involving stack registers slightly.

	2013-01-24  Uros Bizjak  <ubizjak@gmail.com>

	* config/i386/constraints.md (Yf): New constraint.
	* config/i386/i386.md (*movdf_internal_rex64): Use Yf*f instead
	of f constraint to conditionaly disable x87 register preferences.
	(*movdf_internal): Ditto.
	(*movsf_internal): Ditto.

	2012-01-24  Uros Bizjak  <ubizjak@gmail.com>

	* config/i386/i386.md (*movti_internal_rex64): Add (o,e) alternative.
	(*movtf_internal_rex64): Add (!o,C) alternative
	(*movxf_internal_rex64): Ditto.
	(*movdf_internal_rex64): Add (?r,C) and (?m,C) alternatives.

testsuite/ChangeLog:

	Backport from mainline
	2013-01-22  Uros Bizjak  <ubizjak@gmail.com>

	PR target/56028
	* gcc.target/i386/pr56028.c: New test.

	2013-01-24  Uros Bizjak  <ubizjak@gmail.com>

	* gcc.target/i386/movsd.c: New test.

git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_7-branch@195495 138bc75d-0d04-0410-961f-82ee72b054a4

Signed-off-by: Michael Olbrich <m.olbrich@pengutronix.de>
---
 gcc/ChangeLog                           |   39 ++++++
 gcc/config/i386/constraints.md          |    5 +
 gcc/config/i386/i386.md                 |  197 +++++++++++++++++++------------
 gcc/testsuite/ChangeLog                 |   12 ++
 gcc/testsuite/gcc.target/i386/movsd.c   |   15 +++
 gcc/testsuite/gcc.target/i386/pr56028.c |   54 +++++++++
 6 files changed, 249 insertions(+), 73 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/i386/movsd.c
 create mode 100644 gcc/testsuite/gcc.target/i386/pr56028.c

diff --git a/gcc/config/i386/constraints.md b/gcc/config/i386/constraints.md
index 5a19307..25327dd 100644
--- a/gcc/config/i386/constraints.md
+++ b/gcc/config/i386/constraints.md
@@ -92,6 +92,7 @@
 ;;  p	Integer register when TARGET_PARTIAL_REG_STALL is disabled
 ;;  d	Integer register when integer DFmode moves are enabled
 ;;  x	Integer register when integer XFmode moves are enabled
+;;  f	x87 register when 80387 floating point arithmetic is enabled
 
 (define_register_constraint "Yz" "TARGET_SSE ? SSE_FIRST_REG : NO_REGS"
  "First SSE register (@code{%xmm0}).")
@@ -118,6 +119,10 @@
  "optimize_function_for_speed_p (cfun) ? GENERAL_REGS : NO_REGS"
  "@internal Any integer register when integer XFmode moves are enabled.")
 
+(define_register_constraint "Yf"
+ "(ix86_fpmath & FPMATH_387) ? FLOAT_REGS : NO_REGS"
+ "@internal Any x87 register when 80387 FP arithmetic is enabled.")
+
 (define_constraint "z"
   "@internal Constant call address operand."
   (match_operand 0 "constant_call_address_operand"))
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index eace56d..16dafb3 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -1824,8 +1824,8 @@
    (set_attr "mode" "OI")])
 
 (define_insn "*movti_internal_rex64"
-  [(set (match_operand:TI 0 "nonimmediate_operand" "=!r,o,x,x,xm")
-	(match_operand:TI 1 "general_operand" "riFo,riF,C,xm,x"))]
+  [(set (match_operand:TI 0 "nonimmediate_operand" "=!r,o,x,x,m")
+	(match_operand:TI 1 "general_operand" "riFo,re,C,xm,x"))]
   "TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
 {
   switch (which_alternative)
@@ -1928,9 +1928,9 @@
 
 (define_insn "*movdi_internal_rex64"
   [(set (match_operand:DI 0 "nonimmediate_operand"
-	  "=r,r  ,r,m ,!o,*y,m*y,?*y,?r ,?*Ym,*x,m ,*x,*x,?r ,?*Yi,?*x,?*Ym")
+	  "=r,r  ,r,m ,*y,m*y,?*y,?r ,?*Ym,*x,m ,*x,*x,?r ,?*Yi,?*x,?*Ym")
 	(match_operand:DI 1 "general_operand"
-	  "Z ,rem,i,re,n ,C ,*y ,m  ,*Ym,r   ,C ,*x,*x,m ,*Yi,r   ,*Ym,*x"))]
+	  "Z ,rem,i,re,C ,*y ,m  ,*Ym,r   ,C ,*x,*x,m ,*Yi,r   ,*Ym,*x"))]
   "TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))"
 {
   switch (get_attr_type (insn))
@@ -1963,9 +1963,6 @@
     case TYPE_MMX:
       return "pxor\t%0, %0";
 
-    case TYPE_MULTI:
-      return "#";
-
     case TYPE_LEA:
       return "lea{q}\t{%E1, %0|%0, %E1}";
 
@@ -1983,16 +1980,14 @@
 }
   [(set (attr "type")
      (cond [(eq_attr "alternative" "4")
-	      (const_string "multi")
-	    (eq_attr "alternative" "5")
 	      (const_string "mmx")
-	    (eq_attr "alternative" "6,7,8,9")
+	    (eq_attr "alternative" "5,6,7,8")
 	      (const_string "mmxmov")
-	    (eq_attr "alternative" "10")
+	    (eq_attr "alternative" "9")
 	      (const_string "sselog1")
-	    (eq_attr "alternative" "11,12,13,14,15")
+	    (eq_attr "alternative" "10,11,12,13,14")
 	      (const_string "ssemov")
-	    (eq_attr "alternative" "16,17")
+	    (eq_attr "alternative" "15,16")
 	      (const_string "ssecvt")
  	    (match_operand 1 "pic_32bit_operand" "")
 	      (const_string "lea")
@@ -2009,18 +2004,18 @@
 	 (const_string "8")
 	 (const_string "*")))
    (set (attr "prefix_rex")
-     (if_then_else (eq_attr "alternative" "8,9")
+     (if_then_else (eq_attr "alternative" "7,8")
        (const_string "1")
        (const_string "*")))
    (set (attr "prefix_data16")
-     (if_then_else (eq_attr "alternative" "11")
+     (if_then_else (eq_attr "alternative" "10")
        (const_string "1")
        (const_string "*")))
    (set (attr "prefix")
-     (if_then_else (eq_attr "alternative" "10,11,12,13,14,15")
+     (if_then_else (eq_attr "alternative" "11,12,13,14,15")
        (const_string "maybe_vex")
        (const_string "orig")))
-   (set_attr "mode" "SI,DI,DI,DI,SI,DI,DI,DI,DI,DI,TI,DI,TI,DI,DI,DI,DI,DI")])
+   (set_attr "mode" "SI,DI,DI,DI,DI,DI,DI,DI,DI,TI,DI,TI,DI,DI,DI,DI,DI")])
 
 ;; Reload patterns to support multi-word load/store
 ;; with non-offsetable address.
@@ -2056,41 +2051,6 @@
   DONE;
 })
 
-;; Convert impossible stores of immediate to existing instructions.
-;; First try to get scratch register and go through it.  In case this
-;; fails, move by 32bit parts.
-(define_peephole2
-  [(match_scratch:DI 2 "r")
-   (set (match_operand:DI 0 "memory_operand" "")
-        (match_operand:DI 1 "immediate_operand" ""))]
-  "TARGET_64BIT && !symbolic_operand (operands[1], DImode)
-   && !x86_64_immediate_operand (operands[1], DImode)"
-  [(set (match_dup 2) (match_dup 1))
-   (set (match_dup 0) (match_dup 2))])
-
-;; We need to define this as both peepholer and splitter for case
-;; peephole2 pass is not run.
-;; "&& 1" is needed to keep it from matching the previous pattern.
-(define_peephole2
-  [(set (match_operand:DI 0 "memory_operand" "")
-        (match_operand:DI 1 "immediate_operand" ""))]
-  "TARGET_64BIT && !symbolic_operand (operands[1], DImode)
-   && !x86_64_immediate_operand (operands[1], DImode) && 1"
-  [(set (match_dup 2) (match_dup 3))
-   (set (match_dup 4) (match_dup 5))]
-  "split_double_mode (DImode, &operands[0], 2, &operands[2], &operands[4]);")
-
-(define_split
-  [(set (match_operand:DI 0 "memory_operand" "")
-        (match_operand:DI 1 "immediate_operand" ""))]
-  "TARGET_64BIT && ((optimize > 0 && flag_peephole2)
-		    ? epilogue_completed : reload_completed)
-   && !symbolic_operand (operands[1], DImode)
-   && !x86_64_immediate_operand (operands[1], DImode)"
-  [(set (match_dup 2) (match_dup 3))
-   (set (match_dup 4) (match_dup 5))]
-  "split_double_mode (DImode, &operands[0], 2, &operands[2], &operands[4]);")
-
 (define_insn "*movdi_internal"
   [(set (match_operand:DI 0 "nonimmediate_operand"
 	  "=r  ,o  ,*y,m*y,*y,*x,m ,*x,*x,*x,m ,*x,*x,?*x,?*Ym")
@@ -2798,7 +2758,7 @@
 (define_expand "movtf"
   [(set (match_operand:TF 0 "nonimmediate_operand" "")
 	(match_operand:TF 1 "nonimmediate_operand" ""))]
-  "TARGET_SSE2"
+  "TARGET_64BIT || TARGET_SSE2"
 {
   ix86_expand_move (TFmode, operands);
   DONE;
@@ -2810,11 +2770,10 @@
   ""
   "ix86_expand_move (<MODE>mode, operands); DONE;")
 
-(define_insn "*movtf_internal"
+(define_insn "*movtf_internal_rex64"
   [(set (match_operand:TF 0 "nonimmediate_operand" "=x,m,x,?*r ,!o")
-	(match_operand:TF 1 "general_operand"	   "xm,x,C,*roF,F*r"))]
-  "TARGET_SSE2
-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))
+	(match_operand:TF 1 "general_operand"	   "xm,x,C,*roF,*r"))]
+  "TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (!can_create_pseudo_p ()
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
        || GET_CODE (operands[1]) != CONST_DOUBLE
@@ -2873,11 +2832,103 @@
 		   (const_string "TI"))]
 	       (const_string "DI")))])
 
+(define_insn "*movtf_internal_sse2"
+  [(set (match_operand:TF 0 "nonimmediate_operand" "=x,m,x")
+	(match_operand:TF 1 "general_operand"  	   "xm,x,C"))]
+  "TARGET_SSE2 && !TARGET_64BIT
+   && !(MEM_P (operands[0]) && MEM_P (operands[1]))
+   && (!can_create_pseudo_p ()
+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
+       || GET_CODE (operands[1]) != CONST_DOUBLE
+       || (optimize_function_for_size_p (cfun)
+	   && standard_sse_constant_p (operands[1])
+	   && !memory_operand (operands[0], TFmode))
+       || (!TARGET_MEMORY_MISMATCH_STALL
+	   && memory_operand (operands[0], TFmode)))"
+{
+  switch (which_alternative)
+    {
+    case 0:
+    case 1:
+      /* Handle misaligned load/store since we
+         don't have movmisaligntf pattern. */
+      if (misaligned_operand (operands[0], TFmode)
+	  || misaligned_operand (operands[1], TFmode))
+	{
+	  if (get_attr_mode (insn) == MODE_V4SF)
+	    return "%vmovups\t{%1, %0|%0, %1}";
+	  else
+	    return "%vmovdqu\t{%1, %0|%0, %1}";
+	}
+      else
+	{
+	  if (get_attr_mode (insn) == MODE_V4SF)
+	    return "%vmovaps\t{%1, %0|%0, %1}";
+	  else
+	    return "%vmovdqa\t{%1, %0|%0, %1}";
+	}
+
+    case 2:
+      return standard_sse_constant_opcode (insn, operands[1]);
+
+    default:
+      gcc_unreachable ();
+    }
+}
+  [(set_attr "type" "ssemov,ssemov,sselog1")
+   (set_attr "prefix" "maybe_vex")
+   (set (attr "mode")
+        (cond [(eq_attr "alternative" "0,2")
+		 (if_then_else
+		   (match_test "optimize_function_for_size_p (cfun)")
+		   (const_string "V4SF")
+		   (const_string "TI"))
+	       (eq_attr "alternative" "1")
+		 (if_then_else
+		   (ior (match_test "TARGET_SSE_TYPELESS_STORES")
+			(match_test "optimize_function_for_size_p (cfun)"))
+		   (const_string "V4SF")
+		   (const_string "TI"))]
+	       (const_string "DI")))])
+
+(define_insn "*movxf_internal_rex64"
+  [(set (match_operand:XF 0 "nonimmediate_operand" "=f,m,f,?Yx*r ,!o")
+	(match_operand:XF 1 "general_operand"	   "fm,f,G,Yx*roF,Yx*rC"))]
+  "TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
+   && (!can_create_pseudo_p ()
+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
+       || GET_CODE (operands[1]) != CONST_DOUBLE
+       || (optimize_function_for_size_p (cfun)
+	   && standard_80387_constant_p (operands[1]) > 0
+	   && !memory_operand (operands[0], XFmode))
+       || (!TARGET_MEMORY_MISMATCH_STALL
+	   && memory_operand (operands[0], XFmode)))"
+{
+  switch (which_alternative)
+    {
+    case 0:
+    case 1:
+      return output_387_reg_move (insn, operands);
+
+    case 2:
+      return standard_80387_constant_opcode (operands[1]);
+
+    case 3:
+    case 4:
+      return "#";
+
+    default:
+      gcc_unreachable ();
+    }
+}
+  [(set_attr "type" "fmov,fmov,fmov,multi,multi")
+   (set_attr "mode" "XF,XF,XF,SI,SI")])
+
 ;; Possible store forwarding (partial memory) stall in alternative 4.
 (define_insn "*movxf_internal"
   [(set (match_operand:XF 0 "nonimmediate_operand" "=f,m,f,?Yx*r ,!o")
-	(match_operand:XF 1 "general_operand"	   "fm,f,G,Yx*roF,FYx*r"))]
-  "!(MEM_P (operands[0]) && MEM_P (operands[1]))
+	(match_operand:XF 1 "general_operand"	   "fm,f,G,Yx*roF,Yx*rF"))]
+  "!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (!can_create_pseudo_p ()
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
        || GET_CODE (operands[1]) != CONST_DOUBLE
@@ -2909,9 +2960,9 @@
 
 (define_insn "*movdf_internal_rex64"
   [(set (match_operand:DF 0 "nonimmediate_operand"
-		"=f,m,f,?r,?m,?r,!o,x,x,x,m,Yi,r ")
+		"=?Yf*f,?m   ,?Yf*f,?r,?m,?r,?r,x,x,x,m,Yi,r ")
 	(match_operand:DF 1 "general_operand"
-		"fm,f,G,rm,r ,F ,F ,C,x,m,x,r ,Yi"))]
+		"Yf*fm ,Yf*f ,G    ,rm,rC,C ,F ,C,x,m,x,r ,Yi"))]
   "TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (!can_create_pseudo_p ()
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
@@ -2937,10 +2988,10 @@
       return "mov{q}\t{%1, %0|%0, %1}";
 
     case 5:
-      return "movabs{q}\t{%1, %0|%0, %1}";
+      return "mov{l}\t{%1, %k0|%k0, %1}";
 
     case 6:
-      return "#";
+      return "movabs{q}\t{%1, %0|%0, %1}";
 
     case 7:
       return standard_sse_constant_opcode (insn, operands[1]);
@@ -2982,22 +3033,20 @@
   [(set (attr "type")
 	(cond [(eq_attr "alternative" "0,1,2")
 		 (const_string "fmov")
-	       (eq_attr "alternative" "3,4,5")
+	       (eq_attr "alternative" "3,4,5,6")
 		 (const_string "imov")
-	       (eq_attr "alternative" "6")
-		 (const_string "multi")
 	       (eq_attr "alternative" "7")
 		 (const_string "sselog1")
 	      ]
 	      (const_string "ssemov")))
    (set (attr "modrm")
      (if_then_else
-       (and (eq_attr "alternative" "5") (eq_attr "type" "imov"))
+       (and (eq_attr "alternative" "6") (eq_attr "type" "imov"))
 	 (const_string "0")
 	 (const_string "*")))
    (set (attr "length_immediate")
      (if_then_else
-       (and (eq_attr "alternative" "5") (eq_attr "type" "imov"))
+       (and (eq_attr "alternative" "6") (eq_attr "type" "imov"))
 	 (const_string "8")
 	 (const_string "*")))
    (set (attr "prefix")
@@ -3011,8 +3060,10 @@
    (set (attr "mode")
         (cond [(eq_attr "alternative" "0,1,2")
 		 (const_string "DF")
-	       (eq_attr "alternative" "3,4,5,6,11,12")
+	       (eq_attr "alternative" "3,4,6,11,12")
 		 (const_string "DI")
+	       (eq_attr "alternative" "5")
+		 (const_string "SI")
 
 	       /* xorps is one byte shorter.  */
 	       (eq_attr "alternative" "7")
@@ -3050,9 +3101,9 @@
 ;; Possible store forwarding (partial memory) stall in alternative 4.
 (define_insn "*movdf_internal"
   [(set (match_operand:DF 0 "nonimmediate_operand"
-		"=f,m,f,?Yd*r ,!o   ,x,x,x,m,*x,*x,*x,m")
+		"=Yf*f,m   ,Yf*f,?Yd*r ,!o   ,x,x,x,m,*x,*x,*x,m")
 	(match_operand:DF 1 "general_operand"
-		"fm,f,G,Yd*roF,FYd*r,C,x,m,x,C ,*x,m ,*x"))]
+		"Yf*fm,Yf*f,G   ,Yd*roF,Yd*rF,C,x,m,x,C ,*x,m ,*x"))]
   "!TARGET_64BIT && !(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (!can_create_pseudo_p ()
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
@@ -3184,9 +3235,9 @@
 
 (define_insn "*movsf_internal"
   [(set (match_operand:SF 0 "nonimmediate_operand"
-	  "=f,m,f,?r ,?m,x,x,x,m,!*y,!m,!*y,?Yi,?r,!*Ym,!r")
+	  "=Yf*f,m   ,Yf*f,?r ,?m,x,x,x,m,!*y,!m,!*y,?Yi,?r,!*Ym,!r")
 	(match_operand:SF 1 "general_operand"
-	  "fm,f,G,rmF,Fr,C,x,m,x,m  ,*y,*y ,r  ,Yi,r   ,*Ym"))]
+	  "Yf*fm,Yf*f,G   ,rmF,rF,C,x,m,x,m  ,*y,*y ,r  ,Yi,r   ,*Ym"))]
   "!(MEM_P (operands[0]) && MEM_P (operands[1]))
    && (!can_create_pseudo_p ()
        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)
diff --git a/gcc/testsuite/gcc.target/i386/movsd.c b/gcc/testsuite/gcc.target/i386/movsd.c
new file mode 100644
index 0000000..32a19e7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/movsd.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -msse2 -mfpmath=sse" } */
+
+volatile double y;
+
+void
+test ()
+{
+  int z;
+
+  for (z = 0; z < 1000; z++)
+    y = 1.23;
+}
+
+/* { dg-final { scan-assembler-not "(fld|fst)" } } */
diff --git a/gcc/testsuite/gcc.target/i386/pr56028.c b/gcc/testsuite/gcc.target/i386/pr56028.c
new file mode 100644
index 0000000..18ae253
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr56028.c
@@ -0,0 +1,54 @@
+/* { dg-do compile  { target { ! { ia32 } } } } */
+/* { dg-options "-O2" } */
+
+volatile int a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p;
+
+volatile long long y;
+
+void
+test ()
+{
+  int a_ = a;
+  int b_ = b;
+  int c_ = c;
+  int d_ = d;
+  int e_ = e;
+  int f_ = f;
+  int g_ = g;
+  int h_ = h;
+  int i_ = i;
+  int j_ = j;
+  int k_ = k;
+  int l_ = l;
+  int m_ = m;
+  int n_ = n;
+  int o_ = o;
+  int p_ = p;
+
+  int z;
+
+  for (z = 0; z < 1000; z++)
+    {
+      y = 0x100000002ll;
+      y = 0x300000004ll;
+    }
+
+  a = a_;
+  b = b_;
+  c = c_;
+  d = d_;
+  e = e_;
+  f = f_;
+  g = g_;
+  h = h_;
+  i = i_;
+  j = j_;
+  k = k_;
+  l = l_;
+  m = m_;
+  n = n_;
+  o = o_;
+  p = p_;
+}
+
+/* { dg-final { scan-assembler-times "movabs" 2 } } */
