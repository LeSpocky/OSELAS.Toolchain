diff -uNr glibc-2.3.2.orig/configure glibc-2.3.2/configure
--- glibc-2.3.2.orig/configure	2005-04-18 14:06:14.000000000 +0100
+++ glibc-2.3.2/configure	2005-04-18 14:08:14.000000000 +0100
@@ -2269,7 +2269,10 @@
   # Found it, now check the version.
   echo "$as_me:$LINENO: checking version of $CC" >&5
 echo $ECHO_N "checking version of $CC... $ECHO_C" >&6
-  ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*version \([egcygnustpi-]*[0-9.]*\).*$/\1/p'`
+  ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*version \([egcygnustpiRedHat-]*[0-9.]*\).*$/\1/p'`
+  #aldy
+  ac_prog_version=`echo $ac_prog_version | sed 's/RedHat-//'`
+#aldy
   case $ac_prog_version in
     '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
     3.[2-9]*)
diff -uNr glibc-2.3.2.orig/spe/_ansi.h glibc-2.3.2/spe/_ansi.h
--- glibc-2.3.2.orig/spe/_ansi.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/_ansi.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,96 @@
+/* Provide support for both ANSI and non-ANSI environments.  */
+
+/* Some ANSI environments are "broken" in the sense that __STDC__ cannot be
+   relied upon to have it's intended meaning.  Therefore we must use our own
+   concoction: _HAVE_STDC.  Always use _HAVE_STDC instead of __STDC__ in newlib
+   sources!
+
+   To get a strict ANSI C environment, define macro __STRICT_ANSI__.  This will
+   "comment out" the non-ANSI parts of the ANSI header files (non-ANSI header
+   files aren't affected).  */
+
+#ifndef	_ANSIDECL_H_
+#define	_ANSIDECL_H_
+
+//#include <newlib.h>
+//#include <sys/config.h>
+#include "config.h"
+
+/* First try to figure out whether we really are in an ANSI C environment.  */
+/* FIXME: This probably needs some work.  Perhaps sys/config.h can be
+   prevailed upon to give us a clue.  */
+
+#ifdef __STDC__
+#define _HAVE_STDC
+#endif
+
+#ifdef _HAVE_STDC
+#define	_PTR		void *
+#define	_AND		,
+#define	_NOARGS		void
+#define	_CONST		const
+#define	_VOLATILE	volatile
+#define	_SIGNED		signed
+#define	_DOTS		, ...
+#define _VOID void
+#ifdef __CYGWIN__
+#define	_EXFUN(name, proto)		__cdecl name proto
+#define	_EXPARM(name, proto)		(* __cdecl name) proto
+#else
+#define	_EXFUN(name, proto)		name proto
+#define _EXPARM(name, proto)		(* name) proto
+#endif
+#define	_DEFUN(name, arglist, args)	name(args)
+#define	_DEFUN_VOID(name)		name(_NOARGS)
+#define _CAST_VOID (void)
+#ifndef _LONG_DOUBLE
+#define _LONG_DOUBLE long double
+#endif
+#ifndef _PARAMS
+#define _PARAMS(paramlist)		paramlist
+#endif
+#else	
+#define	_PTR		char *
+#define	_AND		;
+#define	_NOARGS
+#define	_CONST
+#define	_VOLATILE
+#define	_SIGNED
+#define	_DOTS
+#define _VOID void
+#define	_EXFUN(name, proto)		name()
+#define	_DEFUN(name, arglist, args)	name arglist args;
+#define	_DEFUN_VOID(name)		name()
+#define _CAST_VOID
+#define _LONG_DOUBLE double
+#ifndef _PARAMS
+#define _PARAMS(paramlist)		()
+#endif
+#endif
+
+/* Support gcc's __attribute__ facility.  */
+
+#ifdef __GNUC__
+#define _ATTRIBUTE(attrs) __attribute__ (attrs)
+#else
+#define _ATTRIBUTE(attrs)
+#endif
+
+/*  ISO C++.  */
+
+#ifdef __cplusplus
+#if !(defined(_BEGIN_STD_C) && defined(_END_STD_C))
+#ifdef _HAVE_STD_CXX
+#define _BEGIN_STD_C namespace std { extern "C" {
+#define _END_STD_C  } }
+#else
+#define _BEGIN_STD_C extern "C" {
+#define _END_STD_C  }
+#endif
+#endif
+#else
+#define _BEGIN_STD_C
+#define _END_STD_C
+#endif
+
+#endif /* _ANSIDECL_H_ */
diff -uNr glibc-2.3.2.orig/spe/atosfix16.c glibc-2.3.2/spe/atosfix16.c
--- glibc-2.3.2.orig/spe/atosfix16.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/atosfix16.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,88 @@
+/*
+FUNCTION
+   <<atosfix16>>, <<atosfix32>>, <<atosfix64>>---string to signed fixed-point
+
+INDEX
+	atosfix16
+INDEX
+	atosfix32
+INDEX
+	atosfix64
+INDEX
+	_atosfix16_r
+INDEX
+	_atosfix32_r
+INDEX
+	_atosfix64_r
+
+ANSI_SYNOPSIS
+	#include <stdlib.h>
+        __int16_t atosfix16(const char *<[s]>);
+	__int32_t atosfix32(const char *<[s]>);
+	__int64_t atosfix32(const char *<[s]>);
+
+        __int16_t _atosfix16_r(struct __reent *, const char *<[s]>);
+	__int32_t _atosfix32_r(struct __reent *, const char *<[s]>);
+	__int64_t _atosfix32_r(struct __reent *, const char *<[s]>);
+
+TRAD_SYNOPSIS
+	#include <stdlib.h>
+	__int16_t atosfix16(<[s]>)
+	const char *<[s]>;
+	
+	__int32_t atosfix32(<[s]>)
+	const char *<[s]>;
+
+	__int64_t atosfix64(<[s]>)
+	const char *<[s]>;
+
+	__int16_t _atosfix16_r(<reent>, <[s]>)
+	struct _reent *<[reent]>;
+	const char *<[s]>;
+	
+	__int32_t _atosfix32_r(<reent>, <[s]>)
+	struct _reent *<[reent]>;
+	const char *<[s]>;
+	
+	__int64_t _atosfix64_r(<reent>, <[s]>)
+	struct _reent *<[reent]>;
+	const char *<[s]>;
+	
+DESCRIPTION
+	<<atosfix16>> converts the initial portion of a string to a sign
+	+ 15-bit fraction fixed point value.
+	<<atosfix32>> converts the initial portion of a string to a sign
+	+ 31-bit fraction fixed point value.
+	<<atosfix64>> converts the initial portion of a string to a sign
+	+ 63-bit fraction fixed point value.
+	<<atosfix16(s)>> is implemented as <<strtosfix16(s, NULL).>>
+	<<atosfix32(s)>> is implemented as <<strtosfix32(s, NULL).>>
+	<<atosfix64(s)>> is implemented as <<strtosfix64(s, NULL).>>
+
+	The alternate functions <<_atosfix16_r>>, <<_atosfix32_r>>,
+	and <<_atosfix64_r>> are reentrant versions.
+	The extra argument <[reent]> is a pointer to a reentrancy structure.
+
+RETURNS
+	The functions return the converted value, if any. If no conversion was
+	made, <<0>> is returned.  If saturation occurs, <<ERANGE>> is stored
+	in errno.
+
+PORTABILITY
+	<<atosfix16>>, <<atosfix32>>, and <<atosfix64>> are non-standard.
+
+	No supporting OS subroutines are directly required.  The
+	OS subroutines required by <<strtod>> are used.
+*/
+
+/*
+ * Jeff Johnston - 02/13/2002
+ */
+
+#include <stdlib.h>
+
+__int16_t
+atosfix16 (const char *s)
+{
+  return strtosfix16 (s, NULL);
+}
diff -uNr glibc-2.3.2.orig/spe/atosfix32.c glibc-2.3.2/spe/atosfix32.c
--- glibc-2.3.2.orig/spe/atosfix32.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/atosfix32.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,11 @@
+/*
+ * Jeff Johnston - 02/13/2002
+ */
+
+#include <stdlib.h>
+
+__int32_t
+atosfix32 (const char *s)
+{
+  return strtosfix32 (s, NULL);
+}
diff -uNr glibc-2.3.2.orig/spe/atosfix64.c glibc-2.3.2/spe/atosfix64.c
--- glibc-2.3.2.orig/spe/atosfix64.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/atosfix64.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,11 @@
+/*
+ * Jeff Johnston - 02/13/2002
+ */
+
+#include <stdlib.h>
+
+__int64_t
+atosfix64 (const char *s)
+{
+  return strtosfix64 (s, NULL);
+}
diff -uNr glibc-2.3.2.orig/spe/atoufix16.c glibc-2.3.2/spe/atoufix16.c
--- glibc-2.3.2.orig/spe/atoufix16.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/atoufix16.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,88 @@
+/*
+FUNCTION
+   <<atoufix16>>, <<atoufix32>>, <<atoufix64>>---string to unsigned fixed-point
+
+INDEX
+	atoufix16
+INDEX
+	atoufix32
+INDEX
+	atoufix64
+INDEX
+	_atoufix16_r
+INDEX
+	_atoufix32_r
+INDEX
+	_atoufix64_r
+
+ANSI_SYNOPSIS
+	#include <stdlib.h>
+        __uint16_t atoufix16(const char *<[s]>);
+	__uint32_t atoufix32(const char *<[s]>);
+	__uint64_t atoufix32(const char *<[s]>);
+
+        __uint16_t _atoufix16_r(struct __reent *, const char *<[s]>);
+	__uint32_t _atoufix32_r(struct __reent *, const char *<[s]>);
+	__uint64_t _atoufix32_r(struct __reent *, const char *<[s]>);
+
+TRAD_SYNOPSIS
+	#include <stdlib.h>
+	__uint16_t atoufix16(<[s]>)
+	const char *<[s]>;
+	
+	__uint32_t atoufix32(<[s]>)
+	const char *<[s]>;
+
+	__uint64_t atoufix64(<[s]>)
+	const char *<[s]>;
+
+	__uint16_t _atoufix16_r(<reent>, <[s]>)
+	struct _reent *<[reent]>;
+	const char *<[s]>;
+	
+	__uint32_t _atoufix32_r(<reent>, <[s]>)
+	struct _reent *<[reent]>;
+	const char *<[s]>;
+	
+	__uint64_t _atoufix64_r(<reent>, <[s]>)
+	struct _reent *<[reent]>;
+	const char *<[s]>;
+	
+DESCRIPTION
+	<<atoufix16>> converts the initial portion of a string to a
+	16-bit fraction unsigned fixed point value.
+	<<atoufix32>> converts the initial portion of a string to a
+	32-bit fraction unsigned fixed point value.
+	<<atoufix64>> converts the initial portion of a string to a
+	64-bit fraction unsigned fixed point value.
+	<<atoufix16(s)>> is implemented as <<strtoufix16(s, NULL).>>
+	<<atoufix32(s)>> is implemented as <<strtoufix32(s, NULL).>>
+	<<atoufix64(s)>> is implemented as <<strtoufix64(s, NULL).>>
+
+	The alternate functions <<_atoufix16_r>>, <<_atoufix32_r>>,
+	and <<_atoufix64_r>> are reentrant versions.
+	The extra argument <[reent]> is a pointer to a reentrancy structure.
+
+RETURNS
+	The functions return the converted value, if any. If no conversion was
+	made, <<0>> is returned.  If saturation occurs, <<ERANGE>> is stored
+	in errno.
+
+PORTABILITY
+	<<atoufix16>>, <<atoufix32>>, and <<atoufix64>> are non-standard.
+
+	No supporting OS subroutines are directly required.  The
+	OS subroutines required by <<strtod>> are used.
+*/
+
+/*
+ * Jeff Johnston - 02/13/2002
+ */
+
+#include <stdlib.h>
+
+__uint16_t
+atoufix16 (const char *s)
+{
+  return strtoufix16 (s, NULL);
+}
diff -uNr glibc-2.3.2.orig/spe/atoufix32.c glibc-2.3.2/spe/atoufix32.c
--- glibc-2.3.2.orig/spe/atoufix32.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/atoufix32.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,11 @@
+/*
+ * Jeff Johnston - 02/13/2002
+ */
+
+#include <stdlib.h>
+
+__uint32_t
+atoufix32 (const char *s)
+{
+  return strtoufix32 (s, NULL);
+}
diff -uNr glibc-2.3.2.orig/spe/atoufix64.c glibc-2.3.2/spe/atoufix64.c
--- glibc-2.3.2.orig/spe/atoufix64.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/atoufix64.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,11 @@
+/*
+ * Jeff Johnston - 02/13/2002
+ */
+
+#include <stdlib.h>
+
+__uint64_t
+atoufix64 (const char *s)
+{
+  return strtoufix64 (s, NULL);
+}
diff -uNr glibc-2.3.2.orig/spe/Banner glibc-2.3.2/spe/Banner
--- glibc-2.3.2.orig/spe/Banner	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/Banner	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1 @@
+spe-0.1 by Aldy Hernandez
diff -uNr glibc-2.3.2.orig/spe/ChangeLog glibc-2.3.2/spe/ChangeLog
--- glibc-2.3.2.orig/spe/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/ChangeLog	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,33 @@
+2004-03-24  Aldy Hernandez  <aldyh@redhat.com>
+
+	* simdldtoa.c: New.
+
+	* mprec.h: New.
+
+	* fix64.h: New.
+
+	* Makefile: Depend on simdldtoa.c.
+
+	* strtosfix64.c: Import and adapt from newlib.
+
+	* strtoufix64.c: Same.
+
+2004-03-16  Aldy Hernandez  <aldyh@redhat.com>
+
+	* stdio-common/vfprintf.c (__ufix64tod_internal): Handle -1.0.
+
+2003-12-01  Aldy Hernandez  <aldyh@redhat.com>
+
+        * ../stdio-common/vfprintf.c (jump_table): Add 'r' and 'R'.
+        (__ufix64tod_internal): New.
+        (process_arg): Add fixed point support.
+        * stdio-common/vfscanf.c (__vfscanf): Add fixed point support.
+
+        * ../sysdeps/powerpc/powerpc32/Makefile: Set -mspe in cflags
+        and asm-CPPFLAGS.
+
+        * ../stdlib/stdlib.h: Add ato*fix* and str*fix* prototypes.
+
+        * ../stdio-common/sscanf.c (sscanf): Add ellipsis.  Use ANSI way.
+
+        * ../configure: Strip "RedHat-" from compiler name.
diff -uNr glibc-2.3.2.orig/spe/configure glibc-2.3.2/spe/configure
--- glibc-2.3.2.orig/spe/configure	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/configure	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,5 @@
+# This is only to keep the GNU C library configure mechanism happy.
+#
+# Perhaps some day we need a real configuration script for different
+# kernel versions or so.
+exit 0
diff -uNr glibc-2.3.2.orig/spe/COPYING glibc-2.3.2/spe/COPYING
--- glibc-2.3.2.orig/spe/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/COPYING	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,504 @@
+		  GNU LESSER GENERAL PUBLIC LICENSE
+		       Version 2.1, February 1999
+
+ Copyright (C) 1991, 1999 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the Lesser GPL.  It also counts
+ as the successor of the GNU Library Public License, version 2, hence
+ the version number 2.1.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Lesser General Public License, applies to some
+specially designated software packages--typically libraries--of the
+Free Software Foundation and other authors who decide to use it.  You
+can use it too, but we suggest you first think carefully about whether
+this license or the ordinary General Public License is the better
+strategy to use in any particular case, based on the explanations below.
+
+  When we speak of free software, we are referring to freedom of use,
+not price.  Our General Public Licenses are designed to make sure that
+you have the freedom to distribute copies of free software (and charge
+for this service if you wish); that you receive source code or can get
+it if you want it; that you can change the software and use pieces of
+it in new free programs; and that you are informed that you can do
+these things.
+
+  To protect your rights, we need to make restrictions that forbid
+distributors to deny you these rights or to ask you to surrender these
+rights.  These restrictions translate to certain responsibilities for
+you if you distribute copies of the library or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link other code with the library, you must provide
+complete object files to the recipients, so that they can relink them
+with the library after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  We protect your rights with a two-step method: (1) we copyright the
+library, and (2) we offer you this license, which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  To protect each distributor, we want to make it very clear that
+there is no warranty for the free library.  Also, if the library is
+modified by someone else and passed on, the recipients should know
+that what they have is not the original version, so that the original
+author's reputation will not be affected by problems that might be
+introduced by others.
+
+  Finally, software patents pose a constant threat to the existence of
+any free program.  We wish to make sure that a company cannot
+effectively restrict the users of a free program by obtaining a
+restrictive license from a patent holder.  Therefore, we insist that
+any patent license obtained for a version of the library must be
+consistent with the full freedom of use specified in this license.
+
+  Most GNU software, including some libraries, is covered by the
+ordinary GNU General Public License.  This license, the GNU Lesser
+General Public License, applies to certain designated libraries, and
+is quite different from the ordinary General Public License.  We use
+this license for certain libraries in order to permit linking those
+libraries into non-free programs.
+
+  When a program is linked with a library, whether statically or using
+a shared library, the combination of the two is legally speaking a
+combined work, a derivative of the original library.  The ordinary
+General Public License therefore permits such linking only if the
+entire combination fits its criteria of freedom.  The Lesser General
+Public License permits more lax criteria for linking other code with
+the library.
+
+  We call this license the "Lesser" General Public License because it
+does Less to protect the user's freedom than the ordinary General
+Public License.  It also provides other free software developers Less
+of an advantage over competing non-free programs.  These disadvantages
+are the reason we use the ordinary General Public License for many
+libraries.  However, the Lesser license provides advantages in certain
+special circumstances.
+
+  For example, on rare occasions, there may be a special need to
+encourage the widest possible use of a certain library, so that it becomes
+a de-facto standard.  To achieve this, non-free programs must be
+allowed to use the library.  A more frequent case is that a free
+library does the same job as widely used non-free libraries.  In this
+case, there is little to gain by limiting the free library to free
+software only, so we use the Lesser General Public License.
+
+  In other cases, permission to use a particular library in non-free
+programs enables a greater number of people to use a large body of
+free software.  For example, permission to use the GNU C Library in
+non-free programs enables many more people to use the whole GNU
+operating system, as well as its variant, the GNU/Linux operating
+system.
+
+  Although the Lesser General Public License is Less protective of the
+users' freedom, it does ensure that the user of a program that is
+linked with the Library has the freedom and the wherewithal to run
+that program using a modified version of the Library.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, whereas the latter must
+be combined with the library in order to run.
+
+		  GNU LESSER GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library or other
+program which contains a notice placed by the copyright holder or
+other authorized party saying it may be distributed under the terms of
+this Lesser General Public License (also called "this License").
+Each licensee is addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also combine or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Use a suitable shared library mechanism for linking with the
+    Library.  A suitable mechanism is one that (1) uses at run time a
+    copy of the library already present on the user's computer system,
+    rather than copying library functions into the executable, and (2)
+    will operate properly with a modified version of the library, if
+    the user installs one, as long as the modified version is
+    interface-compatible with the version that the work was made with.
+
+    c) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    d) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    e) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the materials to be distributed need not include anything that is
+normally distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties with
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Lesser General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+           How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
+
+
diff -uNr glibc-2.3.2.orig/spe/fix64.h glibc-2.3.2/spe/fix64.h
--- glibc-2.3.2.orig/spe/fix64.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/fix64.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,83 @@
+/* This file has been placed in the public domain.  */
+
+#ifndef _FIX64_H_
+
+#define _FIX64_H_
+
+#include <ieeefp.h>
+#include <math.h>
+#include <float.h>
+#include <errno.h>
+//#include <sys/config.h>
+#include "config.h"
+
+#ifdef __IEEE_LITTLE_ENDIAN
+#define IEEE_8087
+#endif
+
+#ifdef __IEEE_BIG_ENDIAN
+#define IEEE_MC68k
+#endif
+
+#ifdef __Z8000__
+#define Just_16
+#endif
+
+#if defined(IEEE_8087) + defined(IEEE_MC68k) + defined(VAX) + defined(IBM) != 1
+Exactly one of IEEE_8087, IEEE_MC68k, VAX, or IBM should be defined.
+#endif
+
+union long_double_union
+{
+  long double ld;
+  __uint32_t i[4];
+};
+
+typedef union long_double_union LONG_DOUBLE_UNION;
+
+extern void _simdstrtold (char *, char **, LONG_DOUBLE_UNION *);
+extern int    _simdldcheck (LONG_DOUBLE_UNION *);
+
+#define SIMD_LDBL_MANT_DIG 113
+
+#ifdef IEEE_8087
+# define word0(x) (x.i[3])
+# define word1(x) (x.i[2])
+# define word2(x) (x.i[1])
+# define word3(x) (x.i[0])
+#else /* !IEEE_8087 */
+# define word0(x) (x.i[0])
+# define word1(x) (x.i[1])
+# define word2(x) (x.i[2])
+# define word3(x) (x.i[3])
+#endif /* !IEEE_8087 */
+
+#undef  Exp_shift
+#define Exp_shift   16
+#undef  Exp_mask
+#define Exp_mask    ((__uint32_t)0x7fff0000L)
+#undef  Exp_msk1
+#define Exp_msk1    ((__uint32_t)0x00010000L)
+#undef  Bias
+#define Bias 	     16383
+#undef  Ebits
+#define Ebits 	     15
+#undef  Sign_bit
+#define Sign_bit    ((__uint32_t)0x80000000L)
+#define init(x) {} 
+
+union fix64_union
+{
+  __uint64_t ll;
+  __uint32_t j[2];
+};
+
+#ifdef __LITTLE_ENDIAN__
+# define hiword(y) (y.j[1])
+# define loword(y) (y.j[0])
+#else /* __BIG_ENDIAN__ */
+# define hiword(y) (y.j[0])
+# define loword(y) (y.j[1])
+#endif /* __BIG_ENDIAN__ */
+
+#endif /* _FIX64_H_ */
diff -uNr glibc-2.3.2.orig/spe/ieeefp.h glibc-2.3.2/spe/ieeefp.h
--- glibc-2.3.2.orig/spe/ieeefp.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/ieeefp.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,242 @@
+#ifndef _IEEE_FP_H_
+#define _IEEE_FP_H_
+
+#include "_ansi.h"
+
+//#include <machine/ieeefp.h>
+#include "machine-ieeefp.h"
+
+/* FIXME FIXME FIXME:
+   Neither of __ieee_{float,double}_shape_tape seem to be used anywhere
+   except in libm/test.  If that is the case, please delete these from here.
+   If that is not the case, please insert documentation here describing why
+   they're needed.  */
+
+#ifdef __IEEE_BIG_ENDIAN
+
+typedef union 
+{
+  double value;
+  struct 
+  {
+    unsigned int sign : 1;
+    unsigned int exponent: 11;
+    unsigned int fraction0:4;
+    unsigned int fraction1:16;
+    unsigned int fraction2:16;
+    unsigned int fraction3:16;
+    
+  } number;
+  struct 
+  {
+    unsigned int sign : 1;
+    unsigned int exponent: 11;
+    unsigned int quiet:1;
+    unsigned int function0:3;
+    unsigned int function1:16;
+    unsigned int function2:16;
+    unsigned int function3:16;
+  } nan;
+  struct 
+  {
+    unsigned long msw;
+    unsigned long lsw;
+  } parts;
+    long aslong[2];
+} __ieee_double_shape_type;
+
+#endif
+
+#ifdef __IEEE_LITTLE_ENDIAN
+
+typedef union 
+{
+  double value;
+  struct 
+  {
+#ifdef __SMALL_BITFIELDS
+    unsigned int fraction3:16;
+    unsigned int fraction2:16;
+    unsigned int fraction1:16;
+    unsigned int fraction0: 4;
+#else
+    unsigned int fraction1:32;
+    unsigned int fraction0:20;
+#endif
+    unsigned int exponent :11;
+    unsigned int sign     : 1;
+  } number;
+  struct 
+  {
+#ifdef __SMALL_BITFIELDS
+    unsigned int function3:16;
+    unsigned int function2:16;
+    unsigned int function1:16;
+    unsigned int function0:3;
+#else
+    unsigned int function1:32;
+    unsigned int function0:19;
+#endif
+    unsigned int quiet:1;
+    unsigned int exponent: 11;
+    unsigned int sign : 1;
+  } nan;
+  struct 
+  {
+    unsigned long lsw;
+    unsigned long msw;
+  } parts;
+
+  long aslong[2];
+
+} __ieee_double_shape_type;
+
+#endif
+
+#ifdef __IEEE_BIG_ENDIAN
+
+typedef union
+{
+  float value;
+  struct 
+  {
+    unsigned int sign : 1;
+    unsigned int exponent: 8;
+    unsigned int fraction0: 7;
+    unsigned int fraction1: 16;
+  } number;
+  struct 
+  {
+    unsigned int sign:1;
+    unsigned int exponent:8;
+    unsigned int quiet:1;
+    unsigned int function0:6;
+    unsigned int function1:16;
+  } nan;
+  long p1;
+  
+} __ieee_float_shape_type;
+
+#endif
+
+#ifdef __IEEE_LITTLE_ENDIAN
+
+typedef union
+{
+  float value;
+  struct 
+  {
+    unsigned int fraction0: 7;
+    unsigned int fraction1: 16;
+    unsigned int exponent: 8;
+    unsigned int sign : 1;
+  } number;
+  struct 
+  {
+    unsigned int function1:16;
+    unsigned int function0:6;
+    unsigned int quiet:1;
+    unsigned int exponent:8;
+    unsigned int sign:1;
+  } nan;
+  long p1;
+  
+} __ieee_float_shape_type;
+
+#endif
+
+
+
+
+
+/* FLOATING ROUNDING */
+
+typedef int fp_rnd;
+#define FP_RN 0 	/* Round to nearest 		*/
+#define FP_RM 1		/* Round down 			*/
+#define FP_RP 2		/* Round up 			*/
+#define FP_RZ 3		/* Round to zero (trunate) 	*/
+
+fp_rnd _EXFUN(fpgetround,(void));
+fp_rnd _EXFUN(fpsetround, (fp_rnd));
+
+/* EXCEPTIONS */
+
+typedef int fp_except;
+#define FP_X_INV 0x10	/* Invalid operation 		*/
+#define FP_X_DX  0x80	/* Divide by zero		*/
+#define FP_X_OFL 0x04	/* Overflow exception		*/
+#define FP_X_UFL 0x02	/* Underflow exception		*/
+#define FP_X_IMP 0x01	/* imprecise exception		*/
+
+fp_except _EXFUN(fpgetmask,(void));
+fp_except _EXFUN(fpsetmask,(fp_except));
+fp_except _EXFUN(fpgetsticky,(void));
+fp_except _EXFUN(fpsetsticky, (fp_except));
+
+/* INTEGER ROUNDING */
+
+typedef int fp_rdi;
+#define FP_RDI_TOZ 0	/* Round to Zero 		*/
+#define FP_RDI_RD  1	/* Follow float mode		*/
+
+fp_rdi _EXFUN(fpgetroundtoi,(void));
+fp_rdi _EXFUN(fpsetroundtoi,(fp_rdi));
+
+int _EXFUN(spe_isnan, (double));
+int _EXFUN(spe_isinf, (double));
+int _EXFUN(spe_finite, (double));
+
+
+
+int _EXFUN(spe_isnanf, (float));
+int _EXFUN(spe_isinff, (float));
+int _EXFUN(spe_finitef, (float));
+
+#define __IEEE_DBL_EXPBIAS 1023
+#define __IEEE_FLT_EXPBIAS 127
+
+#define __IEEE_DBL_EXPLEN 11
+#define __IEEE_FLT_EXPLEN 8
+
+
+#define __IEEE_DBL_FRACLEN (64 - (__IEEE_DBL_EXPLEN + 1))
+#define __IEEE_FLT_FRACLEN (32 - (__IEEE_FLT_EXPLEN + 1))
+
+#define __IEEE_DBL_MAXPOWTWO	((double)(1L << 32 - 2) * (1L << (32-11) - 32 + 1))
+#define __IEEE_FLT_MAXPOWTWO	((float)(1L << (32-8) - 1))
+
+#define __IEEE_DBL_NAN_EXP 0x7ff
+#define __IEEE_FLT_NAN_EXP 0xff
+
+
+#define spe_isnanf(x) (((*(long *)&(x) & 0x7f800000L)==0x7f800000L) && \
+		   ((*(long *)&(x) & 0x007fffffL)!=0000000000L))
+
+#define spe_isinff(x) (((*(long *)&(x) & 0x7f800000L)==0x7f800000L) && \
+		   ((*(long *)&(x) & 0x007fffffL)==0000000000L))
+
+#define spe_finitef(x) (((*(long *)&(x) & 0x7f800000L)!=0x7f800000L))
+
+#ifdef _DOUBLE_IS_32BITS
+#undef __IEEE_DBL_EXPBIAS
+#define __IEEE_DBL_EXPBIAS __IEEE_FLT_EXPBIAS
+
+#undef __IEEE_DBL_EXPLEN
+#define __IEEE_DBL_EXPLEN __IEEE_FLT_EXPLEN
+
+#undef __IEEE_DBL_FRACLEN
+#define __IEEE_DBL_FRACLEN __IEEE_FLT_FRACLEN
+
+#undef __IEEE_DBL_MAXPOWTWO
+#define __IEEE_DBL_MAXPOWTWO __IEEE_FLT_MAXPOWTWO
+
+#undef __IEEE_DBL_NAN_EXP
+#define __IEEE_DBL_NAN_EXP __IEEE_FLT_NAN_EXP
+
+#undef __ieee_double_shape_type
+#define __ieee_double_shape_type __ieee_float_shape_type
+
+#endif /* _DOUBLE_IS_32BITS */
+
+#endif /* _IEEE_FP_H_ */
diff -uNr glibc-2.3.2.orig/spe/machine-ieeefp.h glibc-2.3.2/spe/machine-ieeefp.h
--- glibc-2.3.2.orig/spe/machine-ieeefp.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/machine-ieeefp.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,264 @@
+#ifndef __IEEE_BIG_ENDIAN
+#ifndef __IEEE_LITTLE_ENDIAN
+
+/* This file can define macros to choose variations of the IEEE float
+   format:
+
+   _FLT_LARGEST_EXPONENT_IS_NORMAL
+
+	Defined if the float format uses the largest exponent for finite
+	numbers rather than NaN and infinity representations.  Such a
+	format cannot represent NaNs or infinities at all, but it's FLT_MAX
+	is twice the IEEE value.
+
+   _FLT_NO_DENORMALS
+
+	Defined if the float format does not support IEEE denormals.  Every
+	float with a zero exponent is taken to be a zero representation.
+ 
+   ??? At the moment, there are no equivalent macros above for doubles and
+   the macros are not fully supported by --enable-newlib-hw-fp.
+
+   __IEEE_BIG_ENDIAN
+
+        Defined if the float format is big endian.  This is mutually exclusive
+        with __IEEE_LITTLE_ENDIAN.
+
+   __IEEE_LITTLE_ENDIAN
+ 
+        Defined if the float format is little endian.  This is mutually exclusive
+        with __IEEE_BIG_ENDIAN.
+
+   Note that one of __IEEE_BIG_ENDIAN or __IEEE_LITTLE_ENDIAN must be specified for a
+   platform or error will occur.
+
+   __IEEE_BYTES_LITTLE_ENDIAN
+
+        This flag is used in conjunction with __IEEE_BIG_ENDIAN to describe a situation 
+	whereby multiple words of an IEEE floating point are in big endian order, but the
+	words themselves are little endian with respect to the bytes.
+
+   _DOUBLE_IS_32_BITS 
+
+        This is used on platforms that support double by using the 32-bit IEEE
+        float type.
+
+   _FLOAT_ARG
+
+        This represents what type a float arg is passed as.  It is used when the type is
+        not promoted to double.
+	
+*/
+
+#if (defined(__arm__) || defined(__thumb__)) && !defined(__MAVERICK__)
+/* ARM always has big-endian words.  Within those words the byte ordering
+   will be big or little endian depending upon the target.  */
+#define __IEEE_BIG_ENDIAN
+#ifdef __ARMEL__
+#define __IEEE_BYTES_LITTLE_ENDIAN
+#endif
+#endif
+
+#ifdef __hppa__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __sparc__
+#ifdef __LITTLE_ENDIAN_DATA__
+#define __IEEE_LITTLE_ENDIAN
+#else
+#define __IEEE_BIG_ENDIAN
+#endif
+#endif
+
+#if defined(__m68k__) || defined(__mc68000__)
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#if defined(__mc68hc11__) || defined(__mc68hc12__) || defined(__mc68hc1x__)
+#define __IEEE_BIG_ENDIAN
+#ifdef __HAVE_SHORT_DOUBLE__
+# define _DOUBLE_IS_32BITS
+#endif
+#endif
+
+#if defined (__H8300__) || defined (__H8300H__) || defined (__H8300S__) || defined (__H8500__)
+#define __IEEE_BIG_ENDIAN
+#define _FLOAT_ARG float
+#define _DOUBLE_IS_32BITS
+#endif
+
+#ifdef __sh__
+#ifdef __LITTLE_ENDIAN__
+#define __IEEE_LITTLE_ENDIAN
+#else
+#define __IEEE_BIG_ENDIAN
+#endif
+#if defined(__SH2E__) || defined(__SH3E__) || defined(__SH4_SINGLE_ONLY__)
+#define _DOUBLE_IS_32BITS
+#endif
+#endif
+
+#ifdef _AM29K
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef _WIN32
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __i386__
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __i960__
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __M32R__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __TIC80__
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __MIPSEL__
+#define __IEEE_LITTLE_ENDIAN
+#endif
+#ifdef __MIPSEB__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __MMIX__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __D30V__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+/* necv70 was __IEEE_LITTLE_ENDIAN. */
+
+#ifdef __W65__
+#define __IEEE_LITTLE_ENDIAN
+#define _DOUBLE_IS_32BITS
+#endif
+
+#if defined(__Z8001__) || defined(__Z8002__)
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __m88k__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __mn10300__
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __mn10200__
+#define __IEEE_LITTLE_ENDIAN
+#define _DOUBLE_IS_32BITS
+#endif
+
+#ifdef __v800
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __v850
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __D10V__
+#define __IEEE_BIG_ENDIAN
+#if __DOUBLE__ == 32
+#define _DOUBLE_IS_32BITS
+#endif
+#endif
+
+#ifdef __PPC__
+#if (defined(_BIG_ENDIAN) && _BIG_ENDIAN) || (defined(_AIX) && _AIX)
+#define __IEEE_BIG_ENDIAN
+#else
+#if (defined(_LITTLE_ENDIAN) && _LITTLE_ENDIAN) || (defined(__sun__) && __sun__) || (defined(_WIN32) && _WIN32)
+#define __IEEE_LITTLE_ENDIAN
+#endif
+#endif
+#endif
+
+#ifdef __xstormy16__
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __arc__
+#ifdef __big_endian__
+#define __IEEE_BIG_ENDIAN
+#else
+#define __IEEE_LITTLE_ENDIAN
+#endif
+#endif
+
+#ifdef __fr30__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __mcore__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __frv__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __ia64__
+#ifdef __BIG_ENDIAN__
+#define __IEEE_BIG_ENDIAN
+#else
+#define __IEEE_LITTLE_ENDIAN
+#endif
+#endif
+
+#ifdef __AVR__
+#define __IEEE_LITTLE_ENDIAN
+#define _DOUBLE_IS_32BITS
+#endif
+
+#if defined(__or32__) || defined(__or1k__) || defined(__or16__)
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __IP2K__
+#define __IEEE_BIG_ENDIAN
+#define __SMALL_BITFIELDS
+#define _DOUBLE_IS_32BITS
+#endif
+
+#ifdef __MAVERICK__
+#ifdef __ARMEL__
+#  define __IEEE_LITTLE_ENDIAN
+#else  /* must be __ARMEB__ */
+#  define __IEEE_BIG_ENDIAN
+#endif /* __ARMEL__ */
+#endif /* __MAVERICK__ */
+
+#ifdef __CRIS
+#define __IEEE_LITTLE_ENDIAN
+#endif
+
+#ifdef __IP4K__
+#define __IEEE_BIG_ENDIAN
+#endif
+
+#ifdef __s390__
+#define __IEEE_BIG_ENDIAN
+#endif
+#ifndef __IEEE_BIG_ENDIAN
+#ifndef __IEEE_LITTLE_ENDIAN
+#error Endianess not declared!!
+#endif /* not __IEEE_LITTLE_ENDIAN */
+#endif /* not __IEEE_BIG_ENDIAN */
+
+#endif /* not __IEEE_LITTLE_ENDIAN */
+#endif /* not __IEEE_BIG_ENDIAN */
+
diff -uNr glibc-2.3.2.orig/spe/Makefile glibc-2.3.2/spe/Makefile
--- glibc-2.3.2.orig/spe/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/Makefile	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,19 @@
+subdir  := spe
+
+extra-libs := libspe
+extra-libs-others := $(extra-libs)
+
+libspe-routines := strtosfix16 strtosfix32 strtosfix64 strtoufix16 \
+		   strtoufix32 strtoufix64 atosfix16 \
+		   atosfix32 atosfix64 atoufix16 atoufix32 atoufix64 simdldtoa
+
+include ../Makeconfig
+
+# Crap, we use the strt*fix* routines from scanf, so we need to get it into
+# libc.  Magically, they will not be available to anyone else but libc
+# internally, and unfortunately to anyone statically linking libc.a.
+#
+# Anyone else needing them needs to DTRT and link libspe.
+routines += strtosfix16 strtosfix32 strtosfix64 strtoufix16 strtoufix32 strtoufix64 simdldtoa
+
+include ../Rules
diff -uNr glibc-2.3.2.orig/spe/mprec.h glibc-2.3.2/spe/mprec.h
--- glibc-2.3.2.orig/spe/mprec.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/mprec.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,317 @@
+/****************************************************************
+ *
+ * The author of this software is David M. Gay.
+ *
+ * Copyright (c) 1991 by AT&T.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose without fee is hereby granted, provided that this entire notice
+ * is included in all copies of any software which is or includes a copy
+ * or modification of this software and in all copies of the supporting
+ * documentation for such software.
+ *
+ * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR AT&T MAKES ANY
+ * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
+ * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ ***************************************************************/
+
+/* Please send bug reports to
+	David M. Gay
+	AT&T Bell Laboratories, Room 2C-463
+	600 Mountain Avenue
+	Murray Hill, NJ 07974-2070
+	U.S.A.
+	dmg@research.att.com or research!dmg
+ */
+
+#include <ieeefp.h>
+#include <math.h>
+#include <float.h>
+#include <errno.h>
+#include "config.h"
+//#include <sys/config.h>
+#include <sys/types.h>
+
+#ifdef __IEEE_LITTLE_ENDIAN
+#define IEEE_8087
+#endif
+
+#ifdef __IEEE_BIG_ENDIAN
+#define IEEE_MC68k
+#endif
+
+#ifdef __Z8000__
+#define Just_16
+#endif
+
+#ifdef DEBUG
+#include "stdio.h"
+#define Bug(x) {fprintf(stderr, "%s\n", x); exit(1);}
+#endif
+
+#ifdef Unsigned_Shifts
+#define Sign_Extend(a,b) if (b < 0) a |= (__uint32_t)0xffff0000;
+#else
+#define Sign_Extend(a,b) /*no-op*/
+#endif
+
+#if defined(IEEE_8087) + defined(IEEE_MC68k) + defined(VAX) + defined(IBM) != 1
+Exactly one of IEEE_8087, IEEE_MC68k, VAX, or IBM should be defined.
+#endif
+
+/* If we are going to examine or modify specific bits in a double using
+   the word0 and/or word1 macros, then we must wrap the double inside
+   a union.  This is necessary to avoid undefined behavior according to
+   the ANSI C spec.  */
+union double_union
+{
+  double d;
+  __uint32_t i[2];
+};
+
+#ifdef IEEE_8087
+#define word0(x) (x.i[1])
+#define word1(x) (x.i[0])
+#else
+#define word0(x) (x.i[0])
+#define word1(x) (x.i[1])
+#endif
+
+/* The following definition of Storeinc is appropriate for MIPS processors.
+ * An alternative that might be better on some machines is
+ * #define Storeinc(a,b,c) (*a++ = b << 16 | c & 0xffff)
+ */
+#if defined (__IEEE_BYTES_LITTLE_ENDIAN) + defined (IEEE_8087) + defined (VAX)
+#define Storeinc(a,b,c) (((unsigned short *)a)[1] = (unsigned short)b, \
+((unsigned short *)a)[0] = (unsigned short)c, a++)
+#else
+#define Storeinc(a,b,c) (((unsigned short *)a)[0] = (unsigned short)b, \
+((unsigned short *)a)[1] = (unsigned short)c, a++)
+#endif
+
+/* #define P DBL_MANT_DIG */
+/* Ten_pmax = floor(P*log(2)/log(5)) */
+/* Bletch = (highest power of 2 < DBL_MAX_10_EXP) / 16 */
+/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
+/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
+
+#if defined(IEEE_8087) + defined(IEEE_MC68k)
+#if defined (_DOUBLE_IS_32BITS) 
+#define Exp_shift   23
+#define Exp_shift1  23
+#define Exp_msk1    ((__uint32_t)0x00800000L)
+#define Exp_msk11   ((__uint32_t)0x00800000L)
+#define Exp_mask    ((__uint32_t)0x7f800000L)
+#define P    	    24
+#define Bias 	    127
+#if 0
+#define IEEE_Arith  /* it is, but the code doesn't handle IEEE singles yet */
+#endif
+#define Emin        (-126)
+#define Exp_1       ((__uint32_t)0x3f800000L)
+#define Exp_11      ((__uint32_t)0x3f800000L)
+#define Ebits 	    8
+#define Frac_mask   ((__uint32_t)0x007fffffL)
+#define Frac_mask1  ((__uint32_t)0x007fffffL)
+#define Ten_pmax    10
+#define Sign_bit    ((__uint32_t)0x80000000L)
+#define Ten_pmax    10
+#define Bletch	    2
+#define Bndry_mask  ((__uint32_t)0x007fffffL)
+#define Bndry_mask1 ((__uint32_t)0x007fffffL)
+#define LSB 1
+#define Sign_bit    ((__uint32_t)0x80000000L)
+#define Log2P 	    1
+#define Tiny0 	    0
+#define Tiny1 	    1
+#define Quick_max   5
+#define Int_max     6
+#define Infinite(x) (word0(x) == ((__uint32_t)0x7f800000L))
+#undef word0
+#undef word1
+
+#define word0(x) (x.i[0])
+#define word1(x) 0
+#else
+
+#define Exp_shift  20
+#define Exp_shift1 20
+#define Exp_msk1    ((__uint32_t)0x100000L)
+#define Exp_msk11   ((__uint32_t)0x100000L)
+#define Exp_mask  ((__uint32_t)0x7ff00000L)
+#define P 53
+#define Bias 1023
+#define IEEE_Arith
+#define Emin (-1022)
+#define Exp_1  ((__uint32_t)0x3ff00000L)
+#define Exp_11 ((__uint32_t)0x3ff00000L)
+#define Ebits 11
+#define Frac_mask  ((__uint32_t)0xfffffL)
+#define Frac_mask1 ((__uint32_t)0xfffffL)
+#define Ten_pmax 22
+#define Bletch 0x10
+#define Bndry_mask  ((__uint32_t)0xfffffL)
+#define Bndry_mask1 ((__uint32_t)0xfffffL)
+#define LSB 1
+#define Sign_bit ((__uint32_t)0x80000000L)
+#define Log2P 1
+#define Tiny0 0
+#define Tiny1 1
+#define Quick_max 14
+#define Int_max 14
+#define Infinite(x) (word0(x) == ((__uint32_t)0x7ff00000L)) /* sufficient test for here */
+#endif
+
+#else
+#undef  Sudden_Underflow
+#define Sudden_Underflow
+#ifdef IBM
+#define Exp_shift  24
+#define Exp_shift1 24
+#define Exp_msk1   ((__uint32_t)0x1000000L)
+#define Exp_msk11  ((__uint32_t)0x1000000L)
+#define Exp_mask  ((__uint32_t)0x7f000000L)
+#define P 14
+#define Bias 65
+#define Exp_1  ((__uint32_t)0x41000000L)
+#define Exp_11 ((__uint32_t)0x41000000L)
+#define Ebits 8	/* exponent has 7 bits, but 8 is the right value in b2d */
+#define Frac_mask  ((__uint32_t)0xffffffL)
+#define Frac_mask1 ((__uint32_t)0xffffffL)
+#define Bletch 4
+#define Ten_pmax 22
+#define Bndry_mask  ((__uint32_t)0xefffffL)
+#define Bndry_mask1 ((__uint32_t)0xffffffL)
+#define LSB 1
+#define Sign_bit ((__uint32_t)0x80000000L)
+#define Log2P 4
+#define Tiny0 ((__uint32_t)0x100000L)
+#define Tiny1 0
+#define Quick_max 14
+#define Int_max 15
+#else /* VAX */
+#define Exp_shift  23
+#define Exp_shift1 7
+#define Exp_msk1    0x80
+#define Exp_msk11   ((__uint32_t)0x800000L)
+#define Exp_mask  ((__uint32_t)0x7f80L)
+#define P 56
+#define Bias 129
+#define Exp_1  ((__uint32_t)0x40800000L)
+#define Exp_11 ((__uint32_t)0x4080L)
+#define Ebits 8
+#define Frac_mask  ((__uint32_t)0x7fffffL)
+#define Frac_mask1 ((__uint32_t)0xffff007fL)
+#define Ten_pmax 24
+#define Bletch 2
+#define Bndry_mask  ((__uint32_t)0xffff007fL)
+#define Bndry_mask1 ((__uint32_t)0xffff007fL)
+#define LSB ((__uint32_t)0x10000L)
+#define Sign_bit ((__uint32_t)0x8000L)
+#define Log2P 1
+#define Tiny0 0x80
+#define Tiny1 0
+#define Quick_max 15
+#define Int_max 15
+#endif
+#endif
+
+#ifndef IEEE_Arith
+#define ROUND_BIASED
+#endif
+
+#ifdef RND_PRODQUOT
+#define rounded_product(a,b) a = rnd_prod(a, b)
+#define rounded_quotient(a,b) a = rnd_quot(a, b)
+#ifdef KR_headers
+extern double rnd_prod(), rnd_quot();
+#else
+extern double rnd_prod(double, double), rnd_quot(double, double);
+#endif
+#else
+#define rounded_product(a,b) a *= b
+#define rounded_quotient(a,b) a /= b
+#endif
+
+#define Big0 (Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))
+#define Big1 ((__uint32_t)0xffffffffL)
+
+#ifndef Just_16
+/* When Pack_32 is not defined, we store 16 bits per 32-bit long.
+ * This makes some inner loops simpler and sometimes saves work
+ * during multiplications, but it often seems to make things slightly
+ * slower.  Hence the default is now to store 32 bits per long.
+ */
+
+#ifndef Pack_32
+#define Pack_32
+#endif
+#endif
+
+
+#ifdef __cplusplus
+extern "C" double strtod(const char *s00, char **se);
+extern "C" char *dtoa(double d, int mode, int ndigits,
+			int *decpt, int *sign, char **rve);
+#endif
+
+
+typedef struct _Bigint _Bigint;
+
+#define Balloc	_Balloc
+#define Bfree	_Bfree
+#define multadd _multadd
+#define s2b	_s2b
+#define lo0bits _lo0bits
+#define hi0bits _hi0bits
+#define i2b	_i2b
+#define mult	_multiply
+#define pow5mult	_pow5mult
+#define lshift	_lshift
+#define cmp	__mcmp
+#define diff	__mdiff
+#define ulp 	_ulp
+#define b2d	_b2d
+#define d2b	_d2b
+#define ratio	_ratio
+
+#define tens __mprec_tens
+#define bigtens __mprec_bigtens
+#define tinytens __mprec_tinytens
+
+#define __ULong unsigned long	/* aldy */
+
+struct _reent ;
+double 		_EXFUN(ulp,(double x));
+double		_EXFUN(b2d,(_Bigint *a , int *e));
+_Bigint *	_EXFUN(Balloc,(struct _reent *p, int k));
+void 		_EXFUN(Bfree,(struct _reent *p, _Bigint *v));
+_Bigint *	_EXFUN(multadd,(struct _reent *p, _Bigint *, int, int));
+_Bigint *	_EXFUN(s2b,(struct _reent *, const char*, int, int, __ULong));
+_Bigint	*	_EXFUN(i2b,(struct _reent *,int));
+_Bigint *	_EXFUN(mult, (struct _reent *, _Bigint *, _Bigint *));
+_Bigint *	_EXFUN(pow5mult, (struct _reent *, _Bigint *, int k));
+int 		_EXFUN(hi0bits,(__ULong));
+int 		_EXFUN(lo0bits,(__ULong *));
+_Bigint *        _EXFUN(d2b,(struct _reent *p, double d, int *e, int *bits));
+_Bigint *        _EXFUN(lshift,(struct _reent *p, _Bigint *b, int k));
+_Bigint *        _EXFUN(diff,(struct _reent *p, _Bigint *a, _Bigint *b));
+int             _EXFUN(cmp,(_Bigint *a, _Bigint *b));
+
+double		_EXFUN(ratio,(_Bigint *a, _Bigint *b));
+#define Bcopy(x,y) memcpy((char *)&x->_sign, (char *)&y->_sign, y->_wds*sizeof(__Long) + 2*sizeof(int))
+
+#if defined(_DOUBLE_IS_32BITS) && defined(__v800)
+#define n_bigtens 2
+#else
+#define n_bigtens 5
+#endif
+
+extern _CONST double tinytens[];
+extern _CONST double bigtens[];
+extern _CONST double tens[];
+
+
+double _EXFUN(_mprec_log10,(int));
diff -uNr glibc-2.3.2.orig/spe/patches/glibc-2.3.2-patch glibc-2.3.2/spe/patches/glibc-2.3.2-patch
--- glibc-2.3.2.orig/spe/patches/glibc-2.3.2-patch	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/patches/glibc-2.3.2-patch	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,233 @@
+--- ../../../pristine/glibc-2.3.2/stdio-common/vfprintf.c	Thu Jan 30 12:30:25 2003
++++ ../../stdio-common/vfprintf.c	Mon Dec  1 08:55:03 2003
+@@ -224,6 +224,62 @@ static CHAR_T *group_number __P ((CHAR_T
+ 				  const char *)) internal_function;
+ #endif
+ 
++/* __SPE__ local changes.  */
++#ifndef __BIG_ENDIAN__
++#error Huh
++#endif
++
++/* Convert an unsigned fixed-point 64-bit value to a double.  */
++static double
++__ufix64tod_internal (unsigned long long value)
++{
++  union double_union {
++    double d;
++    struct {
++      unsigned int sign:1;
++      unsigned int exp:11;
++      long long unsigned int mantissa:52;
++    } s;
++  };
++  union double_union u;
++  int negexp;
++  unsigned long long tmp;
++  static const int BIAS = 0x3ff;
++
++  /* -1 has to be handled specially.  */
++  if (value == 0x8000000000000000ull)
++    return -1;
++
++  if (value == 0)
++    u.d = 0.0;
++  else
++    {
++      /* Find exponent by locating most-significant one-bit.  */
++      negexp = 1;
++      tmp = value;
++      while (negexp < 65)
++        {
++          if (tmp & 0x4000000000000000ull)
++            break;
++          ++negexp;
++          tmp <<= 1;
++        }
++
++      u.s.sign = (value & 0x8000000000000000ull) != 0;
++      u.s.exp = -negexp + BIAS;
++      /* The code below loses the least significant 12 bits because
++         doubles (and long doubles) in ppc32-linux have 52-bit
++         mantissas.  This function should be adjusted if/when long
++         doubles get greater precision.  */
++      u.s.mantissa = (value & 0x7fffffffffffffffull) >> (64 - 52 - negexp - 1);
++#if SPE_DEBUG
++      printf("ufix64toa: fixed orig = %llx\n", value);
++      printf("ufix64toa: negexp=%x\n", negexp);
++      printf("ufix64toa: u.s sign =%x\n", u.s.sign);
++      printf("ufix64toa: u.s exp  =%x\n", u.s.exp);
++      printf("ufix64toa: u.s mant =%llx\n", (long long)u.s.mantissa);
++      printf("ufix64toa: double: '%f'\n", u.d);
++#endif
++    }
++  return u.d;
++}
++/* END OF __SPE__ LOCAL CHANGES.  */
+ 
+ /* The function itself.  */
+ int
+@@ -288,7 +344,7 @@ vfprintf (FILE *s, const CHAR_T *format,
+ 	       0, /* 'E' */ 19, /* F */   19, /* 'G' */ 19,
+ 	       0, /* 'I' */ 29,            0,            0,
+     /* 'L' */ 12,            0,            0,            0,
+-	       0,            0,            0, /* 'S' */ 21,
++	       0,            0, /* 'R' */ 19, /* 'S' */ 21,
+ 	       0,            0,            0,            0,
+     /* 'X' */ 18,            0, /* 'Z' */ 13,            0,
+ 	       0,            0,            0,            0,
+@@ -296,7 +352,7 @@ vfprintf (FILE *s, const CHAR_T *format,
+     /* 'd' */ 15, /* 'e' */ 19, /* 'f' */ 19, /* 'g' */ 19,
+     /* 'h' */ 10, /* 'i' */ 15, /* 'j' */ 28,            0,
+     /* 'l' */ 11, /* 'm' */ 24, /* 'n' */ 23, /* 'o' */ 17,
+-    /* 'p' */ 22, /* 'q' */ 12,            0, /* 's' */ 21,
++    /* 'p' */ 22, /* 'q' */ 12, /* 'r' */ 19, /* 's' */ 21,
+     /* 't' */ 27, /* 'u' */ 16,            0,            0,
+     /* 'x' */ 18,            0, /* 'z' */ 13
+   };
+@@ -804,7 +860,8 @@ vfprintf (FILE *s, const CHAR_T *format,
+ 	const void *ptr;						      \
+ 	int function_done;						      \
+ 									      \
+-	if (fspec == NULL)						      \
++	/* __SPE__: check for 'r' and 'R' below.  */			      \
++	if (fspec == NULL || spec == 'r' || spec == 'R')		      \
+ 	  {								      \
+ 	    struct printf_info info = { .prec = prec,			      \
+ 					.width = width,			      \
+@@ -821,6 +878,30 @@ vfprintf (FILE *s, const CHAR_T *format,
+ 					.extra = 0,			      \
+ 					.wide = sizeof (CHAR_T) != 1 };	      \
+ 									      \
++	    /* __SPE__ magic for fixed point numbers.  */		\
++            if (info.spec == 'r' || info.spec == 'R')			\
++              {                                                         \
++                unsigned long long uquad;                               \
++                                                                        \
++                if (is_short)                                           \
++                  {                                                     \
++                    uquad = va_arg (ap, unsigned /*short*/);            \
++                    uquad <<= 48;                                       \
++                  }                                                     \
++                else if (is_long)                                  	\
++                  uquad = va_arg (ap, unsigned long long);              \
++                else                                                    \
++                  {                                                     \
++                    uquad = va_arg (ap, /*unsigned*/ int);              \
++                    uquad <<= 32;                                       \
++                  }                                                     \
++		if (info.spec == 'R')					\
++		  uquad >>= 1;						\
++		info.spec = 'f';					\
++                the_arg.pa_double = __ufix64tod_internal (uquad);       \
++              }                                                         \
++            else                                                        \
++	    /* END OF __SPE__ */					\
+ 	    if (is_long_double)						      \
+ 	      the_arg.pa_long_double = va_arg (ap, long double);	      \
+ 	    else							      \
+--- ../../../pristine/glibc-2.3.2/stdio-common/vfscanf.c	Wed Jan 15 17:41:19 2003
++++ ../../stdio-common/vfscanf.c	Mon Dec  1 09:48:08 2003
+@@ -1591,6 +1591,10 @@ __vfscanf (FILE *s, const char *format, 
+ 	case L_('G'):
+ 	case L_('a'):
+ 	case L_('A'):
++	/* BEGIN __SPE__ */
++	case L_('r'):
++	case L_('R'):
++	/* END __SPE__ */
+ 	  c = inchar ();
+ 	  if (c == EOF)
+ 	    input_error ();
+@@ -1870,6 +1874,39 @@ __vfscanf (FILE *s, const char *format, 
+ 	scan_float:
+ 	  /* Convert the number.  */
+ 	  ADDW (L_('\0'));
++	  /* BEGIN __SPE__ */
++	  if (fc == L_('r') || fc == L_('R'))
++	    {
++	      if (flags & LONG)		/* 'l' modifier */
++	        {
++		  unsigned long long d;
++		  if (fc == L_('r'))
++		    d = strtosfix64 (wp, NULL);
++		  else
++		    d = strtoufix64 (wp, NULL);
++		  *ARG (unsigned long long *) = d;
++	        }
++	      else if (flags & SHORT)	/* 's' modifier */
++	       {
++		  unsigned short d;
++		  if (fc == L_('r'))
++		    d = strtosfix16 (wp, NULL);
++		  else
++		    d = strtoufix16 (wp, NULL);
++		  *ARG (unsigned short *) = d;
++	       }
++	      else			/* no modifier */
++	       {
++		  unsigned long d;
++		  if (fc == L_('r'))
++		    d = strtosfix32 (wp, NULL);
++		  else
++		    d = strtoufix32 (wp, NULL);
++		  *ARG (unsigned long *) = d;
++	       }
++	    }
++	  else
++	  /* END __SPE__ */
+ 	  if (flags & LONGDBL)
+ 	    {
+ 	      long double d = __strtold_internal (wp, &tw, flags & GROUP);
+--- ../../../pristine/glibc-2.3.2/stdlib/stdlib.h	Tue Aug 27 21:11:33 2002
++++ ../../stdlib/stdlib.h	Wed Dec 10 16:09:24 2003
+@@ -911,6 +911,22 @@ extern int getloadavg (double __loadavg[
+ #endif /* don't just need malloc and calloc */
+ #undef __need_malloc_and_calloc
+ 
++/* __SPE__ local changes */
++extern unsigned long long strtoufix64 (const char *, char **);
++extern short int atosfix16 (const char *);
++extern int atosfix32 (const char *);
++extern long long atosfix64 (const char *);
++extern unsigned short atoufix16 (const char *);
++extern unsigned int atoufix32 (const char *);
++extern unsigned long long atoufix64 (const char *);
++extern short int strtosfix16 (const char *, char **);
++extern int strtosfix32 (const char *, char **);
++extern long long strtosfix64 (const char *, char **);
++extern unsigned short int strtoufix16 (const char *, char **);
++extern unsigned int strtoufix32 (const char *, char **);
++/* end of __SPE__ local changes */
++
+ __END_DECLS
+ 
+ #endif /* stdlib.h  */
+--- ../../../pristine/glibc-2.3.2/configure	Wed Feb 26 03:20:48 2003
++++ ../../configure	Wed Oct 15 10:11:40 2003
+@@ -2269,7 +2269,10 @@ else
+   # Found it, now check the version.
+   echo "$as_me:$LINENO: checking version of $CC" >&5
+ echo $ECHO_N "checking version of $CC... $ECHO_C" >&6
+-  ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*version \([egcygnustpi-]*[0-9.]*\).*$/\1/p'`
++  ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*version \([egcygnustpiRedHat-]*[0-9.]*\).*$/\1/p'`
++  #aldy
++  ac_prog_version=`echo $ac_prog_version | sed 's/RedHat-//'`
++#aldy
+   case $ac_prog_version in
+     '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
+     3.[2-9]*)
+--- ../../../pristine/glibc-2.3.2/sysdeps/powerpc/powerpc32/Makefile	Mon Jan 27 15:01:46 2003
++++ ../../sysdeps/powerpc/powerpc32/Makefile	Wed Oct 15 16:23:01 2003
+@@ -1,7 +1,9 @@
+ # Powerpc32 specific build options.
+ 
+-+cflags += -Wa,-mppc -mpowerpc
+-asm-CPPFLAGS += -Wa,-mppc
++#+cflags += -Wa,-mppc -mpowerpc
++#asm-CPPFLAGS += -Wa,-mppc
++cflags += -Wa,-mspe
++asm-CPPFLAGS += -Wa,-mspe
+ 
+ ifeq ($(with-fp),no)
+ +cflags += -msoft-float
diff -uNr glibc-2.3.2.orig/spe/patches/glibc-2.3.3-patch glibc-2.3.2/spe/patches/glibc-2.3.3-patch
--- glibc-2.3.2.orig/spe/patches/glibc-2.3.3-patch	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/patches/glibc-2.3.3-patch	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,273 @@
+Index: stdio-common/vfprintf.c
+===================================================================
+RCS file: /cvs/glibc/libc/stdio-common/vfprintf.c,v
+retrieving revision 1.124
+diff -c -p -r1.124 vfprintf.c
+*** stdio-common/vfprintf.c	30 Nov 2003 19:21:39 -0000	1.124
+--- stdio-common/vfprintf.c	24 Sep 2004 17:50:42 -0000
+*************** static CHAR_T *group_number __P ((CHAR_T
+*** 224,229 ****
+--- 224,289 ----
+  				  const char *)) internal_function;
+  #endif
+  
++ /* __SPE__ local changes.  */
++ #ifndef __BIG_ENDIAN__
++ #error Huh
++ #endif
++ 
++ /* Convert an unsigned fixed-point 64-bit value to a double.  */
++ static double
++ __ufix64tod_internal (unsigned long long value)
++ {
++   union double_union {
++     double d;
++     struct {
++       unsigned int sign:1;
++       unsigned int exp:11;
++       long long unsigned int mantissa:52;
++     } s;
++   };
++   union double_union u;
++   int negexp;
++   unsigned long long tmp;
++   static const int BIAS = 0x3ff;
++ 
++   /* -1 has to be handled specially.  */
++   if (value == 0x8000000000000000ull)
++     return -1;
++ 
++   if (value == 0)
++     u.d = 0.0;
++   else
++     {
++       /* Find exponent by locating most-significant one-bit.  */
++       negexp = 1;
++       tmp = value;
++       while (negexp < 65)
++         {
++           if (tmp & 0x4000000000000000ull)
++             break;
++           ++negexp;
++           tmp <<= 1;
++         }
++ 
++       u.s.sign = (value & 0x8000000000000000ull) != 0;
++       u.s.exp = -negexp + BIAS;
++       /* The code below loses the least significant 12 bits because
++          doubles (and long doubles) in ppc32-linux have 52-bit
++          mantissas.  This function should be adjusted if/when long
++          doubles get greater precision.  */
++       u.s.mantissa = (value & 0x7fffffffffffffffull) >> (64 - 52 - negexp - 1);
++ #if SPE_DEBUG
++       printf("ufix64toa: fixed orig = %llx\n", value);
++       printf("ufix64toa: negexp=%x\n", negexp);
++       printf("ufix64toa: u.s sign =%x\n", u.s.sign);
++       printf("ufix64toa: u.s exp  =%x\n", u.s.exp);
++       printf("ufix64toa: u.s mant =%llx\n", (long long)u.s.mantissa);
++       printf("ufix64toa: double: '%f'\n", u.d);
++ #endif
++     }
++   return u.d;
++ }
++ /* END OF __SPE__ LOCAL CHANGES.  */
+  
+  /* The function itself.  */
+  int
+*************** vfprintf (FILE *s, const CHAR_T *format,
+*** 288,294 ****
+  	       0, /* 'E' */ 19, /* F */   19, /* 'G' */ 19,
+  	       0, /* 'I' */ 29,            0,            0,
+      /* 'L' */ 12,            0,            0,            0,
+! 	       0,            0,            0, /* 'S' */ 21,
+  	       0,            0,            0,            0,
+      /* 'X' */ 18,            0, /* 'Z' */ 13,            0,
+  	       0,            0,            0,            0,
+--- 348,354 ----
+  	       0, /* 'E' */ 19, /* F */   19, /* 'G' */ 19,
+  	       0, /* 'I' */ 29,            0,            0,
+      /* 'L' */ 12,            0,            0,            0,
+! 	       0,            0, /* 'R' */ 19, /* 'S' */ 21,
+  	       0,            0,            0,            0,
+      /* 'X' */ 18,            0, /* 'Z' */ 13,            0,
+  	       0,            0,            0,            0,
+*************** vfprintf (FILE *s, const CHAR_T *format,
+*** 296,302 ****
+      /* 'd' */ 15, /* 'e' */ 19, /* 'f' */ 19, /* 'g' */ 19,
+      /* 'h' */ 10, /* 'i' */ 15, /* 'j' */ 28,            0,
+      /* 'l' */ 11, /* 'm' */ 24, /* 'n' */ 23, /* 'o' */ 17,
+!     /* 'p' */ 22, /* 'q' */ 12,            0, /* 's' */ 21,
+      /* 't' */ 27, /* 'u' */ 16,            0,            0,
+      /* 'x' */ 18,            0, /* 'z' */ 13
+    };
+--- 356,362 ----
+      /* 'd' */ 15, /* 'e' */ 19, /* 'f' */ 19, /* 'g' */ 19,
+      /* 'h' */ 10, /* 'i' */ 15, /* 'j' */ 28,            0,
+      /* 'l' */ 11, /* 'm' */ 24, /* 'n' */ 23, /* 'o' */ 17,
+!     /* 'p' */ 22, /* 'q' */ 12, /* 'r' */ 19, /* 's' */ 21,
+      /* 't' */ 27, /* 'u' */ 16,            0,            0,
+      /* 'x' */ 18,            0, /* 'z' */ 13
+    };
+*************** vfprintf (FILE *s, const CHAR_T *format,
+*** 802,808 ****
+  	const void *ptr;						      \
+  	int function_done;						      \
+  									      \
+! 	if (fspec == NULL)						      \
+  	  {								      \
+  	    struct printf_info info = { .prec = prec,			      \
+  					.width = width,			      \
+--- 862,869 ----
+  	const void *ptr;						      \
+  	int function_done;						      \
+  									      \
+! 	/* __SPE__: check for 'r' and 'R' below.  */			      \
+! 	if (fspec == NULL || spec == 'r' || spec == 'R')		      \
+  	  {								      \
+  	    struct printf_info info = { .prec = prec,			      \
+  					.width = width,			      \
+*************** vfprintf (FILE *s, const CHAR_T *format,
+*** 819,824 ****
+--- 880,909 ----
+  					.extra = 0,			      \
+  					.wide = sizeof (CHAR_T) != 1 };	      \
+  									      \
++             /* __SPE__ magic for fixed point numbers.  */               \
++             if (info.spec == 'r' || info.spec == 'R')                   \
++               {                                                         \
++                 unsigned long long uquad;                               \
++                                                                         \
++                 if (is_short)                                           \
++                   {                                                     \
++                     uquad = va_arg (ap, unsigned /*short*/);            \
++                     uquad <<= 48;                                       \
++                   }                                                     \
++                 else if (is_long)                                       \
++                   uquad = va_arg (ap, unsigned long long);              \
++                 else                                                    \
++                   {                                                     \
++                     uquad = va_arg (ap, /*unsigned*/ int);              \
++                     uquad <<= 32;                                       \
++                   }                                                     \
++                 if (info.spec == 'R')                                   \
++                   uquad >>= 1;                                          \
++                 info.spec = 'f';                                        \
++                 the_arg.pa_double = __ufix64tod_internal (uquad);       \
++               }                                                         \
++             else                                                        \
++             /* END OF __SPE__ */                                        \
+  	    if (is_long_double)						      \
+  	      the_arg.pa_long_double = va_arg (ap, long double);	      \
+  	    else							      \
+Index: stdio-common/vfscanf.c
+===================================================================
+RCS file: /cvs/glibc/libc/stdio-common/vfscanf.c,v
+retrieving revision 1.106
+diff -c -p -r1.106 vfscanf.c
+*** stdio-common/vfscanf.c	6 Sep 2003 07:15:41 -0000	1.106
+--- stdio-common/vfscanf.c	24 Sep 2004 17:50:44 -0000
+*************** __vfscanf (FILE *s, const char *format, 
+*** 1591,1596 ****
+--- 1591,1600 ----
+  	case L_('G'):
+  	case L_('a'):
+  	case L_('A'):
++         /* BEGIN __SPE__ */
++         case L_('r'):
++         case L_('R'):
++         /* END __SPE__ */
+  	  c = inchar ();
+  	  if (c == EOF)
+  	    input_error ();
+*************** __vfscanf (FILE *s, const char *format, 
+*** 1873,1878 ****
+--- 1877,1915 ----
+  	scan_float:
+  	  /* Convert the number.  */
+  	  ADDW (L_('\0'));
++           /* BEGIN __SPE__ */
++           if (fc == L_('r') || fc == L_('R'))
++             {
++               if (flags & LONG)         /* 'l' modifier */
++                 {
++                   unsigned long long d;
++                   if (fc == L_('r'))
++                     d = strtosfix64 (wp, NULL);
++                   else
++                     d = strtoufix64 (wp, NULL);
++                   *ARG (unsigned long long *) = d;
++                 }
++               else if (flags & SHORT)   /* 's' modifier */
++                {
++                   unsigned short d;
++                   if (fc == L_('r'))
++                     d = strtosfix16 (wp, NULL);
++                   else
++                     d = strtoufix16 (wp, NULL);
++                   *ARG (unsigned short *) = d;
++                }
++               else                      /* no modifier */
++                {
++                   unsigned long d;
++                   if (fc == L_('r'))
++                     d = strtosfix32 (wp, NULL);
++                   else
++                     d = strtoufix32 (wp, NULL);
++                   *ARG (unsigned long *) = d;
++                }
++             }
++           else
++           /* END __SPE__ */
+  	  if (flags & LONGDBL)
+  	    {
+  	      long double d = __strtold_internal (wp, &tw, flags & GROUP);
+Index: stdlib/stdlib.h
+===================================================================
+RCS file: /cvs/glibc/libc/stdlib/stdlib.h,v
+retrieving revision 1.103
+diff -c -p -r1.103 stdlib.h
+*** stdlib/stdlib.h	2 Sep 2003 04:43:07 -0000	1.103
+--- stdlib/stdlib.h	24 Sep 2004 17:50:45 -0000
+*************** extern int getloadavg (double __loadavg[
+*** 919,924 ****
+--- 919,939 ----
+  #endif /* don't just need malloc and calloc */
+  #undef __need_malloc_and_calloc
+  
++ /* __SPE__ local changes */
++ extern unsigned long long strtoufix64 (const char *, char **);
++ extern short int atosfix16 (const char *);
++ extern int atosfix32 (const char *);
++ extern long long atosfix64 (const char *);
++ extern unsigned short atoufix16 (const char *);
++ extern unsigned int atoufix32 (const char *);
++ extern unsigned long long atoufix64 (const char *);
++ extern short int strtosfix16 (const char *, char **);
++ extern int strtosfix32 (const char *, char **);
++ extern long long strtosfix64 (const char *, char **);
++ extern unsigned short int strtoufix16 (const char *, char **);
++ extern unsigned int strtoufix32 (const char *, char **);
++ /* end of __SPE__ local changes */
++ 
+  __END_DECLS
+  
+  #endif /* stdlib.h  */
+Index: sysdeps/powerpc/powerpc32/Makefile
+===================================================================
+RCS file: /cvs/glibc/libc/sysdeps/powerpc/powerpc32/Makefile,v
+retrieving revision 1.5
+diff -c -p -r1.5 Makefile
+*** sysdeps/powerpc/powerpc32/Makefile	22 Oct 2003 21:30:02 -0000	1.5
+--- sysdeps/powerpc/powerpc32/Makefile	24 Sep 2004 17:50:52 -0000
+***************
+*** 1,5 ****
+--- 1,9 ----
+  # Powerpc32 specific build options.
+  
++ # BEGIN __SPE__
++ cflags += -Wa,-mspe
++ asm-CPPFLAGS += -Wa,-mspe
++ # END __SPE__
+  ifeq ($(with-fp),no)
+  +cflags += -msoft-float
+  sysdep-LDFLAGS += -msoft-float
diff -uNr glibc-2.3.2.orig/spe/README glibc-2.3.2/spe/README
--- glibc-2.3.2.orig/spe/README	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/README	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,25 @@
+This library is a glibc add-on that provides E500/SPE modifications to
+glibc's PPC port.  It provides the SPE API modifications described in
+the SPE PIM.
+
+In addition to this file, you need to install the patches in the patches/
+subdirectory to take advantage of the scanf and printf extensions.
+
+To build this library, you need to untar it into your glibc sources,
+and apply the patches in patches/.  You are also strongly adviced to
+remove the following directories from your glibc source tree:
+
+	sysdeps/powerpc/fpu
+	sysdeps/powerpc/powerpc32/fpu
+
+These directories contain versions of some math functions that require
+an FPU as well as conflicting setjmp and longjmp implementations.
+
+This library has been tested with glibc versions 2.3.2 and 2.3.3.  It may or 
+may not work with previous or later versions.
+
+Notes:
+	- The fpu/bits/mathdef.h in this library needs to be the same
+ 	  as the mathdef.h in glibc's sysdeps/powerpc/fpu/bits/mathdef.h.
+
+This library was written by Aldy Hernandez <aldyh@redhat.com>.
diff -uNr glibc-2.3.2.orig/spe/simdldtoa.c glibc-2.3.2/spe/simdldtoa.c
--- glibc-2.3.2.orig/spe/simdldtoa.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/simdldtoa.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,3720 @@
+ /* Extended precision arithmetic functions for long double I/O.
+  * This program has been placed in the public domain.
+  */
+
+#include <_ansi.h>
+//#include <reent.h>
+#include <string.h>
+#include <stdlib.h>
+#include "mprec.h"
+#include "fix64.h"
+
+/* These are the externally visible entries. */
+/* linux name:  long double _IO_strtold (char *, char **); */
+void _simdstrtold (char *, char **, LONG_DOUBLE_UNION *);
+char * _simdldtoa_r (struct _reent *, LONG_DOUBLE_UNION *, int, int, int *, int *, char **);
+int    _simdldcheck (LONG_DOUBLE_UNION *);
+
+ /* Number of 16 bit words in external x type format */
+ #define NE 10
+
+ /* Number of 16 bit words in internal format */
+ #define NI (NE+3)
+
+ /* Array offset to exponent */
+ #define E 1
+
+ /* Array offset to high guard word */
+ #define M 2
+
+ /* Number of bits of precision */
+ #define NBITS ((NI-4)*16)
+
+ /* Maximum number of decimal digits in ASCII conversion
+  * = NBITS*log10(2)
+  */
+ #define NDEC (NBITS*8/27)
+
+ /* The exponent of 1.0 */
+ #define EXONE (0x3fff)
+
+ /* Maximum exponent digits - base 10 */
+ #define MAX_EXP_DIGITS 5
+
+/* Control structure for long doublue conversion including rounding precision values.
+ * rndprc can be set to 80 (if NE=6), 64, 56, 53, or 24 bits.
+ */
+typedef struct
+{
+  int rlast;
+  int rndprc;
+  int rw;
+  int re;
+  int outexpon;
+  unsigned short rmsk;
+  unsigned short rmbit;
+  unsigned short rebit;
+  unsigned short rbit[NI];
+  unsigned short equot[NI];
+} LDPARMS;
+
+static void esub(short unsigned int *a, short unsigned int *b, short unsigned int *c, LDPARMS *ldp);
+static void emul(short unsigned int *a, short unsigned int *b, short unsigned int *c, LDPARMS *ldp);
+static void ediv(short unsigned int *a, short unsigned int *b, short unsigned int *c, LDPARMS *ldp);
+static int ecmp(short unsigned int *a, short unsigned int *b);
+static int enormlz(short unsigned int *x);
+static int eshift(short unsigned int *x, int sc);
+static void eshup1(register short unsigned int *x);
+static void eshup8(register short unsigned int *x);
+static void eshup6(register short unsigned int *x);
+static void eshdn1(register short unsigned int *x);
+static void eshdn8(register short unsigned int *x);
+static void eshdn6(register short unsigned int *x);
+static void eneg(short unsigned int *x);
+static void emov(register short unsigned int *a, register short unsigned int *b);
+static void eclear(register short unsigned int *x);
+static void einfin(register short unsigned int *x, register LDPARMS *ldp);
+static void efloor(short unsigned int *x, short unsigned int *y, LDPARMS *ldp);
+static void etoasc(short unsigned int *x, char *string, int ndigs, int outformat, LDPARMS *ldp);
+
+#if SIMD_LDBL_MANT_DIG == 24
+static void e24toe(short unsigned int *pe, short unsigned int *y, LDPARMS *ldp);
+#elif SIMD_LDBL_MANT_DIG == 53
+static void e53toe(short unsigned int *pe, short unsigned int *y, LDPARMS *ldp);
+#elif SIMD_LDBL_MANT_DIG == 64
+static void e64toe(short unsigned int *pe, short unsigned int *y, LDPARMS *ldp);
+#else
+static void e113toe(short unsigned int *pe, short unsigned int *y, LDPARMS *ldp);
+#endif
+
+/*							econst.c	*/
+/*  e type constants used by high precision check routines */
+
+#if NE == 10
+/* 0.0 */
+static unsigned short ezero[NE] =
+ {0x0000, 0x0000, 0x0000, 0x0000,
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,};
+
+/* 1.0E0 */
+static unsigned short eone[NE] =
+ {0x0000, 0x0000, 0x0000, 0x0000,
+  0x0000, 0x0000, 0x0000, 0x0000, 0x8000, 0x3fff,};
+
+#else
+
+/* 0.0 */
+static unsigned short ezero[NE] = {
+0, 0000000,0000000,0000000,0000000,0000000,};
+/* 1.0E0 */
+static unsigned short eone[NE] = {
+0, 0000000,0000000,0000000,0100000,0x3fff,};
+
+#endif
+
+/* Debugging routine for displaying errors */
+#ifdef DEBUG
+/* Notice: the order of appearance of the following
+ * messages is bound to the error codes defined
+ * in mconf.h.
+ */
+static char *ermsg[7] = {
+"unknown",      /* error code 0 */
+"domain",       /* error code 1 */
+"singularity",  /* et seq.      */
+"overflow",
+"underflow",
+"total loss of precision",
+"partial loss of precision"
+};
+#define mtherr(name, code) printf( "\n%s %s error\n", name, ermsg[code] );
+#else
+#define mtherr(name, code)
+#endif
+
+/*							ieee.c
+ *
+ *    Extended precision IEEE binary floating point arithmetic routines
+ *
+ * Numbers are stored in C language as arrays of 16-bit unsigned
+ * short integers.  The arguments of the routines are pointers to
+ * the arrays.
+ *
+ *
+ * External e type data structure, simulates Intel 8087 chip
+ * temporary real format but possibly with a larger significand:
+ *
+ *	NE-1 significand words	(least significant word first,
+ *				 most significant bit is normally set)
+ *	exponent		(value = EXONE for 1.0,
+ *				top bit is the sign)
+ *
+ *
+ * Internal data structure of a number (a "word" is 16 bits):
+ *
+ * ei[0]	sign word	(0 for positive, 0xffff for negative)
+ * ei[1]	biased exponent	(value = EXONE for the number 1.0)
+ * ei[2]	high guard word	(always zero after normalization)
+ * ei[3]
+ * to ei[NI-2]	significand	(NI-4 significand words,
+ *				 most significant word first,
+ *				 most significant bit is set)
+ * ei[NI-1]	low guard word	(0x8000 bit is rounding place)
+ *
+ *
+ *
+ *		Routines for external format numbers
+ *
+ *	asctoe( string, e )	ASCII string to extended double e type
+ *	asctoe64( string, &d )	ASCII string to long double
+ *	asctoe53( string, &d )	ASCII string to double
+ *	asctoe24( string, &f )	ASCII string to single
+ *	asctoeg( string, e, prec, ldp ) ASCII string to specified precision
+ *	e24toe( &f, e, ldp )	IEEE single precision to e type
+ *	e53toe( &d, e, ldp )	IEEE double precision to e type
+ *	e64toe( &d, e, ldp )	IEEE long double precision to e type
+ *	e113toe( &d, e, ldp )	IEEE long double precision to e type
+ *	eabs(e)			absolute value
+ *	eadd( a, b, c )		c = b + a
+ *	eclear(e)		e = 0
+ *	ecmp (a, b)		Returns 1 if a > b, 0 if a == b,
+ *				-1 if a < b, -2 if either a or b is a NaN.
+ *	ediv( a, b, c, ldp )	c = b / a
+ *	efloor( a, b, ldp )	truncate to integer, toward -infinity
+ *	efrexp( a, exp, s )	extract exponent and significand
+ *	eifrac( e, &l, frac )   e to long integer and e type fraction
+ *	euifrac( e, &l, frac )  e to unsigned long integer and e type fraction
+ *	einfin( e, ldp )	set e to infinity, leaving its sign alone
+ *	eldexp( a, n, b )	multiply by 2**n
+ *	emov( a, b )		b = a
+ *	emul( a, b, c, ldp )	c = b * a
+ *	eneg(e)			e = -e
+ *	eround( a, b )		b = nearest integer value to a
+ *	esub( a, b, c, ldp )	c = b - a
+ *	e24toasc( &f, str, n )	single to ASCII string, n digits after decimal
+ *	e53toasc( &d, str, n )	double to ASCII string, n digits after decimal
+ *	e64toasc( &d, str, n )	long double to ASCII string
+ *	etoasc(e,str,n,fmt,ldp)e to ASCII string, n digits after decimal
+ *	etoe24( e, &f )		convert e type to IEEE single precision
+ *	etoe53( e, &d )		convert e type to IEEE double precision
+ *	etoe64( e, &d )		convert e type to IEEE long double precision
+ *	ltoe( &l, e )		long (32 bit) integer to e type
+ *	ultoe( &l, e )		unsigned long (32 bit) integer to e type
+ *      eisneg( e )             1 if sign bit of e != 0, else 0
+ *      eisinf( e )             1 if e has maximum exponent (non-IEEE)
+ *				or is infinite (IEEE)
+ *      eisnan( e )             1 if e is a NaN
+ *	esqrt( a, b )		b = square root of a
+ *
+ *
+ *		Routines for internal format numbers
+ *
+ *	eaddm( ai, bi )		add significands, bi = bi + ai
+ *	ecleaz(ei)		ei = 0
+ *	ecleazs(ei)		set ei = 0 but leave its sign alone
+ *	ecmpm( ai, bi )		compare significands, return 1, 0, or -1
+ *	edivm( ai, bi, ldp )	divide  significands, bi = bi / ai
+ *	emdnorm(ai,l,s,exp,ldp) normalize and round off
+ *	emovi( a, ai )		convert external a to internal ai
+ *	emovo( ai, a, ldp )	convert internal ai to external a
+ *	emovz( ai, bi )		bi = ai, low guard word of bi = 0
+ *	emulm( ai, bi, ldp )	multiply significands, bi = bi * ai
+ *	enormlz(ei)		left-justify the significand
+ *	eshdn1( ai )		shift significand and guards down 1 bit
+ *	eshdn8( ai )		shift down 8 bits
+ *	eshdn6( ai )		shift down 16 bits
+ *	eshift( ai, n )		shift ai n bits up (or down if n < 0)
+ *	eshup1( ai )		shift significand and guards up 1 bit
+ *	eshup8( ai )		shift up 8 bits
+ *	eshup6( ai )		shift up 16 bits
+ *	esubm( ai, bi )		subtract significands, bi = bi - ai
+ *
+ *
+ * The result is always normalized and rounded to NI-4 word precision
+ * after each arithmetic operation.
+ *
+ * Exception flags are NOT fully supported.
+ *
+ * Define INFINITY in mconf.h for support of infinity; otherwise a
+ * saturation arithmetic is implemented.
+ *
+ * Define NANS for support of Not-a-Number items; otherwise the
+ * arithmetic will never produce a NaN output, and might be confused
+ * by a NaN input.
+ * If NaN's are supported, the output of ecmp(a,b) is -2 if
+ * either a or b is a NaN. This means asking if(ecmp(a,b) < 0)
+ * may not be legitimate. Use if(ecmp(a,b) == -1) for less-than
+ * if in doubt.
+ * Signaling NaN's are NOT supported; they are treated the same
+ * as quiet NaN's.
+ *
+ * Denormals are always supported here where appropriate (e.g., not
+ * for conversion to DEC numbers).
+ */
+
+/*
+ * Revision history:
+ *
+ *  5 Jan 84	PDP-11 assembly language version
+ *  6 Dec 86	C language version
+ * 30 Aug 88	100 digit version, improved rounding
+ * 15 May 92    80-bit long double support
+ * 22 Nov 00    Revised to fit into newlib by Jeff Johnston <jjohnstn@redhat.com>
+ *
+ * Author:  S. L. Moshier.
+ *
+ * Copyright (c) 1984,2000 S.L. Moshier
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose without fee is hereby granted, provided that this entire notice
+ * is included in all copies of any software which is or includes a copy
+ * or modification of this software and in all copies of the supporting
+ * documentation for such software.
+ *
+ * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+ * WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
+ * OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
+ * SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ */
+
+#include <stdio.h>
+/* #include "\usr\include\stdio.h" */
+/*#include "ehead.h"*/
+/*#include "mconf.h"*/
+/*							mconf.h
+ *
+ *	Common include file for math routines
+ *
+ *
+ *
+ * SYNOPSIS:
+ *
+ * #include "mconf.h"
+ *
+ *
+ *
+ * DESCRIPTION:
+ *
+ * This file contains definitions for error codes that are
+ * passed to the common error handling routine mtherr()
+ * (which see).
+ *
+ * The file also includes a conditional assembly definition
+ * for the type of computer arithmetic (IEEE, DEC, Motorola
+ * IEEE, or UNKnown).
+ *
+ * For Digital Equipment PDP-11 and VAX computers, certain
+ * IBM systems, and others that use numbers with a 56-bit
+ * significand, the symbol DEC should be defined.  In this
+ * mode, most floating point constants are given as arrays
+ * of octal integers to eliminate decimal to binary conversion
+ * errors that might be introduced by the compiler.
+ *
+ * For computers, such as IBM PC, that follow the IEEE 
+ * Standard for Binary Floating Point Arithmetic (ANSI/IEEE
+ * Std 754-1985), the symbol IBMPC should be defined.  These
+ * numbers have 53-bit significands.  In this mode, constants
+ * are provided as arrays of hexadecimal 16 bit integers.
+ *
+ * To accommodate other types of computer arithmetic, all
+ * constants are also provided in a normal decimal radix
+ * which one can hope are correctly converted to a suitable
+ * format by the available C language compiler.  To invoke
+ * this mode, the symbol UNK is defined.
+ *
+ * An important difference among these modes is a predefined
+ * set of machine arithmetic constants for each.  The numbers
+ * MACHEP (the machine roundoff error), MAXNUM (largest number
+ * represented), and several other parameters are preset by
+ * the configuration symbol.  Check the file const.c to
+ * ensure that these values are correct for your computer.
+ *
+ * For ANSI C compatibility, define ANSIC equal to 1.  Currently
+ * this affects only the atan2() function and others that use it.
+ */
+
+/* Constant definitions for math error conditions
+ */
+
+#define DOMAIN		1	/* argument domain error */
+#define SING		2	/* argument singularity */
+#define OVERFLOW	3	/* overflow range error */
+#define UNDERFLOW	4	/* underflow range error */
+#define TLOSS		5	/* total loss of precision */
+#define PLOSS		6	/* partial loss of precision */
+
+#define EDOM		33
+#define ERANGE		34
+
+typedef struct
+	{
+	double r;
+	double i;
+	}cmplx;
+
+/* Type of computer arithmetic */
+
+#ifndef DEC
+#ifdef __IEEE_LITTLE_ENDIAN
+#define IBMPC 1
+#else  /* !__IEEE_LITTLE_ENDIAN */
+#define MIEEE 1
+#endif /* !__IEEE_LITTLE_ENDIAN */
+#endif /* !DEC */
+
+/* Define 1 for ANSI C atan2() function
+ * See atan.c and clog.c.
+ */
+#define ANSIC 1
+
+/*define VOLATILE volatile*/
+#define VOLATILE 
+
+#define NANS
+#define INFINITY
+
+/* NaN's require infinity support. */
+#ifdef NANS
+#ifndef INFINITY
+#define INFINITY
+#endif
+#endif
+
+/* This handles 64-bit long ints. */
+#define LONGBITS (8 * sizeof(long))
+
+
+static void eaddm(short unsigned int *x, short unsigned int *y);
+static void esubm(short unsigned int *x, short unsigned int *y);
+static void emdnorm(short unsigned int *s, int lost, int subflg, long int exp, int rcntrl, LDPARMS *ldp);
+static int  asctoeg(char *ss, short unsigned int *y, int oprec, LDPARMS *ldp);
+static void enan(short unsigned int *nan, int size);
+#if SIMD_LDBL_MANT_DIG == 24
+static void toe24(short unsigned int *x, short unsigned int *y);
+#elif SIMD_LDBL_MANT_DIG == 53
+static void toe53(short unsigned int *x, short unsigned int *y);
+#elif SIMD_LDBL_MANT_DIG == 64
+static void toe64(short unsigned int *a, short unsigned int *b);
+#else
+static void toe113(short unsigned int *a, short unsigned int *b);
+#endif
+static void eiremain(short unsigned int *den, short unsigned int *num, LDPARMS *ldp);
+static int ecmpm(register short unsigned int *a, register short unsigned int *b);
+static int edivm(short unsigned int *den, short unsigned int *num, LDPARMS *ldp);
+static int emulm(short unsigned int *a, short unsigned int *b, LDPARMS *ldp);
+static int eisneg(short unsigned int *x);
+static int eisinf(short unsigned int *x);
+static void emovi(short unsigned int *a, short unsigned int *b);
+static void emovo(short unsigned int *a, short unsigned int *b, LDPARMS *ldp);
+static void emovz(register short unsigned int *a, register short unsigned int *b);
+static void ecleaz(register short unsigned int *xi);
+static void eadd1(short unsigned int *a, short unsigned int *b, short unsigned int *c, int subflg, LDPARMS *ldp);
+static int eisnan(short unsigned int *x);
+static int eiisnan(short unsigned int *x);
+
+#ifdef DEC
+static void etodec(), todec(), dectoe();
+#endif
+
+/*
+; Clear out entire external format number.
+;
+; unsigned short x[];
+; eclear( x );
+*/
+
+static void eclear(register short unsigned int *x)
+{
+register int i;
+
+for( i=0; i<NE; i++ )
+	*x++ = 0;
+}
+
+
+
+/* Move external format number from a to b.
+ *
+ * emov( a, b );
+ */
+
+static void emov(register short unsigned int *a, register short unsigned int *b)
+{
+register int i;
+
+for( i=0; i<NE; i++ )
+	*b++ = *a++;
+}
+
+
+/*
+;	Negate external format number
+;
+;	unsigned short x[NE];
+;	eneg( x );
+*/
+
+static void eneg(short unsigned int *x)
+{
+
+#ifdef NANS
+if( eisnan(x) )
+	return;
+#endif
+x[NE-1] ^= 0x8000; /* Toggle the sign bit */
+}
+
+
+
+/* Return 1 if external format number is negative,
+ * else return zero.
+ */
+static int eisneg(short unsigned int *x)
+{
+
+#ifdef NANS
+if( eisnan(x) )
+	return( 0 );
+#endif
+if( x[NE-1] & 0x8000 )
+	return( 1 );
+else
+	return( 0 );
+}
+
+
+/* Return 1 if external format number has maximum possible exponent,
+ * else return zero.
+ */
+static int eisinf(short unsigned int *x)
+{
+
+if( (x[NE-1] & 0x7fff) == 0x7fff )
+	{
+#ifdef NANS
+	if( eisnan(x) )
+		return( 0 );
+#endif
+	return( 1 );
+	}
+else
+	return( 0 );
+}
+
+/* Check if e-type number is not a number.
+ */
+static int eisnan(short unsigned int *x)
+{
+
+#ifdef NANS
+int i;
+/* NaN has maximum exponent */
+if( (x[NE-1] & 0x7fff) != 0x7fff )
+	return (0);
+/* ... and non-zero significand field. */
+for( i=0; i<NE-1; i++ )
+	{
+	if( *x++ != 0 )
+		return (1);
+	}
+#endif
+return (0);
+}
+
+/*
+; Fill entire number, including exponent and significand, with
+; largest possible number.  These programs implement a saturation
+; value that is an ordinary, legal number.  A special value
+; "infinity" may also be implemented; this would require tests
+; for that value and implementation of special rules for arithmetic
+; operations involving inifinity.
+*/
+
+static void einfin(register short unsigned int *x, register LDPARMS *ldp)
+{
+register int i;
+
+#ifdef INFINITY
+for( i=0; i<NE-1; i++ )
+	*x++ = 0;
+*x |= 32767;
+ldp = ldp;
+#else
+for( i=0; i<NE-1; i++ )
+	*x++ = 0xffff;
+*x |= 32766;
+if( ldp->rndprc < NBITS )
+	{
+	if (ldp->rndprc == 113)
+		{
+		*(x - 9) = 0;
+		*(x - 8) = 0;
+		}
+	if( ldp->rndprc == 64 )
+		{
+		*(x-5) = 0;
+		}
+	if( ldp->rndprc == 53 )
+		{
+		*(x-4) = 0xf800;
+		}
+	else
+		{
+		*(x-4) = 0;
+		*(x-3) = 0;
+		*(x-2) = 0xff00;
+		}
+	}
+#endif
+}
+
+/* Move in external format number,
+ * converting it to internal format.
+ */
+static void emovi(short unsigned int *a, short unsigned int *b)
+{
+register unsigned short *p, *q;
+int i;
+
+q = b;
+p = a + (NE-1);	/* point to last word of external number */
+/* get the sign bit */
+if( *p & 0x8000 )
+	*q++ = 0xffff;
+else
+	*q++ = 0;
+/* get the exponent */
+*q = *p--;
+*q++ &= 0x7fff;	/* delete the sign bit */
+#ifdef INFINITY
+if( (*(q-1) & 0x7fff) == 0x7fff )
+	{
+#ifdef NANS
+	if( eisnan(a) )
+		{
+		*q++ = 0;
+		for( i=3; i<NI; i++ )
+			*q++ = *p--;
+		return;
+		}
+#endif
+	for( i=2; i<NI; i++ )
+		*q++ = 0;
+	return;
+	}
+#endif
+/* clear high guard word */
+*q++ = 0;
+/* move in the significand */
+for( i=0; i<NE-1; i++ )
+	*q++ = *p--;
+/* clear low guard word */
+*q = 0;
+}
+
+
+/* Move internal format number out,
+ * converting it to external format.
+ */
+static void emovo(short unsigned int *a, short unsigned int *b, LDPARMS *ldp)
+{
+register unsigned short *p, *q;
+unsigned short i;
+
+p = a;
+q = b + (NE-1); /* point to output exponent */
+/* combine sign and exponent */
+i = *p++;
+if( i )
+	*q-- = *p++ | 0x8000;
+else
+	*q-- = *p++;
+#ifdef INFINITY
+if( *(p-1) == 0x7fff )
+	{
+#ifdef NANS
+	if( eiisnan(a) )
+		{
+		enan( b, NBITS );
+		return;
+		}
+#endif
+	einfin(b, ldp);
+	return;
+	}
+#endif
+/* skip over guard word */
+++p;
+/* move the significand */
+for( i=0; i<NE-1; i++ )
+	*q-- = *p++;
+}
+
+
+/* Clear out internal format number.
+ */
+
+static void ecleaz(register short unsigned int *xi)
+{
+register int i;
+
+for( i=0; i<NI; i++ )
+	*xi++ = 0;
+}
+
+/* same, but don't touch the sign. */
+
+static void ecleazs(register short unsigned int *xi)
+{
+register int i;
+
+++xi;
+for(i=0; i<NI-1; i++)
+	*xi++ = 0;
+}
+
+
+
+
+/* Move internal format number from a to b.
+ */
+static void emovz(register short unsigned int *a, register short unsigned int *b)
+{
+register int i;
+
+for( i=0; i<NI-1; i++ )
+	*b++ = *a++;
+/* clear low guard word */
+*b = 0;
+}
+
+/* Return nonzero if internal format number is a NaN.
+ */
+
+static int eiisnan (short unsigned int *x)
+{
+int i;
+
+if( (x[E] & 0x7fff) == 0x7fff )
+	{
+	for( i=M+1; i<NI; i++ )
+		{
+		if( x[i] != 0 )
+			return(1);
+		}
+	}
+return(0);
+}
+
+#if SIMD_LDBL_MANT_DIG == 64
+
+/* Return nonzero if internal format number is infinite. */
+static int 
+eiisinf (x)
+     unsigned short x[];
+{
+
+#ifdef NANS
+  if (eiisnan (x))
+    return (0);
+#endif
+  if ((x[E] & 0x7fff) == 0x7fff)
+    return (1);
+  return (0);
+}
+#endif /* SIMD_LDBL_MANT_DIG == 64 */
+
+/*
+;	Compare significands of numbers in internal format.
+;	Guard words are included in the comparison.
+;
+;	unsigned short a[NI], b[NI];
+;	cmpm( a, b );
+;
+;	for the significands:
+;	returns	+1 if a > b
+;		 0 if a == b
+;		-1 if a < b
+*/
+static int ecmpm(register short unsigned int *a, register short unsigned int *b)
+{
+int i;
+
+a += M; /* skip up to significand area */
+b += M;
+for( i=M; i<NI; i++ )
+	{
+	if( *a++ != *b++ )
+		goto difrnt;
+	}
+return(0);
+
+difrnt:
+if( *(--a) > *(--b) )
+	return(1);
+else
+	return(-1);
+}
+
+
+/*
+;	Shift significand down by 1 bit
+*/
+
+static void eshdn1(register short unsigned int *x)
+{
+register unsigned short bits;
+int i;
+
+x += M;	/* point to significand area */
+
+bits = 0;
+for( i=M; i<NI; i++ )
+	{
+	if( *x & 1 )
+		bits |= 1;
+	*x >>= 1;
+	if( bits & 2 )
+		*x |= 0x8000;
+	bits <<= 1;
+	++x;
+	}	
+}
+
+
+
+/*
+;	Shift significand up by 1 bit
+*/
+
+static void eshup1(register short unsigned int *x)
+{
+register unsigned short bits;
+int i;
+
+x += NI-1;
+bits = 0;
+
+for( i=M; i<NI; i++ )
+	{
+	if( *x & 0x8000 )
+		bits |= 1;
+	*x <<= 1;
+	if( bits & 2 )
+		*x |= 1;
+	bits <<= 1;
+	--x;
+	}
+}
+
+
+
+/*
+;	Shift significand down by 8 bits
+*/
+
+static void eshdn8(register short unsigned int *x)
+{
+register unsigned short newbyt, oldbyt;
+int i;
+
+x += M;
+oldbyt = 0;
+for( i=M; i<NI; i++ )
+	{
+	newbyt = *x << 8;
+	*x >>= 8;
+	*x |= oldbyt;
+	oldbyt = newbyt;
+	++x;
+	}
+}
+
+/*
+;	Shift significand up by 8 bits
+*/
+
+static void eshup8(register short unsigned int *x)
+{
+int i;
+register unsigned short newbyt, oldbyt;
+
+x += NI-1;
+oldbyt = 0;
+
+for( i=M; i<NI; i++ )
+	{
+	newbyt = *x >> 8;
+	*x <<= 8;
+	*x |= oldbyt;
+	oldbyt = newbyt;
+	--x;
+	}
+}
+
+/*
+;	Shift significand up by 16 bits
+*/
+
+static void eshup6(register short unsigned int *x)
+{
+int i;
+register unsigned short *p;
+
+p = x + M;
+x += M + 1;
+
+for( i=M; i<NI-1; i++ )
+	*p++ = *x++;
+
+*p = 0;
+}
+
+/*
+;	Shift significand down by 16 bits
+*/
+
+static void eshdn6(register short unsigned int *x)
+{
+int i;
+register unsigned short *p;
+
+x += NI-1;
+p = x + 1;
+
+for( i=M; i<NI-1; i++ )
+	*(--p) = *(--x);
+
+*(--p) = 0;
+}
+
+/*
+;	Add significands
+;	x + y replaces y
+*/
+
+static void eaddm(short unsigned int *x, short unsigned int *y)
+{
+register unsigned long a;
+int i;
+unsigned int carry;
+
+x += NI-1;
+y += NI-1;
+carry = 0;
+for( i=M; i<NI; i++ )
+	{
+	a = (unsigned long )(*x) + (unsigned long )(*y) + carry;
+	if( a & 0x10000 )
+		carry = 1;
+	else
+		carry = 0;
+	*y = (unsigned short )a;
+	--x;
+	--y;
+	}
+}
+
+/*
+;	Subtract significands
+;	y - x replaces y
+*/
+
+static void esubm(short unsigned int *x, short unsigned int *y)
+{
+unsigned long a;
+int i;
+unsigned int carry;
+
+x += NI-1;
+y += NI-1;
+carry = 0;
+for( i=M; i<NI; i++ )
+	{
+	a = (unsigned long )(*y) - (unsigned long )(*x) - carry;
+	if( a & 0x10000 )
+		carry = 1;
+	else
+		carry = 0;
+	*y = (unsigned short )a;
+	--x;
+	--y;
+	}
+}
+
+
+/* Divide significands */
+
+
+/* Multiply significand of e-type number b
+by 16-bit quantity a, e-type result to c. */
+
+static void m16m(short unsigned int a, short unsigned int *b, short unsigned int *c)
+{
+register unsigned short *pp;
+register unsigned long carry;
+unsigned short *ps;
+unsigned short p[NI];
+unsigned long aa, m;
+int i;
+
+aa = a;
+pp = &p[NI-2];
+*pp++ = 0;
+*pp = 0;
+ps = &b[NI-1];
+
+for( i=M+1; i<NI; i++ )
+	{
+	if( *ps == 0 )
+		{
+		--ps;
+		--pp;
+		*(pp-1) = 0;
+		}
+	else
+		{
+		m = (unsigned long) aa * *ps--;
+		carry = (m & 0xffff) + *pp;
+		*pp-- = (unsigned short )carry;
+		carry = (carry >> 16) + (m >> 16) + *pp;
+		*pp = (unsigned short )carry;
+		*(pp-1) = carry >> 16;
+		}
+	}
+for( i=M; i<NI; i++ )
+	c[i] = p[i];
+}
+
+
+/* Divide significands. Neither the numerator nor the denominator
+is permitted to have its high guard word nonzero.  */
+
+
+static int edivm(short unsigned int *den, short unsigned int *num, LDPARMS *ldp)
+{
+int i;
+register unsigned short *p;
+unsigned long tnum;
+unsigned short j, tdenm, tquot;
+unsigned short tprod[NI+1];
+unsigned short *equot = ldp->equot;
+
+p = &equot[0];
+*p++ = num[0];
+*p++ = num[1];
+
+for( i=M; i<NI; i++ )
+	{
+	*p++ = 0;
+	}
+eshdn1( num );
+tdenm = den[M+1];
+for( i=M; i<NI; i++ )
+	{
+	/* Find trial quotient digit (the radix is 65536). */
+	tnum = (((unsigned long) num[M]) << 16) + num[M+1];
+
+	/* Do not execute the divide instruction if it will overflow. */
+        if( (tdenm * 0xffffUL) < tnum )
+		tquot = 0xffff;
+	else
+		tquot = tnum / tdenm;
+
+		/* Prove that the divide worked. */
+/*
+	tcheck = (unsigned long )tquot * tdenm;
+	if( tnum - tcheck > tdenm )
+		tquot = 0xffff;
+*/
+	/* Multiply denominator by trial quotient digit. */
+	m16m( tquot, den, tprod );
+	/* The quotient digit may have been overestimated. */
+	if( ecmpm( tprod, num ) > 0 )
+		{
+		tquot -= 1;
+		esubm( den, tprod );
+		if( ecmpm( tprod, num ) > 0 )
+			{
+			tquot -= 1;
+			esubm( den, tprod );
+			}
+		}
+/*
+	if( ecmpm( tprod, num ) > 0 )
+		{
+		eshow( "tprod", tprod );
+		eshow( "num  ", num );
+		printf( "tnum = %08lx, tden = %04x, tquot = %04x\n",
+			 tnum, den[M+1], tquot );
+		}
+*/
+	esubm( tprod, num );
+/*
+	if( ecmpm( num, den ) >= 0 )
+		{
+		eshow( "num  ", num );
+		eshow( "den  ", den );
+		printf( "tnum = %08lx, tden = %04x, tquot = %04x\n",
+			 tnum, den[M+1], tquot );
+		}
+*/
+	equot[i] = tquot;
+	eshup6(num);
+	}
+/* test for nonzero remainder after roundoff bit */
+p = &num[M];
+j = 0;
+for( i=M; i<NI; i++ )
+	{
+	j |= *p++;
+	}
+if( j )
+	j = 1;
+
+for( i=0; i<NI; i++ )
+	num[i] = equot[i];
+
+return( (int )j );
+}
+
+
+
+/* Multiply significands */
+static int emulm(short unsigned int *a, short unsigned int *b, LDPARMS *ldp) 
+{
+unsigned short *p, *q;
+unsigned short pprod[NI];
+unsigned short j;
+int i;
+unsigned short *equot = ldp->equot;
+
+equot[0] = b[0];
+equot[1] = b[1];
+for( i=M; i<NI; i++ )
+	equot[i] = 0;
+
+j = 0;
+p = &a[NI-1];
+q = &equot[NI-1];
+for( i=M+1; i<NI; i++ )
+	{
+	if( *p == 0 )
+		{
+		--p;
+		}
+	else
+		{
+		m16m( *p--, b, pprod );
+		eaddm(pprod, equot);
+		}
+	j |= *q;
+	eshdn6(equot);
+	}
+
+for( i=0; i<NI; i++ )
+	b[i] = equot[i];
+
+/* return flag for lost nonzero bits */
+return( (int)j );
+}
+
+
+/*
+static void eshow(str, x)
+char *str;
+unsigned short *x;
+{
+int i;
+
+printf( "%s ", str );
+for( i=0; i<NI; i++ )
+	printf( "%04x ", *x++ );
+printf( "\n" );
+}
+*/
+
+
+/*
+ * Normalize and round off.
+ *
+ * The internal format number to be rounded is "s".
+ * Input "lost" indicates whether the number is exact.
+ * This is the so-called sticky bit.
+ *
+ * Input "subflg" indicates whether the number was obtained
+ * by a subtraction operation.  In that case if lost is nonzero
+ * then the number is slightly smaller than indicated.
+ *
+ * Input "exp" is the biased exponent, which may be negative.
+ * the exponent field of "s" is ignored but is replaced by
+ * "exp" as adjusted by normalization and rounding.
+ *
+ * Input "rcntrl" is the rounding control.
+ */
+
+
+static void emdnorm(short unsigned int *s, int lost, int subflg, long int exp, int rcntrl, LDPARMS *ldp)
+{
+int i, j;
+unsigned short r;
+
+/* Normalize */
+j = enormlz( s );
+
+/* a blank significand could mean either zero or infinity. */
+#ifndef INFINITY
+if( j > NBITS )
+	{
+	ecleazs( s );
+	return;
+	}
+#endif
+exp -= j;
+#ifndef INFINITY
+if( exp >= 32767L )
+	goto overf;
+#else
+if( (j > NBITS) && (exp < 32767L) )
+	{
+	ecleazs( s );
+	return;
+	}
+#endif
+if( exp < 0L )
+	{
+	if( exp > (long )(-NBITS-1) )
+		{
+		j = (int )exp;
+		i = eshift( s, j );
+		if( i )
+			lost = 1;
+		}
+	else
+		{
+		ecleazs( s );
+		return;
+		}
+	}
+/* Round off, unless told not to by rcntrl. */
+if( rcntrl == 0 )
+	goto mdfin;
+/* Set up rounding parameters if the control register changed. */
+if( ldp->rndprc != ldp->rlast )
+	{
+	ecleaz( ldp->rbit );
+	switch( ldp->rndprc )
+		{
+		default:
+		case NBITS:
+			ldp->rw = NI-1; /* low guard word */
+			ldp->rmsk = 0xffff;
+			ldp->rmbit = 0x8000;
+			ldp->rebit = 1;
+			ldp->re = ldp->rw - 1;
+			break;
+		case 113:
+			ldp->rw = 10;
+			ldp->rmsk = 0x7fff;
+			ldp->rmbit = 0x4000;
+			ldp->rebit = 0x8000;
+			ldp->re = ldp->rw;
+			break;
+		case 64:
+			ldp->rw = 7;
+			ldp->rmsk = 0xffff;
+			ldp->rmbit = 0x8000;
+			ldp->rebit = 1;
+			ldp->re = ldp->rw-1;
+			break;
+/* For DEC arithmetic */
+		case 56:
+			ldp->rw = 6;
+			ldp->rmsk = 0xff;
+			ldp->rmbit = 0x80;
+			ldp->rebit = 0x100;
+			ldp->re = ldp->rw;
+			break;
+		case 53:
+			ldp->rw = 6;
+			ldp->rmsk = 0x7ff;
+			ldp->rmbit = 0x0400;
+			ldp->rebit = 0x800;
+			ldp->re = ldp->rw;
+			break;
+		case 24:
+			ldp->rw = 4;
+			ldp->rmsk = 0xff;
+			ldp->rmbit = 0x80;
+			ldp->rebit = 0x100;
+			ldp->re = ldp->rw;
+			break;
+		}
+	ldp->rbit[ldp->re] = ldp->rebit;
+	ldp->rlast = ldp->rndprc;
+	}
+
+/* Shift down 1 temporarily if the data structure has an implied
+ * most significant bit and the number is denormal.
+ * For rndprc = 64 or NBITS, there is no implied bit.
+ * But Intel long double denormals lose one bit of significance even so.
+ */
+#if IBMPC
+if( (exp <= 0) && (ldp->rndprc != NBITS) )
+#else
+if( (exp <= 0) && (ldp->rndprc != 64) && (ldp->rndprc != NBITS) )
+#endif
+	{
+	lost |= s[NI-1] & 1;
+	eshdn1(s);
+	}
+/* Clear out all bits below the rounding bit,
+ * remembering in r if any were nonzero.
+ */
+r = s[ldp->rw] & ldp->rmsk;
+if( ldp->rndprc < NBITS )
+	{
+	i = ldp->rw + 1;
+	while( i < NI )
+		{
+		if( s[i] )
+			r |= 1;
+		s[i] = 0;
+		++i;
+		}
+	}
+s[ldp->rw] &= ~ldp->rmsk;
+if( (r & ldp->rmbit) != 0 )
+	{
+	if( r == ldp->rmbit )
+		{
+		if( lost == 0 )
+			{ /* round to even */
+			if( (s[ldp->re] & ldp->rebit) == 0 )
+				goto mddone;
+			}
+		else
+			{
+			if( subflg != 0 )
+				goto mddone;
+			}
+		}
+	eaddm( ldp->rbit, s );
+	}
+mddone:
+#if IBMPC
+if( (exp <= 0) && (ldp->rndprc != NBITS) )
+#else
+if( (exp <= 0) && (ldp->rndprc != 64) && (ldp->rndprc != NBITS) )
+#endif
+	{
+	eshup1(s);
+	}
+if( s[2] != 0 )
+	{ /* overflow on roundoff */
+	eshdn1(s);
+	exp += 1;
+	}
+mdfin:
+s[NI-1] = 0;
+if( exp >= 32767L )
+	{
+#ifndef INFINITY
+overf:
+#endif
+#ifdef INFINITY
+	s[1] = 32767;
+	for( i=2; i<NI-1; i++ )
+		s[i] = 0;
+#else
+	s[1] = 32766;
+	s[2] = 0;
+	for( i=M+1; i<NI-1; i++ )
+		s[i] = 0xffff;
+	s[NI-1] = 0;
+	if( (ldp->rndprc < 64) || (ldp->rndprc == 113) )
+		{
+		s[ldp->rw] &= ~ldp->rmsk;
+		if( ldp->rndprc == 24 )
+			{
+			s[5] = 0;
+			s[6] = 0;
+			}
+		}
+#endif
+	return;
+	}
+if( exp < 0 )
+	s[1] = 0;
+else
+	s[1] = (unsigned short )exp;
+}
+
+
+
+/*
+;	Subtract external format numbers.
+;
+;	unsigned short a[NE], b[NE], c[NE];
+;       LDPARMS *ldp;
+;	esub( a, b, c, ldp );	 c = b - a
+*/
+
+static void esub(short unsigned int *a, short unsigned int *b, short unsigned int *c, LDPARMS *ldp)
+{
+
+#ifdef NANS
+if( eisnan(a) )
+	{
+	emov (a, c);
+	return;
+	}
+if( eisnan(b) )
+	{
+	emov(b,c);
+	return;
+	}
+/* Infinity minus infinity is a NaN.
+ * Test for subtracting infinities of the same sign.
+ */
+if( eisinf(a) && eisinf(b) && ((eisneg (a) ^ eisneg (b)) == 0))
+	{
+	mtherr( "esub", DOMAIN );
+	enan( c, NBITS );
+	return;
+	}
+#endif
+eadd1( a, b, c, 1, ldp );
+}
+
+
+
+static void eadd1(short unsigned int *a, short unsigned int *b, short unsigned int *c, int subflg, LDPARMS *ldp)
+{
+unsigned short ai[NI], bi[NI], ci[NI];
+int i, lost, j, k;
+long lt, lta, ltb;
+
+#ifdef INFINITY
+if( eisinf(a) )
+	{
+	emov(a,c);
+	if( subflg )
+		eneg(c);
+	return;
+	}
+if( eisinf(b) )
+	{
+	emov(b,c);
+	return;
+	}
+#endif
+emovi( a, ai );
+emovi( b, bi );
+if( subflg )
+	ai[0] = ~ai[0];
+
+/* compare exponents */
+lta = ai[E];
+ltb = bi[E];
+lt = lta - ltb;
+if( lt > 0L )
+	{	/* put the larger number in bi */
+	emovz( bi, ci );
+	emovz( ai, bi );
+	emovz( ci, ai );
+	ltb = bi[E];
+	lt = -lt;
+	}
+lost = 0;
+if( lt != 0L )
+	{
+	if( lt < (long )(-NBITS-1) )
+		goto done;	/* answer same as larger addend */
+	k = (int )lt;
+	lost = eshift( ai, k ); /* shift the smaller number down */
+	}
+else
+	{
+/* exponents were the same, so must compare significands */
+	i = ecmpm( ai, bi );
+	if( i == 0 )
+		{ /* the numbers are identical in magnitude */
+		/* if different signs, result is zero */
+		if( ai[0] != bi[0] )
+			{
+			eclear(c);
+			return;
+			}
+		/* if same sign, result is double */
+		/* double denomalized tiny number */
+		if( (bi[E] == 0) && ((bi[3] & 0x8000) == 0) )
+			{
+			eshup1( bi );
+			goto done;
+			}
+		/* add 1 to exponent unless both are zero! */
+		for( j=1; j<NI-1; j++ )
+			{
+			if( bi[j] != 0 )
+				{
+/* This could overflow, but let emovo take care of that. */
+				ltb += 1;
+				break;
+				}
+			}
+		bi[E] = (unsigned short )ltb;
+		goto done;
+		}
+	if( i > 0 )
+		{	/* put the larger number in bi */
+		emovz( bi, ci );
+		emovz( ai, bi );
+		emovz( ci, ai );
+		}
+	}
+if( ai[0] == bi[0] )
+	{
+	eaddm( ai, bi );
+	subflg = 0;
+	}
+else
+	{
+	esubm( ai, bi );
+	subflg = 1;
+	}
+emdnorm( bi, lost, subflg, ltb, 64, ldp );
+
+done:
+emovo( bi, c, ldp );
+}
+
+
+
+/*
+;	Divide.
+;
+;	unsigned short a[NE], b[NE], c[NE];
+;       LDPARMS *ldp;
+;	ediv( a, b, c, ldp );	c = b / a
+*/
+static void ediv(short unsigned int *a, short unsigned int *b, short unsigned int *c, LDPARMS *ldp)
+{
+unsigned short ai[NI], bi[NI];
+int i;
+long lt, lta, ltb;
+
+#ifdef NANS
+/* Return any NaN input. */
+if( eisnan(a) )
+	{
+	emov(a,c);
+	return;
+	}
+if( eisnan(b) )
+	{
+	emov(b,c);
+	return;
+	}
+/* Zero over zero, or infinity over infinity, is a NaN. */
+if( ((ecmp(a,ezero) == 0) && (ecmp(b,ezero) == 0))
+	|| (eisinf (a) && eisinf (b)) )
+	{
+	mtherr( "ediv", DOMAIN );
+	enan( c, NBITS );
+	return;
+	}
+#endif
+/* Infinity over anything else is infinity. */
+#ifdef INFINITY
+if( eisinf(b) )
+	{
+	if( eisneg(a) ^ eisneg(b) )
+		*(c+(NE-1)) = 0x8000;
+	else
+		*(c+(NE-1)) = 0;
+	einfin(c, ldp);
+	return;
+	}
+if( eisinf(a) )
+	{
+	eclear(c);
+	return;
+	}
+#endif
+emovi( a, ai );
+emovi( b, bi );
+lta = ai[E];
+ltb = bi[E];
+if( bi[E] == 0 )
+	{ /* See if numerator is zero. */
+	for( i=1; i<NI-1; i++ )
+		{
+		if( bi[i] != 0 )
+			{
+			ltb -= enormlz( bi );
+			goto dnzro1;
+			}
+		}
+	eclear(c);
+	return;
+	}
+dnzro1:
+
+if( ai[E] == 0 )
+	{	/* possible divide by zero */
+	for( i=1; i<NI-1; i++ )
+		{
+		if( ai[i] != 0 )
+			{
+			lta -= enormlz( ai );
+			goto dnzro2;
+			}
+		}
+	if( ai[0] == bi[0] )
+		*(c+(NE-1)) = 0;
+	else
+		*(c+(NE-1)) = 0x8000;
+	einfin(c, ldp);
+	mtherr( "ediv", SING );
+	return;
+	}
+dnzro2:
+
+i = edivm( ai, bi, ldp );
+/* calculate exponent */
+lt = ltb - lta + EXONE;
+emdnorm( bi, i, 0, lt, 64, ldp );
+/* set the sign */
+if( ai[0] == bi[0] )
+	bi[0] = 0;
+else
+	bi[0] = 0Xffff;
+emovo( bi, c, ldp );
+}
+
+
+
+/*
+;	Multiply.
+;
+;	unsigned short a[NE], b[NE], c[NE];
+;       LDPARMS *ldp
+;	emul( a, b, c, ldp );	c = b * a
+*/
+static void emul(short unsigned int *a, short unsigned int *b, short unsigned int *c, LDPARMS *ldp)
+{
+unsigned short ai[NI], bi[NI];
+int i, j;
+long lt, lta, ltb;
+
+#ifdef NANS
+/* NaN times anything is the same NaN. */
+if( eisnan(a) )
+	{
+	emov(a,c);
+	return;
+	}
+if( eisnan(b) )
+	{
+	emov(b,c);
+	return;
+	}
+/* Zero times infinity is a NaN. */
+if( (eisinf(a) && (ecmp(b,ezero) == 0))
+	|| (eisinf(b) && (ecmp(a,ezero) == 0)) )
+	{
+	mtherr( "emul", DOMAIN );
+	enan( c, NBITS );
+	return;
+	}
+#endif
+/* Infinity times anything else is infinity. */
+#ifdef INFINITY
+if( eisinf(a) || eisinf(b) )
+	{
+	if( eisneg(a) ^ eisneg(b) )
+		*(c+(NE-1)) = 0x8000;
+	else
+		*(c+(NE-1)) = 0;
+	einfin(c, ldp);
+	return;
+	}
+#endif
+emovi( a, ai );
+emovi( b, bi );
+lta = ai[E];
+ltb = bi[E];
+if( ai[E] == 0 )
+	{
+	for( i=1; i<NI-1; i++ )
+		{
+		if( ai[i] != 0 )
+			{
+			lta -= enormlz( ai );
+			goto mnzer1;
+			}
+		}
+	eclear(c);
+	return;
+	}
+mnzer1:
+
+if( bi[E] == 0 )
+	{
+	for( i=1; i<NI-1; i++ )
+		{
+		if( bi[i] != 0 )
+			{
+			ltb -= enormlz( bi );
+			goto mnzer2;
+			}
+		}
+	eclear(c);
+	return;
+	}
+mnzer2:
+
+/* Multiply significands */
+j = emulm( ai, bi, ldp );
+/* calculate exponent */
+lt = lta + ltb - (EXONE - 1);
+emdnorm( bi, j, 0, lt, 64, ldp );
+/* calculate sign of product */
+if( ai[0] == bi[0] )
+	bi[0] = 0;
+else
+	bi[0] = 0xffff;
+emovo( bi, c, ldp );
+}
+
+
+
+#if SIMD_LDBL_MANT_DIG > 64
+static void e113toe(short unsigned int *pe, short unsigned int *y, LDPARMS *ldp)
+{
+register unsigned short r;
+unsigned short *e, *p;
+unsigned short yy[NI];
+int denorm, i;
+
+e = pe;
+denorm = 0;
+ecleaz(yy);
+#ifdef IBMPC
+e += 7;
+#endif
+r = *e;
+yy[0] = 0;
+if( r & 0x8000 )
+	yy[0] = 0xffff;
+r &= 0x7fff;
+#ifdef INFINITY
+if( r == 0x7fff )
+	{
+#ifdef NANS
+#ifdef IBMPC
+	for( i=0; i<7; i++ )
+		{
+		if( pe[i] != 0 )
+			{
+			enan( y, NBITS );
+			return;
+			}
+		}
+#else  /* !IBMPC */
+	for( i=1; i<8; i++ )
+		{
+		if( pe[i] != 0 )
+			{
+			enan( y, NBITS );
+			return;
+			}
+		}
+#endif /* !IBMPC */
+#endif /* NANS */
+	eclear( y );
+	einfin( y, ldp );
+	if( *e & 0x8000 )
+		eneg(y);
+	return;
+	}
+#endif  /* INFINITY */
+yy[E] = r;
+p = &yy[M + 1];
+#ifdef IBMPC
+for( i=0; i<7; i++ )
+	*p++ = *(--e);
+#else  /* IBMPC */
+++e;
+for( i=0; i<7; i++ )
+	*p++ = *e++;
+#endif /* IBMPC */ 
+/* If denormal, remove the implied bit; else shift down 1. */
+if( r == 0 )
+	{
+	yy[M] = 0;
+	}
+else
+	{
+	yy[M] = 1;
+	eshift( yy, -1 );
+	}
+emovo(yy,y,ldp);
+}
+
+/* move out internal format to ieee long double */
+static void toe113(short unsigned int *a, short unsigned int *b)
+{
+register unsigned short *p, *q;
+unsigned short i;
+
+#ifdef NANS
+if( eiisnan(a) )
+	{
+	enan( b, 113 );
+	return;
+	}
+#endif
+p = a;
+#ifdef MIEEE
+q = b;
+#else
+q = b + 7;			/* point to output exponent */
+#endif
+
+/* If not denormal, delete the implied bit. */
+if( a[E] != 0 )
+	{
+	eshup1 (a);
+	}
+/* combine sign and exponent */
+i = *p++;
+#ifdef MIEEE
+if( i )
+	*q++ = *p++ | 0x8000;
+else
+	*q++ = *p++;
+#else
+if( i )
+	*q-- = *p++ | 0x8000;
+else
+	*q-- = *p++;
+#endif
+/* skip over guard word */
+++p;
+/* move the significand */
+#ifdef MIEEE
+for (i = 0; i < 7; i++)
+	*q++ = *p++;
+#else
+for (i = 0; i < 7; i++)
+	*q-- = *p++;
+#endif
+}
+#endif /* SIMD_LDBL_MANT_DIG > 64 */
+
+
+#if SIMD_LDBL_MANT_DIG == 64
+static void e64toe(short unsigned int *pe, short unsigned int *y, LDPARMS *ldp)
+{
+unsigned short yy[NI];
+unsigned short *p, *q, *e;
+int i;
+
+e = pe;
+p = yy;
+
+for( i=0; i<NE-5; i++ )
+	*p++ = 0;
+#ifdef IBMPC
+for( i=0; i<5; i++ )
+	*p++ = *e++;
+#endif
+#ifdef DEC
+for( i=0; i<5; i++ )
+	*p++ = *e++;
+#endif
+#ifdef MIEEE
+p = &yy[0] + (NE-1);
+*p-- = *e++;
+++e;  /* MIEEE skips over 2nd short */
+for( i=0; i<4; i++ )
+	*p-- = *e++;
+#endif
+
+#ifdef IBMPC
+/* For Intel long double, shift denormal significand up 1
+   -- but only if the top significand bit is zero.  */
+if((yy[NE-1] & 0x7fff) == 0 && (yy[NE-2] & 0x8000) == 0)
+  {
+    unsigned short temp[NI+1];
+    emovi(yy, temp);
+    eshup1(temp);
+    emovo(temp,y,ldp);
+    return;
+  }
+#endif
+#ifdef INFINITY
+/* Point to the exponent field.  */
+p = &yy[NE-1];
+if( *p == 0x7fff )
+	{
+#ifdef NANS
+#ifdef IBMPC
+	for( i=0; i<4; i++ )
+		{
+		if((i != 3 && pe[i] != 0)
+		   /* Check for Intel long double infinity pattern.  */
+		   || (i == 3 && pe[i] != 0x8000))
+			{
+			enan( y, NBITS );
+			return;
+			}
+		}
+#endif
+#ifdef MIEEE
+	for( i=2; i<=5; i++ )
+		{
+		if( pe[i] != 0 )
+			{
+			enan( y, NBITS );
+			return;
+			}
+		}
+#endif
+#endif /* NANS */
+	eclear( y );
+	einfin( y, ldp );
+	if( *p & 0x8000 )
+		eneg(y);
+	return;
+	}
+#endif /* INFINITY */
+p = yy;
+q = y;
+for( i=0; i<NE; i++ )
+	*q++ = *p++;
+}
+
+/* move out internal format to ieee long double */
+static void toe64(short unsigned int *a, short unsigned int *b)
+{
+register unsigned short *p, *q;
+unsigned short i;
+
+#ifdef NANS
+if( eiisnan(a) )
+	{
+	enan( b, 64 );
+	return;
+	}
+#endif
+#ifdef IBMPC
+/* Shift Intel denormal significand down 1.  */
+if( a[E] == 0 )
+  eshdn1(a);
+#endif
+p = a;
+#ifdef MIEEE
+q = b;
+#else
+q = b + 4; /* point to output exponent */
+/* NOTE: Intel data type is 96 bits wide, clear the last word here. */
+*(q+1)= 0;
+#endif
+
+/* combine sign and exponent */
+i = *p++;
+#ifdef MIEEE
+if( i )
+	*q++ = *p++ | 0x8000;
+else
+	*q++ = *p++;
+*q++ = 0; /* leave 2nd short blank */
+#else
+if( i )
+	*q-- = *p++ | 0x8000;
+else
+	*q-- = *p++;
+#endif
+/* skip over guard word */
+++p;
+/* move the significand */
+#ifdef MIEEE
+for( i=0; i<4; i++ )
+	*q++ = *p++;
+#else
+#ifdef INFINITY
+#ifdef IBMPC
+if (eiisinf (a))
+        {
+	/* Intel long double infinity.  */
+	*q-- = 0x8000;
+	*q-- = 0;
+	*q-- = 0;
+	*q = 0;
+	return;
+	}
+#endif /* IBMPC */
+#endif /* INFINITY */
+for( i=0; i<4; i++ )
+	*q-- = *p++;
+#endif
+}
+
+#endif /* SIMD_LDBL_MANT_DIG == 64 */
+
+#if SIMD_LDBL_MANT_DIG == 53
+/*
+; Convert IEEE double precision to e type
+;	double d;
+;	unsigned short x[N+2];
+;	e53toe( &d, x );
+*/
+static void e53toe(short unsigned int *pe, short unsigned int *y, LDPARMS *ldp)
+{
+#ifdef DEC
+
+dectoe( pe, y ); /* see etodec.c */
+
+#else
+
+register unsigned short r;
+register unsigned short *p, *e;
+unsigned short yy[NI];
+int denorm, k;
+
+e = pe;
+denorm = 0;	/* flag if denormalized number */
+ecleaz(yy);
+#ifdef IBMPC
+e += 3;
+#endif
+#ifdef DEC
+e += 3;
+#endif 
+r = *e;
+yy[0] = 0;
+if( r & 0x8000 )
+	yy[0] = 0xffff;
+yy[M] = (r & 0x0f) | 0x10;
+r &= ~0x800f;	/* strip sign and 4 significand bits */
+#ifdef INFINITY
+if( r == 0x7ff0 )
+	{
+#ifdef NANS
+#ifdef IBMPC
+	if( ((pe[3] & 0xf) != 0) || (pe[2] != 0)
+		|| (pe[1] != 0) || (pe[0] != 0) )
+		{
+		enan( y, NBITS );
+		return;
+		}
+#else  /* !IBMPC */
+	if( ((pe[0] & 0xf) != 0) || (pe[1] != 0)
+		 || (pe[2] != 0) || (pe[3] != 0) )
+		{
+		enan( y, NBITS );
+		return;
+		}
+#endif /* !IBMPC */
+#endif  /* NANS */
+	eclear( y );
+	einfin( y, ldp );
+	if( yy[0] )
+		eneg(y);
+	return;
+	}
+#endif
+r >>= 4;
+/* If zero exponent, then the significand is denormalized.
+ * So, take back the understood high significand bit. */ 
+if( r == 0 )
+	{
+	denorm = 1;
+	yy[M] &= ~0x10;
+	}
+r += EXONE - 01777;
+yy[E] = r;
+p = &yy[M+1];
+#ifdef IBMPC
+*p++ = *(--e);
+*p++ = *(--e);
+*p++ = *(--e);
+#else  /* !IBMPC */
+++e;
+*p++ = *e++;
+*p++ = *e++;
+*p++ = *e++;
+#endif /* !IBMPC */
+(void )eshift( yy, -5 );
+if( denorm )
+	{ /* if zero exponent, then normalize the significand */
+	if( (k = enormlz(yy)) > NBITS )
+		ecleazs(yy);
+	else
+		yy[E] -= (unsigned short )(k-1);
+	}
+emovo( yy, y, ldp );
+#endif /* !DEC */
+}
+
+/*
+; e type to IEEE double precision
+;	double d;
+;	unsigned short x[NE];
+;	etoe53( x, &d );
+*/
+
+#ifdef DEC
+
+static void etoe53( x, e )
+unsigned short *x, *e;
+{
+etodec( x, e ); /* see etodec.c */
+}
+
+static void toe53( x, y )
+unsigned short *x, *y;
+{
+todec( x, y );
+}
+
+#else
+
+static void toe53(short unsigned int *x, short unsigned int *y)
+{
+unsigned short i;
+unsigned short *p;
+
+
+#ifdef NANS
+if( eiisnan(x) )
+	{
+	enan( y, 53 );
+	return;
+	}
+#endif
+p = &x[0];
+#ifdef IBMPC
+y += 3;
+#endif
+#ifdef DEC
+y += 3;
+#endif
+*y = 0;	/* output high order */
+if( *p++ )
+	*y = 0x8000;	/* output sign bit */
+
+i = *p++;
+if( i >= (unsigned int )2047 )
+	{	/* Saturate at largest number less than infinity. */
+#ifdef INFINITY
+	*y |= 0x7ff0;
+#ifdef IBMPC
+	*(--y) = 0;
+	*(--y) = 0;
+	*(--y) = 0;
+#else /* !IBMPC */
+	++y;
+	*y++ = 0;
+	*y++ = 0;
+	*y++ = 0;
+#endif /* IBMPC */
+#else /* !INFINITY */
+	*y |= (unsigned short )0x7fef;
+#ifdef IBMPC
+	*(--y) = 0xffff;
+	*(--y) = 0xffff;
+	*(--y) = 0xffff;
+#else /* !IBMPC */
+	++y;
+	*y++ = 0xffff;
+	*y++ = 0xffff;
+	*y++ = 0xffff;
+#endif
+#endif /* !INFINITY */
+	return;
+	}
+if( i == 0 )
+	{
+	(void )eshift( x, 4 );
+	}
+else
+	{
+	i <<= 4;
+	(void )eshift( x, 5 );
+	}
+i |= *p++ & (unsigned short )0x0f;	/* *p = xi[M] */
+*y |= (unsigned short )i; /* high order output already has sign bit set */
+#ifdef IBMPC
+*(--y) = *p++;
+*(--y) = *p++;
+*(--y) = *p;
+#else /* !IBMPC */
+++y;
+*y++ = *p++;
+*y++ = *p++;
+*y++ = *p++;
+#endif /* !IBMPC */
+}
+
+#endif /* not DEC */
+#endif /* SIMD_LDBL_MANT_DIG == 53 */
+
+#if SIMD_LDBL_MANT_DIG == 24
+/*
+; Convert IEEE single precision to e type
+;	float d;
+;	unsigned short x[N+2];
+;	dtox( &d, x );
+*/
+void e24toe( short unsigned int *pe, short unsigned int *y, LDPARMS *ldp )
+{
+register unsigned short r;
+register unsigned short *p, *e;
+unsigned short yy[NI];
+int denorm, k;
+
+e = pe;
+denorm = 0;	/* flag if denormalized number */
+ecleaz(yy);
+#ifdef IBMPC
+e += 1;
+#endif
+#ifdef DEC
+e += 1;
+#endif
+r = *e;
+yy[0] = 0;
+if( r & 0x8000 )
+	yy[0] = 0xffff;
+yy[M] = (r & 0x7f) | 0200;
+r &= ~0x807f;	/* strip sign and 7 significand bits */
+#ifdef INFINITY
+if( r == 0x7f80 )
+	{
+#ifdef NANS
+#ifdef MIEEE
+	if( ((pe[0] & 0x7f) != 0) || (pe[1] != 0) )
+		{
+		enan( y, NBITS );
+		return;
+		}
+#else  /* !MIEEE */
+	if( ((pe[1] & 0x7f) != 0) || (pe[0] != 0) )
+		{
+		enan( y, NBITS );
+		return;
+		}
+#endif /* !MIEEE */
+#endif  /* NANS */
+	eclear( y );
+	einfin( y, ldp );
+	if( yy[0] )
+		eneg(y);
+	return;
+	}
+#endif
+r >>= 7;
+/* If zero exponent, then the significand is denormalized.
+ * So, take back the understood high significand bit. */ 
+if( r == 0 )
+	{
+	denorm = 1;
+	yy[M] &= ~0200;
+	}
+r += EXONE - 0177;
+yy[E] = r;
+p = &yy[M+1];
+#ifdef IBMPC
+*p++ = *(--e);
+#endif
+#ifdef DEC
+*p++ = *(--e);
+#endif
+#ifdef MIEEE
+++e;
+*p++ = *e++;
+#endif
+(void )eshift( yy, -8 );
+if( denorm )
+	{ /* if zero exponent, then normalize the significand */
+	if( (k = enormlz(yy)) > NBITS )
+		ecleazs(yy);
+	else
+		yy[E] -= (unsigned short )(k-1);
+	}
+emovo( yy, y, ldp );
+}
+
+static void toe24(short unsigned int *x, short unsigned int *y)
+{
+unsigned short i;
+unsigned short *p;
+
+#ifdef NANS
+if( eiisnan(x) )
+	{
+	enan( y, 24 );
+	return;
+	}
+#endif
+p = &x[0];
+#ifdef IBMPC
+y += 1;
+#endif
+#ifdef DEC
+y += 1;
+#endif
+*y = 0;	/* output high order */
+if( *p++ )
+	*y = 0x8000;	/* output sign bit */
+
+i = *p++;
+if( i >= 255 )
+	{	/* Saturate at largest number less than infinity. */
+#ifdef INFINITY
+	*y |= (unsigned short )0x7f80;
+#ifdef IBMPC
+	*(--y) = 0;
+#endif
+#ifdef DEC
+	*(--y) = 0;
+#endif
+#ifdef MIEEE
+	++y;
+	*y = 0;
+#endif
+#else /* !INFINITY */
+	*y |= (unsigned short )0x7f7f;
+#ifdef IBMPC
+	*(--y) = 0xffff;
+#endif
+#ifdef DEC
+	*(--y) = 0xffff;
+#endif
+#ifdef MIEEE
+	++y;
+	*y = 0xffff;
+#endif
+#endif /* !INFINITY */
+	return;
+	}
+if( i == 0 )
+	{
+	(void )eshift( x, 7 );
+	}
+else
+	{
+	i <<= 7;
+	(void )eshift( x, 8 );
+	}
+i |= *p++ & (unsigned short )0x7f;	/* *p = xi[M] */
+*y |= i;	/* high order output already has sign bit set */
+#ifdef IBMPC
+*(--y) = *p;
+#endif
+#ifdef DEC
+*(--y) = *p;
+#endif
+#ifdef MIEEE
+++y;
+*y = *p;
+#endif
+}
+#endif /* SIMD_LDBL_MANT_DIG == 24 */
+
+/* Compare two e type numbers.
+ *
+ * unsigned short a[NE], b[NE];
+ * ecmp( a, b );
+ *
+ *  returns +1 if a > b
+ *           0 if a == b
+ *          -1 if a < b
+ *          -2 if either a or b is a NaN.
+ */
+static int ecmp(short unsigned int *a, short unsigned int *b)
+{
+unsigned short ai[NI], bi[NI];
+register unsigned short *p, *q;
+register int i;
+int msign;
+
+#ifdef NANS
+if (eisnan (a)  || eisnan (b))
+	return( -2 );
+#endif
+emovi( a, ai );
+p = ai;
+emovi( b, bi );
+q = bi;
+
+if( *p != *q )
+	{ /* the signs are different */
+/* -0 equals + 0 */
+	for( i=1; i<NI-1; i++ )
+		{
+		if( ai[i] != 0 )
+			goto nzro;
+		if( bi[i] != 0 )
+			goto nzro;
+		}
+	return(0);
+nzro:
+	if( *p == 0 )
+		return( 1 );
+	else
+		return( -1 );
+	}
+/* both are the same sign */
+if( *p == 0 )
+	msign = 1;
+else
+	msign = -1;
+i = NI-1;
+do
+	{
+	if( *p++ != *q++ )
+		{
+		goto diff;
+		}
+	}
+while( --i > 0 );
+
+return(0);	/* equality */
+
+
+
+diff:
+
+if( *(--p) > *(--q) )
+	return( msign );		/* p is bigger */
+else
+	return( -msign );	/* p is littler */
+}
+
+
+/*
+;	Shift significand
+;
+;	Shifts significand area up or down by the number of bits
+;	given by the variable sc.
+*/
+static int eshift(short unsigned int *x, int sc)
+{
+unsigned short lost;
+unsigned short *p;
+
+if( sc == 0 )
+	return( 0 );
+
+lost = 0;
+p = x + NI-1;
+
+if( sc < 0 )
+	{
+	sc = -sc;
+	while( sc >= 16 )
+		{
+		lost |= *p;	/* remember lost bits */
+		eshdn6(x);
+		sc -= 16;
+		}
+
+	while( sc >= 8 )
+		{
+		lost |= *p & 0xff;
+		eshdn8(x);
+		sc -= 8;
+		}
+
+	while( sc > 0 )
+		{
+		lost |= *p & 1;
+		eshdn1(x);
+		sc -= 1;
+		}
+	}
+else
+	{
+	while( sc >= 16 )
+		{
+		eshup6(x);
+		sc -= 16;
+		}
+
+	while( sc >= 8 )
+		{
+		eshup8(x);
+		sc -= 8;
+		}
+
+	while( sc > 0 )
+		{
+		eshup1(x);
+		sc -= 1;
+		}
+	}
+if( lost )
+	lost = 1;
+return( (int )lost );
+}
+
+
+
+/*
+;	normalize
+;
+; Shift normalizes the significand area pointed to by argument
+; shift count (up = positive) is returned.
+*/
+static int enormlz(short unsigned int *x)
+{
+register unsigned short *p;
+int sc;
+
+sc = 0;
+p = &x[M];
+if( *p != 0 )
+	goto normdn;
+++p;
+if( *p & 0x8000 )
+	return( 0 );	/* already normalized */
+while( *p == 0 )
+	{
+	eshup6(x);
+	sc += 16;
+/* With guard word, there are NBITS+16 bits available.
+ * return true if all are zero.
+ */
+	if( sc > NBITS )
+		return( sc );
+	}
+/* see if high byte is zero */
+while( (*p & 0xff00) == 0 )
+	{
+	eshup8(x);
+	sc += 8;
+	}
+/* now shift 1 bit at a time */
+while( (*p  & 0x8000) == 0)
+	{
+	eshup1(x);
+	sc += 1;
+	if( sc > (NBITS+16) )
+		{
+		mtherr( "enormlz", UNDERFLOW );
+		return( sc );
+		}
+	}
+return( sc );
+
+/* Normalize by shifting down out of the high guard word
+   of the significand */
+normdn:
+
+if( *p & 0xff00 )
+	{
+	eshdn8(x);
+	sc -= 8;
+	}
+while( *p != 0 )
+	{
+	eshdn1(x);
+	sc -= 1;
+
+	if( sc < -NBITS )
+		{
+		mtherr( "enormlz", OVERFLOW );
+		return( sc );
+		}
+	}
+return( sc );
+}
+
+
+
+
+/* Convert e type number to decimal format ASCII string.
+ * The constants are for 64 bit precision.
+ */
+
+#define NTEN 12
+#define MAXP 4096
+
+#if NE == 10
+static unsigned short etens[NTEN + 1][NE] =
+{
+  {0x6576, 0x4a92, 0x804a, 0x153f,
+   0xc94c, 0x979a, 0x8a20, 0x5202, 0xc460, 0x7525,},	/* 10**4096 */
+  {0x6a32, 0xce52, 0x329a, 0x28ce,
+   0xa74d, 0x5de4, 0xc53d, 0x3b5d, 0x9e8b, 0x5a92,},	/* 10**2048 */
+  {0x526c, 0x50ce, 0xf18b, 0x3d28,
+   0x650d, 0x0c17, 0x8175, 0x7586, 0xc976, 0x4d48,},
+  {0x9c66, 0x58f8, 0xbc50, 0x5c54,
+   0xcc65, 0x91c6, 0xa60e, 0xa0ae, 0xe319, 0x46a3,},
+  {0x851e, 0xeab7, 0x98fe, 0x901b,
+   0xddbb, 0xde8d, 0x9df9, 0xebfb, 0xaa7e, 0x4351,},
+  {0x0235, 0x0137, 0x36b1, 0x336c,
+   0xc66f, 0x8cdf, 0x80e9, 0x47c9, 0x93ba, 0x41a8,},
+  {0x50f8, 0x25fb, 0xc76b, 0x6b71,
+   0x3cbf, 0xa6d5, 0xffcf, 0x1f49, 0xc278, 0x40d3,},
+  {0x0000, 0x0000, 0x0000, 0x0000,
+   0xf020, 0xb59d, 0x2b70, 0xada8, 0x9dc5, 0x4069,},
+  {0x0000, 0x0000, 0x0000, 0x0000,
+   0x0000, 0x0000, 0x0400, 0xc9bf, 0x8e1b, 0x4034,},
+  {0x0000, 0x0000, 0x0000, 0x0000,
+   0x0000, 0x0000, 0x0000, 0x2000, 0xbebc, 0x4019,},
+  {0x0000, 0x0000, 0x0000, 0x0000,
+   0x0000, 0x0000, 0x0000, 0x0000, 0x9c40, 0x400c,},
+  {0x0000, 0x0000, 0x0000, 0x0000,
+   0x0000, 0x0000, 0x0000, 0x0000, 0xc800, 0x4005,},
+  {0x0000, 0x0000, 0x0000, 0x0000,
+   0x0000, 0x0000, 0x0000, 0x0000, 0xa000, 0x4002,},	/* 10**1 */
+};
+
+static unsigned short emtens[NTEN + 1][NE] =
+{
+  {0x2030, 0xcffc, 0xa1c3, 0x8123,
+   0x2de3, 0x9fde, 0xd2ce, 0x04c8, 0xa6dd, 0x0ad8,},	/* 10**-4096 */
+  {0x8264, 0xd2cb, 0xf2ea, 0x12d4,
+   0x4925, 0x2de4, 0x3436, 0x534f, 0xceae, 0x256b,},	/* 10**-2048 */
+  {0xf53f, 0xf698, 0x6bd3, 0x0158,
+   0x87a6, 0xc0bd, 0xda57, 0x82a5, 0xa2a6, 0x32b5,},
+  {0xe731, 0x04d4, 0xe3f2, 0xd332,
+   0x7132, 0xd21c, 0xdb23, 0xee32, 0x9049, 0x395a,},
+  {0xa23e, 0x5308, 0xfefb, 0x1155,
+   0xfa91, 0x1939, 0x637a, 0x4325, 0xc031, 0x3cac,},
+  {0xe26d, 0xdbde, 0xd05d, 0xb3f6,
+   0xac7c, 0xe4a0, 0x64bc, 0x467c, 0xddd0, 0x3e55,},
+  {0x2a20, 0x6224, 0x47b3, 0x98d7,
+   0x3f23, 0xe9a5, 0xa539, 0xea27, 0xa87f, 0x3f2a,},
+  {0x0b5b, 0x4af2, 0xa581, 0x18ed,
+   0x67de, 0x94ba, 0x4539, 0x1ead, 0xcfb1, 0x3f94,},
+  {0xbf71, 0xa9b3, 0x7989, 0xbe68,
+   0x4c2e, 0xe15b, 0xc44d, 0x94be, 0xe695, 0x3fc9,},
+  {0x3d4d, 0x7c3d, 0x36ba, 0x0d2b,
+   0xfdc2, 0xcefc, 0x8461, 0x7711, 0xabcc, 0x3fe4,},
+  {0xc155, 0xa4a8, 0x404e, 0x6113,
+   0xd3c3, 0x652b, 0xe219, 0x1758, 0xd1b7, 0x3ff1,},
+  {0xd70a, 0x70a3, 0x0a3d, 0xa3d7,
+   0x3d70, 0xd70a, 0x70a3, 0x0a3d, 0xa3d7, 0x3ff8,},
+  {0xcccd, 0xcccc, 0xcccc, 0xcccc,
+   0xcccc, 0xcccc, 0xcccc, 0xcccc, 0xcccc, 0x3ffb,},	/* 10**-1 */
+};
+#else
+static unsigned short etens[NTEN+1][NE] = {
+{0xc94c,0x979a,0x8a20,0x5202,0xc460,0x7525,},/* 10**4096 */
+{0xa74d,0x5de4,0xc53d,0x3b5d,0x9e8b,0x5a92,},/* 10**2048 */
+{0x650d,0x0c17,0x8175,0x7586,0xc976,0x4d48,},
+{0xcc65,0x91c6,0xa60e,0xa0ae,0xe319,0x46a3,},
+{0xddbc,0xde8d,0x9df9,0xebfb,0xaa7e,0x4351,},
+{0xc66f,0x8cdf,0x80e9,0x47c9,0x93ba,0x41a8,},
+{0x3cbf,0xa6d5,0xffcf,0x1f49,0xc278,0x40d3,},
+{0xf020,0xb59d,0x2b70,0xada8,0x9dc5,0x4069,},
+{0x0000,0x0000,0x0400,0xc9bf,0x8e1b,0x4034,},
+{0x0000,0x0000,0x0000,0x2000,0xbebc,0x4019,},
+{0x0000,0x0000,0x0000,0x0000,0x9c40,0x400c,},
+{0x0000,0x0000,0x0000,0x0000,0xc800,0x4005,},
+{0x0000,0x0000,0x0000,0x0000,0xa000,0x4002,}, /* 10**1 */
+};
+
+static unsigned short emtens[NTEN+1][NE] = {
+{0x2de4,0x9fde,0xd2ce,0x04c8,0xa6dd,0x0ad8,}, /* 10**-4096 */
+{0x4925,0x2de4,0x3436,0x534f,0xceae,0x256b,}, /* 10**-2048 */
+{0x87a6,0xc0bd,0xda57,0x82a5,0xa2a6,0x32b5,},
+{0x7133,0xd21c,0xdb23,0xee32,0x9049,0x395a,},
+{0xfa91,0x1939,0x637a,0x4325,0xc031,0x3cac,},
+{0xac7d,0xe4a0,0x64bc,0x467c,0xddd0,0x3e55,},
+{0x3f24,0xe9a5,0xa539,0xea27,0xa87f,0x3f2a,},
+{0x67de,0x94ba,0x4539,0x1ead,0xcfb1,0x3f94,},
+{0x4c2f,0xe15b,0xc44d,0x94be,0xe695,0x3fc9,},
+{0xfdc2,0xcefc,0x8461,0x7711,0xabcc,0x3fe4,},
+{0xd3c3,0x652b,0xe219,0x1758,0xd1b7,0x3ff1,},
+{0x3d71,0xd70a,0x70a3,0x0a3d,0xa3d7,0x3ff8,},
+{0xcccd,0xcccc,0xcccc,0xcccc,0xcccc,0x3ffb,}, /* 10**-1 */
+};
+#endif
+
+
+
+/* ASCII string outputs for unix */
+
+
+#if 0
+void _IO_ldtostr(x, string, ndigs, flags, fmt)
+long double *x;
+char *string;
+int ndigs;
+int flags;
+char fmt;
+{
+unsigned short w[NI];
+char *t, *u;
+LDPARMS rnd;
+LDPARMS *ldp = &rnd;
+
+rnd.rlast = -1;
+rnd.rndprc = NBITS;
+
+if (sizeof(long double) == 16)
+  e113toe( (unsigned short *)x, w, ldp );
+else
+  e64toe( (unsigned short *)x, w, ldp );
+
+etoasc( w, string, ndigs, -1, ldp );
+if( ndigs == 0 && flags == 0 )
+	{
+	/* Delete the decimal point unless alternate format.  */
+	t = string;	
+	while( *t != '.' )
+		++t;
+	u = t +  1;
+	while( *t != '\0' )
+		*t++ = *u++;
+	}
+if (*string == ' ')
+	{
+	t = string;	
+	u = t + 1;
+	while( *t != '\0' )
+		*t++ = *u++;
+	}
+if (fmt == 'E')
+	{
+	t = string;	
+	while( *t != 'e' )
+		++t;
+	*t = 'E';
+	}
+}
+
+#endif
+
+/* This routine will not return more than NDEC+1 digits. */
+
+#if 0
+char *
+_simdldtoa_r (struct _reent *ptr, LONG_DOUBLE_UNION *d, int mode, int ndigits, int *decpt, 
+          int *sign, char **rve)
+{
+unsigned short e[NI];
+char *s, *p;
+int i, j, k;
+LDPARMS rnd;
+LDPARMS *ldp = &rnd;
+char *outstr;
+
+rnd.rlast = -1;
+rnd.rndprc = NBITS;
+
+  _REENT_CHECK_MP(ptr);
+
+/* reentrancy addition to use mprec storage pool */
+if (_REENT_MP_RESULT(ptr))
+  {
+    _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
+    _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
+    Bfree (ptr, _REENT_MP_RESULT(ptr));
+    _REENT_MP_RESULT(ptr) = 0;
+  }
+
+#if SIMD_LDBL_MANT_DIG == 24
+e24toe( (unsigned short *)d, e, ldp );
+#elif SIMD_LDBL_MANT_DIG == 53
+e53toe( (unsigned short *)d, e, ldp );
+#elif SIMD_LDBL_MANT_DIG == 64
+e64toe( (unsigned short *)d, e, ldp );
+#else
+e113toe( (unsigned short *)d, e, ldp );
+#endif
+
+if( eisneg(e) )
+        *sign = 1;
+else
+        *sign = 0;
+/* Mode 3 is "f" format.  */
+if( mode != 3 )
+        ndigits -= 1;
+/* Mode 0 is for %.999 format, which is supposed to give a
+   minimum length string that will convert back to the same binary value.
+   For now, just ask for 20 digits which is enough but sometimes too many.  */
+if( mode == 0 )
+        ndigits = 20;
+
+/* reentrancy addition to use mprec storage pool */
+/* we want to have enough space to hold the formatted result */
+i = ndigits + (mode == 3 ? (MAX_EXP_DIGITS + 1) : 1);
+j = sizeof (__ULong);
+for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i; j <<= 1)
+  _REENT_MP_RESULT_K(ptr)++;
+_REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
+outstr = (char *)_REENT_MP_RESULT(ptr);
+
+/* This sanity limit must agree with the corresponding one in etoasc, to
+   keep straight the returned value of outexpon.  */
+if( ndigits > NDEC )
+        ndigits = NDEC;
+
+etoasc( e, outstr, ndigits, mode, ldp );
+s =  outstr;
+if( eisinf(e) || eisnan(e) )
+        {
+        *decpt = 9999;
+        goto stripspaces;
+        }
+*decpt = ldp->outexpon + 1;
+
+/* Transform the string returned by etoasc into what the caller wants.  */
+
+/* Look for decimal point and delete it from the string. */
+s = outstr;
+while( *s != '\0' )
+        {
+        if( *s == '.' )
+               goto yesdecpt;
+        ++s;
+        }
+goto nodecpt;
+
+yesdecpt:
+
+/* Delete the decimal point.  */
+while( *s != '\0' )
+        {
+        *s = *(s+1);
+        ++s;
+        }
+
+nodecpt:
+
+/* Back up over the exponent field. */
+while( *s != 'E' && s > outstr)
+        --s;
+*s = '\0';
+
+stripspaces:
+
+/* Strip leading spaces and sign. */
+p = outstr;
+while( *p == ' ' || *p == '-')
+        ++p;
+
+/* Find new end of string.  */
+s = outstr;
+while( (*s++ = *p++) != '\0' )
+        ;
+--s;
+
+/* Strip trailing zeros.  */
+if( mode == 2 )
+        k = 1;
+else if( ndigits > ldp->outexpon )
+        k = ndigits;
+else
+        k = ldp->outexpon;
+
+while( *(s-1) == '0' && ((s - outstr) > k))
+        *(--s) = '\0';
+
+/* In f format, flush small off-scale values to zero.
+   Rounding has been taken care of by etoasc. */
+if( mode == 3 && ((ndigits + ldp->outexpon) < 0))
+        {
+        s = outstr;
+        *s = '\0';
+        *decpt = 0;
+        }
+
+if( rve )
+        *rve = s;
+return outstr;
+}
+#endif
+
+/* Routine used to tell if long double is NaN or Infinity or regular number. 
+   Returns:  0 = regular number
+             1 = Nan
+             2 = Infinity
+*/
+int
+_simdldcheck (LONG_DOUBLE_UNION *d)
+{
+unsigned short e[NI];
+LDPARMS rnd;
+LDPARMS *ldp = &rnd;
+
+rnd.rlast = -1;
+rnd.rndprc = NBITS;
+
+#if SIMD_LDBL_MANT_DIG == 24
+e24toe( (unsigned short *)d, e, ldp );
+#elif SIMD_LDBL_MANT_DIG == 53
+e53toe( (unsigned short *)d, e, ldp );
+#elif SIMD_LDBL_MANT_DIG == 64
+e64toe( (unsigned short *)d, e, ldp );
+#else
+e113toe( (unsigned short *)d, e, ldp );
+#endif
+
+if( (e[NE-1] & 0x7fff) == 0x7fff )
+	{
+#ifdef NANS
+	if( eisnan(e) )
+		return( 1 );
+#endif
+	return( 2 );
+	}
+else
+	return( 0 );
+} /* _ldcheck */
+
+static void etoasc(short unsigned int *x, char *string, int ndigits, int outformat, LDPARMS *ldp)
+{
+long digit;
+unsigned short y[NI], t[NI], u[NI], w[NI];
+unsigned short *p, *r, *ten;
+unsigned short sign;
+int i, j, k, expon, rndsav, ndigs;
+char *s, *ss;
+unsigned short m;
+unsigned short *equot = ldp->equot;
+
+ndigs = ndigits;
+rndsav = ldp->rndprc;
+#ifdef NANS
+if( eisnan(x) )
+	{
+	sprintf( string, " NaN " );
+	expon = 9999;
+	goto bxit;
+	}
+#endif
+ldp->rndprc = NBITS;		/* set to full precision */
+emov( x, y ); /* retain external format */
+if( y[NE-1] & 0x8000 )
+	{
+	sign = 0xffff;
+	y[NE-1] &= 0x7fff;
+	}
+else
+	{
+	sign = 0;
+	}
+expon = 0;
+ten = &etens[NTEN][0];
+emov( eone, t );
+/* Test for zero exponent */
+if( y[NE-1] == 0 )
+	{
+	for( k=0; k<NE-1; k++ )
+		{
+		if( y[k] != 0 )
+			goto tnzro; /* denormalized number */
+		}
+	goto isone; /* legal all zeros */
+	}
+tnzro:
+
+/* Test for infinity.
+ */
+if( y[NE-1] == 0x7fff )
+	{
+	if( sign )
+		sprintf( string, " -Infinity " );
+	else
+		sprintf( string, " Infinity " );
+	expon = 9999;
+	goto bxit;
+	}
+
+/* Test for exponent nonzero but significand denormalized.
+ * This is an error condition.
+ */
+if( (y[NE-1] != 0) && ((y[NE-2] & 0x8000) == 0) )
+	{
+	mtherr( "etoasc", DOMAIN );
+	sprintf( string, "NaN" );
+	expon = 9999;
+	goto bxit;
+	}
+
+/* Compare to 1.0 */
+i = ecmp( eone, y );
+if( i == 0 )
+	goto isone;
+
+if( i < 0 )
+	{ /* Number is greater than 1 */
+/* Convert significand to an integer and strip trailing decimal zeros. */
+	emov( y, u );
+	u[NE-1] = EXONE + NBITS - 1;
+
+	p = &etens[NTEN-4][0];
+	m = 16;
+do
+	{
+	ediv( p, u, t, ldp );
+	efloor( t, w, ldp );
+	for( j=0; j<NE-1; j++ )
+		{
+		if( t[j] != w[j] )
+			goto noint;
+		}
+	emov( t, u );
+	expon += (int )m;
+noint:
+	p += NE;
+	m >>= 1;
+	}
+while( m != 0 );
+
+/* Rescale from integer significand */
+	u[NE-1] += y[NE-1] - (unsigned int )(EXONE + NBITS - 1);
+	emov( u, y );
+/* Find power of 10 */
+	emov( eone, t );
+	m = MAXP;
+	p = &etens[0][0];
+	while( ecmp( ten, u ) <= 0 )
+		{
+		if( ecmp( p, u ) <= 0 )
+			{
+			ediv( p, u, u, ldp );
+			emul( p, t, t, ldp );
+			expon += (int )m;
+			}
+		m >>= 1;
+		if( m == 0 )
+			break;
+		p += NE;
+		}
+	}
+else
+	{ /* Number is less than 1.0 */
+/* Pad significand with trailing decimal zeros. */
+	if( y[NE-1] == 0 )
+		{
+		while( (y[NE-2] & 0x8000) == 0 )
+			{
+			emul( ten, y, y, ldp );
+			expon -= 1;
+			}
+		}
+	else
+		{
+		emovi( y, w );
+		for( i=0; i<NDEC+1; i++ )
+			{
+			if( (w[NI-1] & 0x7) != 0 )
+				break;
+/* multiply by 10 */
+			emovz( w, u );
+			eshdn1( u );
+			eshdn1( u );
+			eaddm( w, u );
+			u[1] += 3;
+			while( u[2] != 0 )
+				{
+				eshdn1(u);
+				u[1] += 1;
+				}
+			if( u[NI-1] != 0 )
+				break;
+			if( eone[NE-1] <= u[1] )
+				break;
+			emovz( u, w );
+			expon -= 1;
+			}
+		emovo( w, y, ldp );
+		}
+	k = -MAXP;
+	p = &emtens[0][0];
+	r = &etens[0][0];
+	emov( y, w );
+	emov( eone, t );
+	while( ecmp( eone, w ) > 0 )
+		{
+		if( ecmp( p, w ) >= 0 )
+			{
+			emul( r, w, w, ldp );
+			emul( r, t, t, ldp );
+			expon += k;
+			}
+		k /= 2;
+		if( k == 0 )
+			break;
+		p += NE;
+		r += NE;
+		}
+	ediv( t, eone, t, ldp );
+	}
+isone:
+/* Find the first (leading) digit. */
+emovi( t, w );
+emovz( w, t );
+emovi( y, w );
+emovz( w, y );
+eiremain( t, y, ldp );
+digit = equot[NI-1];
+while( (digit == 0) && (ecmp(y,ezero) != 0) )
+	{
+	eshup1( y );
+	emovz( y, u );
+	eshup1( u );
+	eshup1( u );
+	eaddm( u, y );
+	eiremain( t, y, ldp );
+	digit = equot[NI-1];
+	expon -= 1;
+	}
+s = string;
+if( sign )
+	*s++ = '-';
+else
+	*s++ = ' ';
+/* Examine number of digits requested by caller. */
+if( outformat == 3 )
+        ndigs += expon;
+/*
+else if( ndigs < 0 )
+        ndigs = 0;
+*/
+if( ndigs > NDEC )
+	ndigs = NDEC;
+if( digit == 10 )
+	{
+	*s++ = '1';
+	*s++ = '.';
+	if( ndigs > 0 )
+		{
+		*s++ = '0';
+		ndigs -= 1;
+		}
+	expon += 1;
+	if( ndigs < 0 )
+	        {
+	        ss = s;
+	        goto doexp;
+	        }
+	}
+else
+	{
+	*s++ = (char )digit + '0';
+	*s++ = '.';
+	}
+/* Generate digits after the decimal point. */
+for( k=0; k<=ndigs; k++ )
+	{
+/* multiply current number by 10, without normalizing */
+	eshup1( y );
+	emovz( y, u );
+	eshup1( u );
+	eshup1( u );
+	eaddm( u, y );
+	eiremain( t, y, ldp );
+	*s++ = (char )equot[NI-1] + '0';
+	}
+digit = equot[NI-1];
+--s;
+ss = s;
+/* round off the ASCII string */
+if( digit > 4 )
+	{
+/* Test for critical rounding case in ASCII output. */
+	if( digit == 5 )
+		{
+		emovo( y, t, ldp );
+		if( ecmp(t,ezero) != 0 )
+			goto roun;	/* round to nearest */
+		if( (*(s-1) & 1) == 0 )
+			goto doexp;	/* round to even */
+		}
+/* Round up and propagate carry-outs */
+roun:
+	--s;
+	k = *s & 0x7f;
+/* Carry out to most significant digit? */
+	if( ndigs < 0 )
+		{
+	        /* This will print like "1E-6". */
+		*s = '1';
+		expon += 1;
+		goto doexp;
+		}
+	else if( k == '.' )
+		{
+		--s;
+		k = *s;
+		k += 1;
+		*s = (char )k;
+/* Most significant digit carries to 10? */
+		if( k > '9' )
+			{
+			expon += 1;
+			*s = '1';
+			}
+		goto doexp;
+		}
+/* Round up and carry out from less significant digits */
+	k += 1;
+	*s = (char )k;
+	if( k > '9' )
+		{
+		*s = '0';
+		goto roun;
+		}
+	}
+doexp:
+#ifdef __GO32__
+if( expon >= 0 )
+	sprintf( ss, "e+%02d", expon );
+else
+	sprintf( ss, "e-%02d", -expon );
+#else
+	sprintf( ss, "E%d", expon );
+#endif
+bxit:
+ldp->rndprc = rndsav;
+ldp->outexpon =  expon;
+}
+
+
+
+
+/*
+;								ASCTOQ
+;		ASCTOQ.MAC		LATEST REV: 11 JAN 84
+;					SLM, 3 JAN 78
+;
+;	Convert ASCII string to quadruple precision floating point
+;
+;		Numeric input is free field decimal number
+;		with max of 15 digits with or without 
+;		decimal point entered as ASCII from teletype.
+;	Entering E after the number followed by a second
+;	number causes the second number to be interpreted
+;	as a power of 10 to be multiplied by the first number
+;	(i.e., "scientific" notation).
+;
+;	Usage:
+;		asctoq( string, q );
+*/
+
+void _simdstrtold (char *s, char **se, LONG_DOUBLE_UNION *x)
+{
+  LDPARMS rnd;
+  LDPARMS *ldp = &rnd;
+  int lenldstr;
+
+  rnd.rlast = -1;
+  rnd.rndprc = NBITS;
+
+  lenldstr = asctoeg( s, (unsigned short *)x, SIMD_LDBL_MANT_DIG, ldp );
+  if (se)
+    *se = s + lenldstr;
+}
+
+#define REASONABLE_LEN 200
+
+static int
+asctoeg(char *ss, short unsigned int *y, int oprec, LDPARMS *ldp)
+{
+unsigned short yy[NI], xt[NI], tt[NI];
+int esign, decflg, sgnflg, nexp, exp, prec, lost;
+int k, trail, c, rndsav;
+long lexp;
+unsigned short nsign, *p;
+char *sp, *s, *lstr;
+int lenldstr;
+int mflag = 0;
+char tmpstr[REASONABLE_LEN];
+
+/* Copy the input string. */
+c = strlen (ss) + 2;
+if (c <= REASONABLE_LEN)
+  lstr = tmpstr;
+else
+  {
+    lstr = (char *) calloc (c, 1);
+    mflag = 1;
+  }
+s = ss;
+lenldstr = 0;
+while( *s == ' ' ) /* skip leading spaces */
+  {
+    ++s;
+    ++lenldstr;
+  }
+sp = lstr;
+for( k=0; k<c; k++ )
+	{
+	if( (*sp++ = *s++) == '\0' )
+		break;
+	}
+*sp = '\0';
+s = lstr;
+
+rndsav = ldp->rndprc;
+ldp->rndprc = NBITS; /* Set to full precision */
+lost = 0;
+nsign = 0;
+decflg = 0;
+sgnflg = 0;
+nexp = 0;
+exp = 0;
+prec = 0;
+ecleaz( yy );
+trail = 0;
+
+nxtcom:
+k = *s - '0';
+if( (k >= 0) && (k <= 9) )
+	{
+/* Ignore leading zeros */
+	if( (prec == 0) && (decflg == 0) && (k == 0) )
+		goto donchr;
+/* Identify and strip trailing zeros after the decimal point. */
+	if( (trail == 0) && (decflg != 0) )
+		{
+		sp = s;
+		while( (*sp >= '0') && (*sp <= '9') )
+			++sp;
+/* Check for syntax error */
+		c = *sp & 0x7f;
+		if( (c != 'e') && (c != 'E') && (c != '\0')
+			&& (c != '\n') && (c != '\r') && (c != ' ')
+			&& (c != ',') )
+			goto error;
+		--sp;
+		while( *sp == '0' )
+			*sp-- = 'z';
+		trail = 1;
+		if( *s == 'z' )
+			goto donchr;
+		}
+/* If enough digits were given to more than fill up the yy register,
+ * continuing until overflow into the high guard word yy[2]
+ * guarantees that there will be a roundoff bit at the top
+ * of the low guard word after normalization.
+ */
+	if( yy[2] == 0 )
+		{
+		if( decflg )
+			nexp += 1; /* count digits after decimal point */
+		eshup1( yy );	/* multiply current number by 10 */
+		emovz( yy, xt );
+		eshup1( xt );
+		eshup1( xt );
+		eaddm( xt, yy );
+		ecleaz( xt );
+		xt[NI-2] = (unsigned short )k;
+		eaddm( xt, yy );
+		}
+	else
+		{
+		/* Mark any lost non-zero digit.  */
+		lost |= k;
+		/* Count lost digits before the decimal point.  */
+		if (decflg == 0)
+		        nexp -= 1;
+		}
+	prec += 1;
+	goto donchr;
+	}
+
+switch( *s )
+	{
+	case 'z':
+		break;
+	case 'E':
+	case 'e':
+		goto expnt;
+	case '.':	/* decimal point */
+		if( decflg )
+			goto error;
+		++decflg;
+		break;
+	case '-':
+		nsign = 0xffff;
+		if( sgnflg )
+			goto error;
+		++sgnflg;
+		break;
+	case '+':
+		if( sgnflg )
+			goto error;
+		++sgnflg;
+		break;
+	case ',':
+	case ' ':
+	case '\0':
+	case '\n':
+	case '\r':
+		goto daldone;
+	case 'i':
+	case 'I':
+		goto infinite;
+	default:
+	error:
+#ifdef NANS
+		enan( yy, NI*16 );
+#else
+		mtherr( "asctoe", DOMAIN );
+		ecleaz(yy);
+#endif
+		goto aexit;
+	}
+donchr:
+++s;
+goto nxtcom;
+
+/* Exponent interpretation */
+expnt:
+
+esign = 1;
+exp = 0;
+++s;
+/* check for + or - */
+if( *s == '-' )
+	{
+	esign = -1;
+	++s;
+	}
+if( *s == '+' )
+	++s;
+while( (*s >= '0') && (*s <= '9') )
+	{
+	exp *= 10;
+	exp += *s++ - '0';
+	if (exp > 4977)
+		{
+		if (esign < 0)
+			goto zero;
+		else
+			goto infinite;
+		}
+	}
+if( esign < 0 )
+	exp = -exp;
+if( exp > 4932 )
+	{
+infinite:
+	ecleaz(yy);
+	yy[E] = 0x7fff;  /* infinity */
+	goto aexit;
+	}
+if( exp < -4977 )
+	{
+zero:
+	ecleaz(yy);
+	goto aexit;
+	}
+
+daldone:
+nexp = exp - nexp;
+/* Pad trailing zeros to minimize power of 10, per IEEE spec. */
+while( (nexp > 0) && (yy[2] == 0) )
+	{
+	emovz( yy, xt );
+	eshup1( xt );
+	eshup1( xt );
+	eaddm( yy, xt );
+	eshup1( xt );
+	if( xt[2] != 0 )
+		break;
+	nexp -= 1;
+	emovz( xt, yy );
+	}
+if( (k = enormlz(yy)) > NBITS )
+	{
+	ecleaz(yy);
+	goto aexit;
+	}
+lexp = (EXONE - 1 + NBITS) - k;
+emdnorm( yy, lost, 0, lexp, 64, ldp );
+/* convert to external format */
+
+
+/* Multiply by 10**nexp.  If precision is 64 bits,
+ * the maximum relative error incurred in forming 10**n
+ * for 0 <= n <= 324 is 8.2e-20, at 10**180.
+ * For 0 <= n <= 999, the peak relative error is 1.4e-19 at 10**947.
+ * For 0 >= n >= -999, it is -1.55e-19 at 10**-435.
+ */
+lexp = yy[E];
+if( nexp == 0 )
+	{
+	k = 0;
+	goto expdon;
+	}
+esign = 1;
+if( nexp < 0 )
+	{
+	nexp = -nexp;
+	esign = -1;
+	if( nexp > 4096 )
+		{ /* Punt.  Can't handle this without 2 divides. */
+		emovi( etens[0], tt );
+		lexp -= tt[E];
+		k = edivm( tt, yy, ldp );
+		lexp += EXONE;
+		nexp -= 4096;
+		}
+	}
+p = &etens[NTEN][0];
+emov( eone, xt );
+exp = 1;
+do
+	{
+	if( exp & nexp )
+		emul( p, xt, xt, ldp );
+	p -= NE;
+	exp = exp + exp;
+	}
+while( exp <= MAXP );
+
+emovi( xt, tt );
+if( esign < 0 )
+	{
+	lexp -= tt[E];
+	k = edivm( tt, yy, ldp );
+	lexp += EXONE;
+	}
+else
+	{
+	lexp += tt[E];
+	k = emulm( tt, yy, ldp );
+	lexp -= EXONE - 1;
+	}
+
+expdon:
+
+/* Round and convert directly to the destination type */
+if( oprec == 53 )
+	lexp -= EXONE - 0x3ff;
+else if( oprec == 24 )
+	lexp -= EXONE - 0177;
+#ifdef DEC
+else if( oprec == 56 )
+	lexp -= EXONE - 0201;
+#endif
+ldp->rndprc = oprec;
+emdnorm( yy, k, 0, lexp, 64, ldp );
+
+aexit:
+
+ldp->rndprc = rndsav;
+yy[0] = nsign;
+switch( oprec )
+	{
+#ifdef DEC
+	case 56:
+		todec( yy, y ); /* see etodec.c */
+		break;
+#endif
+#if SIMD_LDBL_MANT_DIG == 53
+	case 53:
+		toe53( yy, y );
+		break;
+#elif SIMD_LDBL_MANT_DIG == 24
+	case 24:
+		toe24( yy, y );
+		break;
+#elif SIMD_LDBL_MANT_DIG == 64
+	case 64:
+		toe64( yy, y );
+		break;
+#elif SIMD_LDBL_MANT_DIG == 113
+	case 113:
+		toe113( yy, y );
+		break;
+#else
+	case NBITS:
+		emovo( yy, y, ldp );
+		break;
+#endif
+	}
+lenldstr += s - lstr;
+if (mflag)
+  free (lstr);
+return lenldstr;
+}
+
+
+ 
+/* y = largest integer not greater than x
+ * (truncated toward minus infinity)
+ *
+ * unsigned short x[NE], y[NE]
+ * LDPARMS *ldp
+ *
+ * efloor( x, y, ldp );
+ */
+static unsigned short bmask[] = {
+0xffff,
+0xfffe,
+0xfffc,
+0xfff8,
+0xfff0,
+0xffe0,
+0xffc0,
+0xff80,
+0xff00,
+0xfe00,
+0xfc00,
+0xf800,
+0xf000,
+0xe000,
+0xc000,
+0x8000,
+0x0000,
+};
+
+static void efloor(short unsigned int *x, short unsigned int *y, LDPARMS *ldp)
+{
+register unsigned short *p;
+int e, expon, i;
+unsigned short f[NE];
+
+emov( x, f ); /* leave in external format */
+expon = (int )f[NE-1];
+e = (expon & 0x7fff) - (EXONE - 1);
+if( e <= 0 )
+	{
+	eclear(y);
+	goto isitneg;
+	}
+/* number of bits to clear out */
+e = NBITS - e;
+emov( f, y );
+if( e <= 0 )
+	return;
+
+p = &y[0];
+while( e >= 16 )
+	{
+	*p++ = 0;
+	e -= 16;
+	}
+/* clear the remaining bits */
+*p &= bmask[e];
+/* truncate negatives toward minus infinity */
+isitneg:
+
+if( (unsigned short )expon & (unsigned short )0x8000 )
+	{
+	for( i=0; i<NE-1; i++ )
+		{
+		if( f[i] != y[i] )
+			{
+			esub( eone, y, y, ldp );
+			break;
+			}
+		}
+	}
+}
+
+
+
+static void eiremain(short unsigned int *den, short unsigned int *num, LDPARMS *ldp)
+{
+long ld, ln;
+unsigned short j;
+ unsigned short *equot = ldp->equot;
+
+ld = den[E];
+ld -= enormlz( den );
+ln = num[E];
+ln -= enormlz( num );
+ecleaz( equot );
+while( ln >= ld )
+	{
+	if( ecmpm(den,num) <= 0 )
+		{
+		esubm(den, num);
+		j = 1;
+		}
+	else
+		{
+		j = 0;
+		}
+	eshup1(equot);
+	equot[NI-1] |= j;
+	eshup1(num);
+	ln -= 1;
+	}
+emdnorm( num, 0, 0, ln, 0, ldp );
+}
+
+/* NaN bit patterns
+ */
+#ifdef MIEEE
+static unsigned short nan113[8] = {
+  0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};
+static unsigned short nan64[6] = {0x7fff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff};
+static unsigned short nan53[4] = {0x7fff, 0xffff, 0xffff, 0xffff};
+static unsigned short nan24[2] = {0x7fff, 0xffff};
+#else /* !MIEEE */
+static unsigned short nan113[8] = {0, 0, 0, 0, 0, 0, 0x8000, 0x7fff};
+static unsigned short nan64[6] = {0, 0, 0, 0, 0xc000, 0x7fff};
+static unsigned short nan53[4] = {0, 0, 0, 0x7ff8};
+static unsigned short nan24[2] = {0, 0x7fc0};
+#endif /* !MIEEE */
+
+
+static void enan (short unsigned int *nan, int size)
+{
+int i, n;
+unsigned short *p;
+
+switch( size )
+	{
+#ifndef DEC
+	case 113:
+	n = 8;
+	p = nan113;
+	break;
+
+	case 64:
+	n = 6;
+	p = nan64;
+	break;
+
+	case 53:
+	n = 4;
+	p = nan53;
+	break;
+
+	case 24:
+	n = 2;
+	p = nan24;
+	break;
+
+	case NBITS:
+	for( i=0; i<NE-2; i++ )
+		*nan++ = 0;
+	*nan++ = 0xc000;
+	*nan++ = 0x7fff;
+	return;
+
+	case NI*16:
+	*nan++ = 0;
+	*nan++ = 0x7fff;
+	*nan++ = 0;
+	*nan++ = 0xc000;
+	for( i=4; i<NI; i++ )
+		*nan++ = 0;
+	return;
+#endif
+	default:
+	mtherr( "enan", DOMAIN );
+	return;
+	}
+for (i=0; i < n; i++)
+	*nan++ = *p++;
+}
diff -uNr glibc-2.3.2.orig/spe/strtosfix16.c glibc-2.3.2/spe/strtosfix16.c
--- glibc-2.3.2.orig/spe/strtosfix16.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/strtosfix16.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,189 @@
+/*
+FUNCTION
+        <<strtosfix16>>, <<strtosfix32>>, <<strtosfix64>>---string to signed fixed point
+
+INDEX
+	strtosfix16
+INDEX
+	strtosfix32
+INDEX
+	strtosfix64
+INDEX
+	_strtosfix16_r
+INDEX
+	_strtosfix32_r
+INDEX
+	_strtosfix64_r
+
+ANSI_SYNOPSIS
+	#include <stdlib.h>
+        __int16 strtosfix16 (const char *<[s]>, char **<[ptr]>);
+
+        __int32 strtosfix32 (const char *<[s]>, char **<[ptr]>);
+
+        __int64 strtosfix64 (const char *<[s]>, char **<[ptr]>);
+
+        __int16 _strtosfix16_r (void *<[reent]>, 
+                       const char *<[s]>, char **<[ptr]>);
+
+        __int32 _strtosfix32_r (void *<[reent]>, 
+                       const char *<[s]>, char **<[ptr]>);
+
+        __int64 _strtosfix64_r (void *<[reent]>, 
+                       const char *<[s]>, char **<[ptr]>);
+
+TRAD_SYNOPSIS
+	#include <stdlib.h>
+	__int16 strtosfix16 (<[s]>, <[ptr]>)
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__int32 strtosfix32 (<[s]>, <[ptr]>)
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__int64 strtosfix64 (<[s]>, <[ptr]>)
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__int16 _strtosfix16_r (<[reent]>, <[s]>, <[ptr]>)
+	char *<[reent]>;
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__int32 _strtosfix32_r (<[reent]>, <[s]>, <[ptr]>)
+	char *<[reent]>;
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__int64 _strtosfix64_r (<[reent]>, <[s]>, <[ptr]>)
+	char *<[reent]>;
+        char *<[s]>;
+        char **<[ptr]>;
+
+DESCRIPTION
+        The function <<strtosfix16>> converts the string <<*<[s]>>> to
+	a fixed-point sign + 15-bits fraction representation.  The function 
+	follows the same rules as <<strtod>>.
+
+	The substring converted is the longest initial
+	subsequence of <[s]>, beginning with the first
+	non-whitespace character, that has the format:
+	.[+|-]<[digits]>[.][<[digits]>][(e|E)[+|-]<[digits]>] 
+	The substring contains no characters if <[s]> is empty, consists
+	entirely of whitespace, or if the first non-whitespace
+	character is something other than <<+>>, <<->>, <<.>>, or a
+	digit. If the substring is empty, no conversion is done, and
+	the value of <[s]> is stored in <<*<[ptr]>>>.  Otherwise,
+	the substring is converted, and a pointer to the final string
+	(which will contain at least the terminating null character of
+	<[s]>) is stored in <<*<[ptr]>>>.  If you want no
+	assignment to <<*<[ptr]>>>, pass a null pointer as <[ptr]>.
+
+	<<strtosfix32>> is identical to <<strtosfix16>> except that it 
+	converts to fixed-point sign + 31-bits fraction representation.
+	<<strtosfix64>> is also similar, except that it converts
+	to fixed-point sign + 63-bit fraction format.
+
+	The alternate functions <<_strtosfix16_r>>, <<_strtosfix32_r>>,
+	and <<_strtosfix64_r>> are reentrant versions.
+	The extra argument <[reent]> is a pointer to a reentrancy structure.
+
+RETURNS
+	The functions return the converted substring value, if any.  If
+	no conversion can be performed, then 0 is returned.  If the converted
+	value is a NaN, 0 is returned and errno is set to <<EDOM>>.
+	If the converted value exceeds the maximum positive fixed-point value, 
+	the output value is saturated to the maximum value and <<ERANGE>> is stored in 
+	errno.  If the converted value is less than the minimum fixed-point negative
+	value, then the output is saturated to the minimum value  and <<ERANGE>> is stored
+	in errno.  Otherwise, the converted value is returned in the
+	specified fixed-point format.
+
+PORTABILITY
+        <<strtosfix16>>, <<strtosfix32>>, and <<strtosfix64>> are non-standard.
+
+        The OS subroutines of <<strtod>> are required.
+*/
+
+#include <limits.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "vfieeefp.h"
+
+/*
+ * Convert a string to a fixed-point (sign + 15-bits) value.
+ *
+ * Ignores `locale' stuff.
+ */
+__int16_t
+strtosfix16 (const char *nptr, char **endptr)
+{
+  union double_union dbl;
+  unsigned long tmp, tmp2;
+  int exp, negexp, sign;
+  __int16_t result;
+
+  dbl.d = strtod (nptr, endptr);
+
+  /* treat NAN as domain error, +/- infinity as saturation */
+  if (!finite(dbl.d))
+    {
+      if (isnan (dbl.d))
+	{
+	  errno = EDOM;
+	  return 0;
+	}
+      errno = ERANGE;
+      if (word0(dbl) & Sign_bit)
+	return SHRT_MIN;
+      return SHRT_MAX;
+    }
+
+  /* check for normal saturation */
+  if (dbl.d >= 1.0)
+    {
+      errno = ERANGE;
+      return SHRT_MAX;
+    }
+  else if (dbl.d < -1.0)
+    {
+      errno = ERANGE;
+      return SHRT_MIN;
+    }
+
+  /* otherwise we have normal number in range */
+
+  /* strip off sign and exponent */
+  sign = word0(dbl) & Sign_bit;
+  exp = ((word0(dbl) & Exp_mask) >> Exp_shift) - Bias;
+  negexp = -exp;
+  if (negexp > 15)
+    return 0;
+  /* add in implicit normalized bit */
+  tmp = word0(dbl) | Exp_msk1;
+  /* remove exponent and sign */
+  tmp <<= Ebits;
+  if (negexp != 0)
+    {
+      /* perform rounding */
+      tmp2 = tmp + (1 << (negexp - 1));
+      result = (short)(tmp2 >> (negexp + 16));
+      /* check if rounding caused carry bit which must be added into result */
+      if (tmp2 < tmp)
+	result |= (1 << (16 - negexp));
+      /* check if positive saturation has occurred because of rounding */
+      if (!sign && result < 0)
+	{
+	  errno = ERANGE;
+	  return SHRT_MAX;
+	}
+    }
+  else
+    {
+      /* we have -1.0, no rounding necessary */
+      return SHRT_MIN;
+    }
+
+  return  sign ? -result : result;
+}
diff -uNr glibc-2.3.2.orig/spe/strtosfix32.c glibc-2.3.2/spe/strtosfix32.c
--- glibc-2.3.2.orig/spe/strtosfix32.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/strtosfix32.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,83 @@
+#include <limits.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "vfieeefp.h"
+
+/*
+ * Convert a string to a fixed-point (sign + 31-bits) value.
+ *
+ * Ignores `locale' stuff.
+ */
+__int32_t
+strtosfix32 (const char *nptr, char **endptr)
+{
+  union double_union dbl;
+  int exp, negexp, sign;
+  unsigned long tmp, tmp2;
+  long result = 0;
+
+  dbl.d = strtod (nptr, endptr);
+
+  /* treat NAN as domain error, +/- infinity as saturation */
+  if (!finite(dbl.d))
+    {
+      if (isnan (dbl.d))
+	{
+	  errno = EDOM;
+	  return 0;
+	}
+      errno = ERANGE;
+      if (word0(dbl) & Sign_bit)
+	return LONG_MIN;
+      return LONG_MAX;
+    }
+
+  /* check for normal saturation */
+  if (dbl.d >= 1.0)
+    {
+      errno = ERANGE;
+      return LONG_MAX;
+    }
+  else if (dbl.d < -1.0)
+    {
+      errno = ERANGE;
+      return LONG_MIN;
+    }
+
+  /* otherwise we have normal number in range */
+
+  /* strip off sign and exponent */
+  sign = word0(dbl) & Sign_bit;
+  exp = ((word0(dbl) & Exp_mask) >> Exp_shift) - Bias;
+  negexp = -exp;
+  if (negexp > 31)
+    return 0;
+  word0(dbl) &= ~(Exp_mask | Sign_bit);
+  /* add in implicit normalized bit */
+  word0(dbl) |= Exp_msk1;
+  /* shift so result is contained in single word */
+  tmp = word0(dbl) << Ebits;
+  tmp |= ((unsigned long)word1(dbl) >> (32 - Ebits));
+  if (negexp != 0)
+    {
+      /* perform rounding */
+      tmp2 = tmp + (1 << (negexp - 1));
+      result = (long)(tmp2 >> negexp);
+      /* check if rounding caused carry bit which must be added into result */
+      if (tmp2 < tmp)
+	result |= (1 << (32 - negexp));
+      /* check if positive saturation has occurred because of rounding */
+      if (!sign && result < 0)
+	{
+	  errno = ERANGE;
+	  return LONG_MAX;
+	}
+    }
+  else
+    {
+      /* we have -1.0, no rounding necessary */
+      return LONG_MIN;
+    }
+
+  return sign ? -result : result;
+}
diff -uNr glibc-2.3.2.orig/spe/strtosfix64.c glibc-2.3.2/spe/strtosfix64.c
--- glibc-2.3.2.orig/spe/strtosfix64.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/strtosfix64.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,96 @@
+#include <limits.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "fix64.h"
+
+/*
+ * Convert a string to a fixed-point (sign + 63-bits) value.
+ *
+ * Ignores `locale' stuff.
+ */
+__int64_t
+strtosfix64 (const char *nptr, char **endptr)
+{
+  union long_double_union ldbl;
+  int exp, negexp, sign, ld_type;
+  __uint64_t tmp, tmp2;
+  __int64_t result = 0;
+
+  init(ldbl);
+
+  _simdstrtold ((char *)nptr, endptr, &ldbl);
+
+  /* treat NAN as domain error, +/- infinity as saturation */
+  ld_type = _simdldcheck (&ldbl);
+  if (ld_type != 0)
+    {
+      if (ld_type == 1)
+	{
+	  errno = EDOM;
+	  return 0;
+	}
+      errno = ERANGE;
+      if (word0(ldbl) & Sign_bit)
+	return LONG_LONG_MIN;
+      return LONG_LONG_MAX;
+    }
+
+  /* strip off sign and exponent */
+  sign = word0(ldbl) & Sign_bit;
+  exp = ((word0(ldbl) & Exp_mask) >> Exp_shift) - Bias;
+  negexp = -exp;
+  if (negexp > 63)
+    return 0;
+  word0(ldbl) &= ~(Exp_mask | Sign_bit);
+  /* add in implicit normalized bit */
+  word0(ldbl) |= Exp_msk1;
+  /* shift so result is contained in single word */
+  tmp = word0(ldbl) << Ebits;
+  tmp |= ((unsigned long)word1(ldbl) >> (32 - Ebits));
+  tmp <<= 32;
+  if (Ebits < 32)
+    tmp |= ((unsigned long)word1(ldbl) << Ebits);
+  tmp |= ((unsigned long)word2(ldbl) >> (32 - Ebits));
+
+  /* check for saturation */
+  if (sign)
+    {
+      if (exp > 0 || (exp == 0 && tmp != 0x8000000000000000LL))
+	{
+	  errno = ERANGE;
+	  return LONG_LONG_MIN;
+	}
+    }
+  else
+    {
+      if (exp >= 0)
+	{
+	  errno = ERANGE;
+	  return LONG_LONG_MAX;
+	}
+    }
+
+  /* otherwise we have normal number in range */
+  if (negexp != 0)
+    {
+      /* perform rounding */
+      tmp2 = tmp + (1 << (negexp - 1));
+      result = (long long)(tmp2 >> negexp);
+      /* check if rounding caused carry bit which must be added into result */
+      if (tmp2 < tmp)
+	result |= (1 << (64 - negexp));
+      /* check if positive saturation has occurred because of rounding */
+      if (!sign && result < 0)
+	{
+	  errno = ERANGE;
+	  return LONG_LONG_MAX;
+	}
+    }
+  else
+    {
+      /* we have -1.0, no rounding necessary */
+      return LONG_LONG_MIN;
+    }
+
+  return sign ? -result : result;
+}
diff -uNr glibc-2.3.2.orig/spe/strtoufix16.c glibc-2.3.2/spe/strtoufix16.c
--- glibc-2.3.2.orig/spe/strtoufix16.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/strtoufix16.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,180 @@
+/*
+FUNCTION
+        <<strtoufix16>>, <<strtoufix32>>, <<strtoufix64>>---string to signed fixed point
+
+INDEX
+	strtoufix16
+INDEX
+	strtoufix32
+INDEX
+	strtoufix64
+INDEX
+	_strtoufix16_r
+INDEX
+	_strtoufix32_r
+INDEX
+	_strtoufix64_r
+
+ANSI_SYNOPSIS
+	#include <stdlib.h>
+        __uint16_t strtoufix16 (const char *<[s]>, char **<[ptr]>);
+
+        __uint32_t strtoufix32 (const char *<[s]>, char **<[ptr]>);
+
+        __uint64_t strtoufix64 (const char *<[s]>, char **<[ptr]>);
+
+        __uint16_t _strtoufix16_r (void *<[reent]>, 
+                       const char *<[s]>, char **<[ptr]>);
+
+        __uint32_t _strtoufix32_r (void *<[reent]>, 
+                       const char *<[s]>, char **<[ptr]>);
+
+        __uint64_t _strtoufix64_r (void *<[reent]>, 
+                       const char *<[s]>, char **<[ptr]>);
+
+TRAD_SYNOPSIS
+	#include <stdlib.h>
+	__uint16_t strtoufix16 (<[s]>, <[ptr]>)
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__uint32_t strtoufix32 (<[s]>, <[ptr]>)
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__uint64_t strtoufix64 (<[s]>, <[ptr]>)
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__uint16_t _strtoufix16_r (<[reent]>, <[s]>, <[ptr]>)
+	char *<[reent]>;
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__uint32_t _strtoufix32_r (<[reent]>, <[s]>, <[ptr]>)
+	char *<[reent]>;
+        char *<[s]>;
+        char **<[ptr]>;
+
+	__uint64_t _strtoufix64_r (<[reent]>, <[s]>, <[ptr]>)
+	char *<[reent]>;
+        char *<[s]>;
+        char **<[ptr]>;
+
+DESCRIPTION
+        The function <<strtoufix16>> converts the string <<*<[s]>>> to
+	a fixed-point 16-bits fraction representation.  The function 
+	follows the same rules as <<strtod>>.
+
+	The substring converted is the longest initial
+	subsequence of <[s]>, beginning with the first
+	non-whitespace character, that has the format:
+	.[+|-]<[digits]>[.][<[digits]>][(e|E)[+|-]<[digits]>] 
+	The substring contains no characters if <[s]> is empty, consists
+	entirely of whitespace, or if the first non-whitespace
+	character is something other than <<+>>, <<->>, <<.>>, or a
+	digit. If the substring is empty, no conversion is done, and
+	the value of <[s]> is stored in <<*<[ptr]>>>.  Otherwise,
+	the substring is converted, and a pointer to the final string
+	(which will contain at least the terminating null character of
+	<[s]>) is stored in <<*<[ptr]>>>.  If you want no
+	assignment to <<*<[ptr]>>>, pass a null pointer as <[ptr]>.
+
+	<<strtoufix32>> is identical to <<strtoufix16>> except that it 
+	converts to fixed-point 32-bit fraction representation.
+	<<strtoufix64>> is also similar, except that it converts
+	to fixed-point 64-bit fraction.
+
+	The alternate functions <<_strtoufix16_r>>, <<_strtoufix32_r>>,
+	and <<_strtoufix64_r>> are reentrant versions.
+	The extra argument <[reent]> is a pointer to a reentrancy structure.
+
+RETURNS
+	The functions return the converted substring value, if any.  If
+	no conversion can be performed, then 0 is returned.  If the converted
+	value is a NaN, 0 is returned and errno is set to <<EDOM>>.
+	If the converted value exceeds the maximum positive unsigned fixed-point value, 
+	the output value is saturated to the maximum value and <<ERANGE>> is stored in 
+	errno.  If the converted value is less than 0, then the output is saturated to 0
+	and <<ERANGE>> is stored in errno.  Otherwise, the converted value is returned in the
+	specified fixed-point format.
+
+PORTABILITY
+        <<strtoufix16>>, <<strtoufix32>>, and <<strtoufix64>> are non-standard.
+
+        The OS subroutines of <<strtod>> are required.
+*/
+
+#include <limits.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "vfieeefp.h"
+
+/*
+ * Convert a string to a fixed-point 16-bit value.
+ *
+ * Ignores `locale' stuff.
+ */
+__uint16_t
+strtoufix16 (const char *nptr, char **endptr)
+{
+  union double_union dbl;
+  unsigned long tmp, tmp2, result;
+  int exp, negexp;
+
+  dbl.d = strtod (nptr, endptr);
+
+  /* treat NAN as domain error, +/- infinity as saturation */
+  if (!finite(dbl.d))
+    {
+      if (isnan (dbl.d))
+	{
+	  errno = EDOM;
+	  return 0;
+	}
+      errno = ERANGE;
+      if (word0(dbl) & Sign_bit)
+	return 0;
+      return USHRT_MAX;
+    }
+
+  /* check for normal saturation */
+  if (dbl.d >= 1.0)
+    {
+      errno = ERANGE;
+      return USHRT_MAX;
+    }
+  else if (dbl.d < 0)
+    {
+      errno = ERANGE;
+      return 0;
+    }
+
+  /* otherwise we have normal postive number in range */
+
+  /* strip off exponent */
+  exp = ((word0(dbl) & Exp_mask) >> Exp_shift) - Bias;
+  negexp = -exp;
+  if (negexp > 16)
+    return 0;
+  /* add in implicit normalized bit */
+  tmp = word0(dbl) | Exp_msk1;
+  /* remove exponent and sign */
+  tmp <<= Ebits;
+  /* perform rounding */
+  tmp2 = tmp + (1 << (negexp + 14));
+  result = tmp2 >> (negexp + 15);
+  /* if rounding causes carry, must add carry bit in */
+  if (tmp2 < tmp)
+    {
+      if (negexp == 0)
+	{
+	  /* we have overflow which means saturation */
+	  errno = ERANGE;
+	  return USHRT_MAX;
+	}
+      result |= (1 << (16 - negexp));
+    }
+
+  return (__uint16_t)result;
+}
diff -uNr glibc-2.3.2.orig/spe/strtoufix32.c glibc-2.3.2/spe/strtoufix32.c
--- glibc-2.3.2.orig/spe/strtoufix32.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/strtoufix32.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,80 @@
+#include <limits.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "vfieeefp.h"
+
+/*
+ * Convert a string to a fixed-point 32-bit value.
+ *
+ * Ignores `locale' stuff.
+ */
+__uint32_t
+strtoufix32 (const char *nptr, char **endptr)
+{
+  union double_union dbl;
+  int exp, negexp;
+  __uint32_t tmp, tmp2, result = 0;
+
+  dbl.d = strtod (nptr, endptr);
+
+  /* treat NAN as domain error, +/- infinity as saturation */
+  if (!finite(dbl.d))
+    {
+      if (isnan (dbl.d))
+	{
+	  errno = EDOM;
+	  return 0;
+	}
+      errno = ERANGE;
+      if (word0(dbl) & Sign_bit)
+	return 0;
+      return ULONG_MAX;
+    }
+
+  /* check for normal saturation */
+  if (dbl.d >= 1.0)
+    {
+      errno = ERANGE;
+      return ULONG_MAX;
+    }
+  else if (dbl.d < 0)
+    {
+      errno = ERANGE;
+      return 0;
+    }
+
+  /* otherwise we have normal positive number in range */
+
+  /* strip off exponent */
+  exp = ((word0(dbl) & Exp_mask) >> Exp_shift) - Bias;
+  negexp = -exp;
+  if (negexp > 32)
+    return 0;
+  word0(dbl) &= ~(Exp_mask | Sign_bit);
+  /* add in implicit normalized bit */
+  word0(dbl) |= Exp_msk1;
+  /* shift so result is contained left-justified in word */
+  tmp = word0(dbl) << Ebits;
+  tmp |= ((unsigned long)word1(dbl) >> (32 - Ebits));
+  /* perform rounding */
+  if (negexp > 1)
+    {
+      tmp2 = tmp + (1 << (negexp - 2));
+      result = (tmp2 >> (negexp - 1));
+      /* if rounding causes carry, add carry bit in */
+      if (tmp2 < tmp)
+	result += 1 << (32 - negexp);
+    }
+  else
+    {
+      result = tmp + ((word1(dbl) & (1 << (32 - Ebits - 1))) != 0);
+      /* if rounding causes carry, then saturation has occurred */
+      if (result < tmp)
+	{
+	  errno = ERANGE;
+	  return ULONG_MAX;
+	}
+    }
+
+  return result;
+}
diff -uNr glibc-2.3.2.orig/spe/strtoufix64.c glibc-2.3.2/spe/strtoufix64.c
--- glibc-2.3.2.orig/spe/strtoufix64.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/strtoufix64.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,96 @@
+#include <_ansi.h>
+#include <limits.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "fix64.h"
+
+/*
+ * Convert a string to a fixed-point 64-bit unsigned value.
+ *
+ * Ignores `locale' stuff.
+ */
+__uint64_t
+strtoufix64 (const char *nptr, char **endptr)
+{
+  union long_double_union ldbl;
+  int exp, sign, negexp, ld_type;
+  __uint64_t tmp, tmp2, result = 0;
+
+  init(ldbl);
+
+  _simdstrtold ((char *)nptr, endptr, &ldbl);
+
+  /* treat NAN as domain error, +/- infinity as saturation */
+  ld_type = _simdldcheck (&ldbl);
+  if (ld_type != 0)
+    {
+      if (ld_type == 1)
+	{
+	  errno = EDOM;
+	  return 0;
+	}
+      errno = ERANGE;
+      if (word0(ldbl) & Sign_bit)
+	return 0;
+      return ULONG_LONG_MAX;
+    }
+
+  /* strip off sign and exponent */
+  sign = word0(ldbl) & Sign_bit;
+  exp = ((word0(ldbl) & Exp_mask) >> Exp_shift) - Bias;
+  negexp = -exp;
+  if (negexp > 63)
+    return 0;
+  word0(ldbl) &= ~(Exp_mask | Sign_bit);
+  /* add in implicit normalized bit */
+  word0(ldbl) |= Exp_msk1;
+  /* shift so result is contained in single word */
+  tmp = word0(ldbl) << Ebits;
+  tmp |= ((unsigned long)word1(ldbl) >> (32 - Ebits));
+  tmp <<= 32;
+  if (Ebits < 32)
+    tmp |= ((unsigned long)word1(ldbl) << Ebits);
+  tmp |= ((unsigned long)word2(ldbl) >> (32 - Ebits));
+
+  /* check for saturation */
+  if (sign)
+    {
+      errno = ERANGE;
+      return 0;
+    }
+  else
+    {
+      if (exp > 0 || (exp == 0 && tmp >= 0x8000000000000000LL))
+	{
+	  errno = ERANGE;
+	  return ULONG_LONG_MAX;
+	}
+    }
+
+  /* otherwise we have normal number in range */
+  if (negexp > 1)
+    {
+      tmp2 = tmp + (1 << (negexp - 2));
+      result = (tmp2 >> (negexp - 1));
+      /* if rounding causes carry, add carry bit in */
+      if (tmp2 < tmp)
+	result += 1 << (64 - negexp);
+    }
+  else
+    {
+      if (Ebits < 32)
+	{
+	  result = tmp + ((word2(ldbl) & (1 << (64 - Ebits - 1))) != 0);
+	  /* if rounding causes carry, then saturation has occurred */
+	  if (result < tmp)
+	    {
+	      errno = ERANGE;
+	      return ULONG_LONG_MAX;
+	    }
+	}
+      else
+	result = tmp;
+    }
+
+  return result;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/bits/fenv.h glibc-2.3.2/spe/sysdeps/powerpc/bits/fenv.h
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/bits/fenv.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/bits/fenv.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,79 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+
+/* Define bits representing the exception.  We use the bit positions of
+   the appropriate bits in the SPEFSCR...  */
+enum
+  {
+    FE_INEXACT = 1 << (63 - 42),
+#define FE_INEXACT	FE_INEXACT
+    FE_INVALID = 1 << (63 - 43),
+#define FE_INVALID	FE_INVALID
+    FE_DIVBYZERO = 1 << (63 - 44),
+#define FE_DIVBYZERO	FE_DIVBYZERO
+    FE_UNDERFLOW = 1 << (63 - 45),
+#define FE_UNDERFLOW	FE_UNDERFLOW
+    FE_OVERFLOW = 1 << (63 - 46)
+#define FE_OVERFLOW	FE_OVERFLOW
+  };
+
+#define FE_ALL_EXCEPT \
+	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+/* The E500 support all of the four defined rounding modes.  We use
+   the bit pattern in the SPEFSCR as the values for the appropriate
+   macros.  */
+enum
+  {
+    FE_TONEAREST = 0,
+#define FE_TONEAREST	FE_TONEAREST
+    FE_TOWARDZERO = 1,
+#define FE_TOWARDZERO	FE_TOWARDZERO
+    FE_UPWARD = 2,
+#define FE_UPWARD	FE_UPWARD
+    FE_DOWNWARD = 3
+#define FE_DOWNWARD	FE_DOWNWARD
+  };
+
+/* Type representing exception flags.  */
+typedef unsigned int fexcept_t;
+
+typedef double fenv_t;
+
+/* If the default argument is used we use this value.  */
+extern const fenv_t __fe_dfl_env;
+#define FE_DFL_ENV	(&__fe_dfl_env)
+
+#ifdef __USE_GNU
+/* Floating-point environment where all exceptions are enabled.  Note that
+   this is not sufficient to give you SIGFPE.  */
+extern const fenv_t __fe_enabled_env;
+# define FE_ENABLED_ENV	(&__fe_enabled_env)
+
+/* Floating-point environment with all exceptions enabled.  Note that
+   just evaluating this value will set the processor into 'FPU
+   exceptions imprecise recoverable' mode, which may cause a significant
+   performance penalty (but have no other visible effect).  */
+extern const fenv_t *__fe_nomask_env (void);
+# define FE_NOMASK_ENV	(__fe_nomask_env ())
+#endif
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/bits/fenvinline.h glibc-2.3.2/spe/sysdeps/powerpc/fpu/bits/fenvinline.h
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/bits/fenvinline.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/bits/fenvinline.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,2 @@
+/* We don't need no stinking inline versions.  Life is hard enough as it
+   is with this hybrid soft/hard float business.  */
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/bits/mathdef.h glibc-2.3.2/spe/sysdeps/powerpc/fpu/bits/mathdef.h
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/bits/mathdef.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/bits/mathdef.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,81 @@
+/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+
+/* FIXME! This file describes properties of the compiler, not the machine;
+   it should not be part of libc!
+
+   FIXME! This file does not deal with the -fshort-double option of
+   gcc! */
+
+#if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+# ifdef __GNUC__
+#  if __STDC__ == 1
+
+/* In GNU or ANSI mode, gcc leaves `float' expressions as-is.  */
+typedef float float_t;		/* `float' expressions are evaluated as
+				   `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* Signal that types stay as they were declared.  */
+#   define FLT_EVAL_METHOD	0
+
+/* Define `INFINITY' as value of type `float'.  */
+#   define INFINITY	HUGE_VALF
+
+#  else
+
+/* For `gcc -traditional', `float' expressions are evaluated as `double'. */
+typedef double float_t;		/* `float' expressions are evaluated as
+				   `double'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* Define `INFINITY' as value of type `float'.  */
+#   define INFINITY	HUGE_VALF
+
+#  endif
+# else
+
+/* Wild guess at types for float_t and double_t. */
+typedef double float_t;
+typedef double double_t;
+
+/* Define `INFINITY' as value of type `float'.  */
+#  define INFINITY	HUGE_VALF
+
+# endif
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647)
+# define FP_ILOGBNAN	(2147483647)
+
+#endif	/* ISO C99 */
+
+#ifndef __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  The disables the
+   declaration of all the `long double' function variants.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/bits/mathinline.h glibc-2.3.2/spe/sysdeps/powerpc/fpu/bits/mathinline.h
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/bits/mathinline.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/bits/mathinline.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,2 @@
+/* Inline?  You've got to be kidding me.  We'll take the library functions
+   any day.  */
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/Dist glibc-2.3.2/spe/sysdeps/powerpc/fpu/Dist
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/Dist	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/Dist	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,3 @@
+fe_nomask.c
+fenv_const.c
+fenv_libc.h
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fclrexcpt.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fclrexcpt.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fclrexcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fclrexcpt.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,47 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+
+#undef feclearexcept
+int
+__feclearexcept (int excepts)
+{
+  unsigned int fpescr;
+
+  /* Get the current state.  */
+  fpescr = fegetenv_register ();
+
+  /* Clear the relevant bits.  */
+  fpescr &= ~(excepts & FE_ALL_EXCEPT);
+
+  /* Put the new state in effect.  */
+  fesetenv_register (fpescr);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__feclearexcept, __old_feclearexcept)
+compat_symbol (libm, __old_feclearexcept, feclearexcept, GLIBC_2_1);
+#endif
+
+versioned_symbol (libm, __feclearexcept, feclearexcept, GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fedisblxcpt.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fedisblxcpt.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fedisblxcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fedisblxcpt.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,60 @@
+/* Disable floating-point exceptions.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <sysdep.h>
+#include <sys/prctl.h>
+
+int
+fedisableexcept (int excepts)
+{
+  unsigned int result = 0, pflags, r;
+  INTERNAL_SYSCALL_DECL (err);
+
+  pflags = INTERNAL_SYSCALL (prctl, err, 1, PR_GET_FPEXC);
+
+  /* Save old enable bits.  */
+  if (pflags & PR_FP_EXC_OVF) 
+    result |= FE_OVERFLOW;
+  if (pflags & PR_FP_EXC_UND) 
+    result |= FE_UNDERFLOW;
+  if (pflags & PR_FP_EXC_INV) 
+    result |= FE_INVALID;
+  if (pflags & PR_FP_EXC_DIV) 
+    result |= FE_DIVBYZERO;
+  if (pflags & PR_FP_EXC_RES) 
+    result |= FE_INEXACT;
+
+  if (excepts & FE_INEXACT)
+    pflags &=  ~PR_FP_EXC_RES;
+  if (excepts & FE_DIVBYZERO)
+    pflags &= ~PR_FP_EXC_DIV;
+  if (excepts & FE_UNDERFLOW)
+    pflags &= ~PR_FP_EXC_UND;
+  if (excepts & FE_OVERFLOW)
+    pflags &= ~PR_FP_EXC_OVF;
+  if (excepts & FE_INVALID)
+    pflags &= ~PR_FP_EXC_INV;
+  r = INTERNAL_SYSCALL (prctl, err, 2, PR_SET_FPEXC, pflags);
+  if (INTERNAL_SYSCALL_ERROR_P (r, err))
+    return -1;
+
+  return result;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/feenablxcpt.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/feenablxcpt.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/feenablxcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/feenablxcpt.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,60 @@
+/* Enable floating-point exceptions.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <sysdep.h>
+#include <sys/prctl.h>
+
+int
+feenableexcept (int excepts)
+{
+  unsigned int result = 0, pflags, r;
+  INTERNAL_SYSCALL_DECL (err);
+
+  pflags = INTERNAL_SYSCALL (prctl, err, 1, PR_GET_FPEXC);
+
+  /* Save old enable bits.  */
+  if (pflags & PR_FP_EXC_OVF) 
+    result |= FE_OVERFLOW;
+  if (pflags & PR_FP_EXC_UND) 
+    result |= FE_UNDERFLOW;
+  if (pflags & PR_FP_EXC_INV) 
+    result |= FE_INVALID;
+  if (pflags & PR_FP_EXC_DIV) 
+    result |= FE_DIVBYZERO;
+  if (pflags & PR_FP_EXC_RES) 
+    result |= FE_INEXACT;
+
+  if (excepts & FE_INEXACT)
+    pflags |= PR_FP_EXC_RES;
+  if (excepts & FE_DIVBYZERO)
+    pflags |= PR_FP_EXC_DIV;
+  if (excepts & FE_UNDERFLOW)
+    pflags |= PR_FP_EXC_UND;
+  if (excepts & FE_OVERFLOW)
+    pflags |= PR_FP_EXC_OVF;
+  if (excepts & FE_INVALID)
+    pflags |= PR_FP_EXC_INV;
+  r = INTERNAL_SYSCALL (prctl, err, 2, PR_SET_FPEXC, pflags);
+  if (INTERNAL_SYSCALL_ERROR_P (r, err))
+    return -1;
+
+  return result;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fegetenv.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fegetenv.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fegetenv.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fegetenv.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,47 @@
+/* Store current floating-point environment.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <bp-sym.h>
+#include <sysdep.h>
+#include <sys/prctl.h>
+
+int
+__fegetenv (fenv_t *envp)
+{
+  fenv_union_t u;
+  INTERNAL_SYSCALL_DECL (err);
+
+
+  u.l[0] = INTERNAL_SYSCALL (prctl, err, 1, PR_GET_FPEXC);
+  u.l[1] = fegetenv_register ();
+  *envp = u.fenv;
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__fegetenv, __old_fegetenv)
+compat_symbol (libm, BP_SYM (__old_fegetenv), BP_SYM (fegetenv), GLIBC_2_1);
+#endif
+
+versioned_symbol (libm, BP_SYM (__fegetenv), BP_SYM (fegetenv), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fegetexcept.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fegetexcept.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fegetexcept.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fegetexcept.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,31 @@
+/* Get floating-point exceptions.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+
+int
+fegetexcept (void)
+{
+  unsigned long fpescr;
+
+  fpescr = fegetenv_register ();
+
+  return fpescr & FE_ALL_EXCEPT;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fegetround.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fegetround.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fegetround.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fegetround.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,31 @@
+/* Return current rounding direction.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+
+#undef fegetround
+int
+fegetround (void)
+{
+  unsigned long fpescr;
+
+  fpescr = fegetenv_register ();
+  return fpescr & 3;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/feholdexcpt.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/feholdexcpt.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/feholdexcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/feholdexcpt.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,44 @@
+/* Store current floating-point environment and clear exceptions.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <sysdep.h>
+#include <sys/prctl.h>
+
+int
+feholdexcept (fenv_t *envp)
+{
+  fenv_union_t u;
+  INTERNAL_SYSCALL_DECL (err);
+
+
+  /* Get the current state.  */
+  u.l[0] = INTERNAL_SYSCALL (prctl, err, 1, PR_GET_FPEXC);
+  u.l[1] = fegetenv_register ();
+  *envp = u.fenv;
+
+  /* Clear everything except for the rounding mode.  */
+  u.l[1] &= 3;
+
+  /* Put the new state in effect.  */
+  fesetenv_register (u.l[1]);
+
+  return 0;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fe_nomask.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fe_nomask.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fe_nomask.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fe_nomask.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,32 @@
+/* Procedure definition for FE_NOMASK_ENV.
+   Copyright (C) 1997 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <errno.h>
+
+/* This is presently a stub, until it's decided how the kernels should
+   support this.  */
+
+const fenv_t *
+__fe_nomask_env(void)
+{
+  __set_errno (ENOSYS);
+  return FE_ENABLED_ENV;
+}
+stub_warning (__fe_nomask_env)
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fenv_const.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fenv_const.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fenv_const.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fenv_const.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,27 @@
+/* Constants for fenv_bits.h.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* If the default argument is used we use this value.  */
+const unsigned long long __fe_dfl_env __attribute__ ((aligned (8))) =
+0x0ULL;
+
+/* Floating-point environment where none of the exceptions are masked.  */
+const unsigned long long __fe_enabled_env __attribute__ ((aligned (8))) =
+0xF00000000ULL;
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fenv_libc.h glibc-2.3.2/spe/sysdeps/powerpc/fpu/fenv_libc.h
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fenv_libc.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fenv_libc.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,77 @@
+/* Internal libc stuff for floating point environment routines.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FENV_LIBC_H
+#define _FENV_LIBC_H	1
+
+#include <fenv.h>
+
+extern int __feraiseexcept_internal (int __excepts);
+
+/* Equivalent to fegetenv, but returns a fenv_t instead of taking a
+   pointer.  */
+#define fegetenv_register() \
+        ({ unsigned fscr; asm volatile ("mfspefscr %0" : "=r" (fscr)); fscr; })
+
+/* Equivalent to fesetenv, but takes a fenv_t instead of a pointer.  */
+#define fesetenv_register(fscr) \
+	({ asm volatile ("mtspefscr %0" : : "r" (fscr)); })
+
+typedef union
+{
+  fenv_t fenv;
+  unsigned int l[2];
+} fenv_union_t;
+
+/* Definitions of all the SPEFSCR bit numbers.  */
+enum {
+  SPEFSCR_SOVH          = 0x80000000,
+  SPEFSCR_OVH           = 0x40000000,
+  SPEFSCR_FGH           = 0x20000000,
+  SPEFSCR_FXH           = 0x10000000,
+  SPEFSCR_FINVH         = 0x08000000,
+  SPEFSCR_FDBZH         = 0x04000000,
+  SPEFSCR_FUNFH         = 0x02000000,
+  SPEFSCR_FOVFH         = 0x01000000,
+  /* 2 unused bits.  */
+  SPEFSCR_FINXS         = 0x00200000,
+  SPEFSCR_FINVS         = 0x00100000,
+  SPEFSCR_FDBZS         = 0x00080000,
+  SPEFSCR_FUNFS         = 0x00040000,
+  SPEFSCR_FOVFS         = 0x00020000,
+  SPEFSCR_MODE          = 0x00010000,
+  SPEFSCR_SOV           = 0x00008000,
+  SPEFSCR_OV            = 0x00004000,
+  SPEFSCR_FG            = 0x00002000,
+  SPEFSCR_FX            = 0x00001000,
+  SPEFSCR_FINV          = 0x00000800,
+  SPEFSCR_FDBZ          = 0x00000400,
+  SPEFSCR_FUNF          = 0x00000200,
+  SPEFSCR_FOVF          = 0x00000100,
+  /* 1 unused bit.  */
+  SPEFSCR_FINXE         = 0x00000040,
+  SPEFSCR_FINVE         = 0x00000020,
+  SPEFSCR_FDBZE         = 0x00000010,
+  SPEFSCR_FUNFE         = 0x00000008,
+  SPEFSCR_FOVFE         = 0x00000004,
+  SPEFSCR_FRMC          = 0x00000003
+};
+
+#endif /* fenv_libc.h */
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fesetenv.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fesetenv.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fesetenv.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fesetenv.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,46 @@
+/* Install given floating-point environment.
+   Copyright (C) 1997,99,2000,01,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <bp-sym.h>
+#include <sysdep.h>
+#include <sys/prctl.h>
+
+int
+__fesetenv (const fenv_t *envp)
+{
+  fenv_union_t u;
+  INTERNAL_SYSCALL_DECL (err);
+
+  u.fenv = *envp;
+  INTERNAL_SYSCALL (prctl, err, 2, PR_SET_FPEXC, u.l[0]);
+  fesetenv_register (u.l[1]);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__fesetenv, __old_fesetenv)
+compat_symbol (libm, BP_SYM (__old_fesetenv), BP_SYM (fesetenv), GLIBC_2_1);
+#endif
+
+libm_hidden_ver (__fesetenv, fesetenv)
+versioned_symbol (libm, BP_SYM (__fesetenv), BP_SYM (fesetenv), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fesetround.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fesetround.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fesetround.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fesetround.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,36 @@
+/* Set current rounding direction.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+
+int
+fesetround (int round)
+{
+  unsigned long fpescr;
+
+  if ((unsigned int) round > 3)
+    return 1;
+
+  fpescr = fegetenv_register ();
+  fpescr = (fpescr & ~SPEFSCR_FRMC) | (round & 3);
+  fesetenv_register (fpescr);
+
+  return 0;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/feupdateenv.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/feupdateenv.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/feupdateenv.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/feupdateenv.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,57 @@
+/* Install given floating-point environment and raise exceptions.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <bp-sym.h>
+#include <sysdep.h>
+#include <sys/prctl.h>
+
+int
+__feupdateenv (const fenv_t *envp)
+{
+  unsigned long fpescr, old, new, pflags;
+  fenv_union_t u;
+  INTERNAL_SYSCALL_DECL (err);
+
+  /* Save the currently set exceptions.  */
+  u.fenv = *envp;
+  new = u.l[1];
+  old = fegetenv_register ();
+  new |= (old & FE_ALL_EXCEPT);
+
+  pflags = INTERNAL_SYSCALL (prctl, err, 1, PR_GET_FPEXC);
+  pflags |= u.l[0];
+  INTERNAL_SYSCALL (prctl, err, 2, PR_SET_FPEXC, pflags);
+
+  /* Enable and raise (if appropriate) exceptions set in `new'. */
+  fesetenv_register (new);
+  feraiseexcept (new & FE_ALL_EXCEPT);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__feupdateenv, __old_feupdateenv)
+compat_symbol (libm, BP_SYM (__old_feupdateenv), BP_SYM (feupdateenv), GLIBC_2_1);
+#endif
+
+versioned_symbol (libm, BP_SYM (__feupdateenv), BP_SYM (feupdateenv), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fgetexcptflg.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fgetexcptflg.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fgetexcptflg.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fgetexcptflg.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,47 @@
+/* Store current representation for exceptions.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <bp-sym.h>
+
+int
+__fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  unsigned long fpescr;
+
+  /* Get the current state.  */
+  fpescr = fegetenv_register ();
+
+  /* ?? Classic PPC doesn't do anything with `excepts', so we'll do
+     the same here.  (We should really be ignoring exceptions in
+     excepts) ??  */
+  *flagp = fpescr & FE_ALL_EXCEPT;
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__fegetexceptflag, __old_fegetexceptflag)
+compat_symbol (libm, BP_SYM (__old_fegetexceptflag), BP_SYM (fegetexceptflag), GLIBC_2_1);
+#endif
+
+versioned_symbol (libm, BP_SYM (__fegetexceptflag), BP_SYM (fegetexceptflag), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fpu_control.h glibc-2.3.2/spe/sysdeps/powerpc/fpu/fpu_control.h
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fpu_control.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fpu_control.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,62 @@
+/* FPU control word definitions.  E500 version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x00   /* RECOMMENDED */
+#define _FPU_RC_DOWN    0x03
+#define _FPU_RC_UP      0x02
+#define _FPU_RC_ZERO    0x01
+
+/* masking of interrupts */
+#define _FPU_MASK_ZM  0x10 /* zero divide */
+#define _FPU_MASK_OM  0x40 /* overflow */
+#define _FPU_MASK_UM  0x80 /* underflow */
+#define _FPU_MASK_XM  0x40 /* inexact */
+#define _FPU_MASK_IM  0x20 /* invalid operation */
+
+#define _FPU_RESERVED 0xff3fff7f /* These bits are reserved are not changed. */
+
+/* The fdlibm code requires no interrupts for exceptions.  */
+#define _FPU_DEFAULT  0x00000000 /* Default value.  */
+
+/* IEEE:  same as above, but (some) exceptions;
+   we leave the 'inexact' exception off.
+ */
+#define _FPU_IEEE     0x000003c0
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t;
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(__cw) ({ \
+  unsigned int env; \
+  asm volatile ("mfspefscr %0" : "=r" (env)); \
+  (__cw) = env; })
+#define _FPU_SETCW(__cw) ({ \
+  unsigned int env = __cw; \
+  asm volatile ("mtspefscr %0" : : "r" (env)); })
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#endif /* _FPU_CONTROL_H */
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fraiseexcpt.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fraiseexcpt.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fraiseexcpt.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fraiseexcpt.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,27 @@
+/* Raise given exceptions.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <bp-sym.h>
+
+#undef feraiseexcept
+
+#define __FERAISEEXCEPT_INTERNAL feraiseexcept
+#include "../raise.c"
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fsetexcptflg.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/fsetexcptflg.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/fsetexcptflg.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/fsetexcptflg.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,54 @@
+/* Set floating-point environment exception handling.
+   Copyright (C) 1997,99,2000,01,04 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <bp-sym.h>
+
+int
+__fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  unsigned long spefscr;
+  fexcept_t flag;
+
+  /* Get the current state.  */
+  spefscr = fegetenv_register ();
+
+  /* Ignore exceptions not listed in 'excepts'.  */
+  flag = *flagp & excepts;
+
+  /* Replace the exception status */
+  spefscr = (spefscr & ~FE_ALL_EXCEPT) | flag;
+
+  /* Store the new status word (along with the rest of the environment).
+     This may cause floating-point exceptions if the restored state
+     requests it.  */
+  fesetenv_register (spefscr);
+  feraiseexcept (spefscr & FE_ALL_EXCEPT);
+
+  /* Success.  */
+  return 0;
+}
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
+strong_alias (__fesetexceptflag, __old_fesetexceptflag)
+compat_symbol (libm, BP_SYM (__old_fesetexceptflag), BP_SYM (fesetexceptflag), GLIBC_2_1);
+#endif
+
+versioned_symbol (libm, BP_SYM (__fesetexceptflag), BP_SYM (fesetexceptflag), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/ftestexcept.c glibc-2.3.2/spe/sysdeps/powerpc/fpu/ftestexcept.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/ftestexcept.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/ftestexcept.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,32 @@
+/* Test exception in current environment.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+
+int
+fetestexcept (int excepts)
+{
+  unsigned long f;
+
+  /* Get the current state.  */
+  f = fegetenv_register ();
+
+  return f & excepts;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/libm-test-ulps glibc-2.3.2/spe/sysdeps/powerpc/fpu/libm-test-ulps
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/libm-test-ulps	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/libm-test-ulps	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,866 @@
+# Begin of automatic generation
+
+# atan2
+Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
+float: 3
+ifloat: 3
+Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
+float: 3
+ifloat: 3
+Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
+float: 1
+ifloat: 1
+
+# atanh
+Test "atanh (0.75) == 0.972955074527656652552676371721589865":
+float: 1
+ifloat: 1
+
+# cacosh
+Test "Real part of: cacosh (-2 - 3 i) == -1.9833870299165354323470769028940395 + 2.1414491111159960199416055713254211 i":
+double: 1
+float: 7
+idouble: 1
+ifloat: 7
+Test "Imaginary part of: cacosh (-2 - 3 i) == -1.9833870299165354323470769028940395 + 2.1414491111159960199416055713254211 i":
+double: 1
+float: 3
+idouble: 1
+ifloat: 3
+
+# casin
+Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# casinh
+Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# catan
+Test "Real part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+float: 3
+ifloat: 3
+Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Real part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
+float: 4
+ifloat: 4
+
+# catanh
+Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+double: 4
+idouble: 4
+Test "Imaginary part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
+float: 4
+ifloat: 4
+Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
+float: 6
+ifloat: 6
+
+# cbrt
+Test "cbrt (-27.0) == -3.0":
+double: 1
+idouble: 1
+Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
+double: 1
+idouble: 1
+
+# ccos
+Test "Imaginary part of: ccos (-2 - 3 i) == -4.1896256909688072301 - 9.1092278937553365979 i":
+float: 1
+ifloat: 1
+Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
+float: 1
+ifloat: 1
+
+# ccosh
+Test "Real part of: ccosh (-2 - 3 i) == -3.7245455049153225654 + 0.5118225699873846088 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (-2 - 3 i) == -3.7245455049153225654 + 0.5118225699873846088 i":
+float: 1
+ifloat: 1
+Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
+float: 1
+ifloat: 1
+
+# cexp
+Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
+float: 1
+ifloat: 1
+Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
+float: 1
+ifloat: 1
+
+# clog
+Test "Imaginary part of: clog (-2 - 3 i) == 1.2824746787307683680267437207826593 - 2.1587989303424641704769327722648368 i":
+float: 3
+ifloat: 3
+Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
+float: 1
+ifloat: 1
+
+# clog10
+Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-2 - 3 i) == 0.5569716761534183846 - 0.9375544629863747085 i":
+double: 1
+float: 5
+idouble: 1
+ifloat: 5
+Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
+float: 1
+ifloat: 1
+
+# cos
+Test "cos (M_PI_6l * 2.0) == 0.5":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "cos (M_PI_6l * 4.0) == -0.5":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "cos (pi/2) == 0":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# cpow
+Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
+float: 1
+ifloat: 1
+Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
+double: 2
+float: 3
+idouble: 2
+ifloat: 3
+Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+double: 1
+float: 4
+idouble: 1
+ifloat: 4
+Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
+float: 2
+ifloat: 2
+Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+# csinh
+Test "Imaginary part of: csinh (-2 - 3 i) == 3.5905645899857799520 - 0.5309210862485198052 i":
+double: 1
+idouble: 1
+Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
+float: 1
+ifloat: 1
+
+# csqrt
+Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
+float: 1
+ifloat: 1
+
+# ctan
+Test "Real part of: ctan (-2 - 3 i) == 0.0037640256415042482 - 1.0032386273536098014 i":
+double: 1
+idouble: 1
+Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
+double: 1
+idouble: 1
+
+# ctanh
+Test "Real part of: ctanh (-2 - 3 i) == -0.9653858790221331242 + 0.0098843750383224937 i":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
+float: 1
+ifloat: 1
+Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
+double: 1
+idouble: 1
+
+# erf
+Test "erf (1.25) == 0.922900128256458230136523481197281140":
+double: 1
+idouble: 1
+
+# erfc
+Test "erfc (0.75) == 0.288844366346484868401062165408589223":
+float: 1
+ifloat: 1
+Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
+double: 1
+idouble: 1
+Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
+double: 1
+idouble: 1
+
+# exp10
+Test "exp10 (-1) == 0.1":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "exp10 (3) == 1000":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+
+# expm1
+Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
+double: 1
+idouble: 1
+Test "expm1 (1) == M_El - 1.0":
+float: 1
+ifloat: 1
+
+# hypot
+Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
+float: 1
+ifloat: 1
+
+# j0
+Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "j0 (8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+
+# j1
+Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+Test "j1 (2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "j1 (8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+
+# jn
+Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
+float: 1
+ifloat: 1
+Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
+float: 2
+ifloat: 2
+Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
+double: 1
+idouble: 1
+Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
+double: 1
+idouble: 1
+Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
+float: 1
+ifloat: 1
+Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
+float: 3
+ifloat: 3
+Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
+double: 1
+idouble: 1
+Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# lgamma
+Test "lgamma (0.7) == 0.26086724653166651439":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "lgamma (1.2) == -0.853740900033158497197e-1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# log10
+Test "log10 (0.75) == -0.124938736608299953132449886193870744":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "log10 (e) == log10(e)":
+float: 1
+ifloat: 1
+
+# log1p
+Test "log1p (-0.25) == -0.287682072451780927439219005993827432":
+float: 1
+ifloat: 1
+
+# sincos
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (pi/2, &sin_res, &cos_res) puts 0 in cos_res":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
+float: 1
+ifloat: 1
+
+# tan
+Test "tan (pi/4) == 1":
+double: 1
+idouble: 1
+
+# tgamma
+Test "tgamma (-0.5) == -2 sqrt (pi)":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "tgamma (0.5) == sqrt (pi)":
+float: 1
+ifloat: 1
+Test "tgamma (0.7) == 1.29805533264755778568":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# y0
+Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "y0 (2.0) == 0.510375672649745119596606592727157873":
+double: 1
+idouble: 1
+Test "y0 (8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+# y1
+Test "y1 (10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "y1 (2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "y1 (8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+# yn
+Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (0, 2.0) == 0.510375672649745119596606592727157873":
+double: 1
+idouble: 1
+Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
+float: 2
+ifloat: 2
+Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
+double: 2
+idouble: 2
+Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
+double: 3
+float: 1
+idouble: 3
+ifloat: 1
+Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
+float: 1
+ifloat: 1
+Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
+double: 1
+idouble: 1
+
+# Maximal error of functions:
+Function: "atan2":
+float: 3
+ifloat: 3
+
+Function: "atanh":
+float: 1
+ifloat: 1
+
+Function: Real part of "cacosh":
+double: 1
+float: 7
+idouble: 1
+ifloat: 7
+
+Function: Imaginary part of "cacosh":
+double: 1
+float: 3
+idouble: 1
+ifloat: 3
+
+Function: Real part of "casin":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "casinh":
+double: 5
+float: 1
+idouble: 5
+ifloat: 1
+
+Function: Imaginary part of "casinh":
+double: 3
+float: 6
+idouble: 3
+ifloat: 6
+
+Function: Real part of "catan":
+float: 4
+ifloat: 4
+
+Function: Imaginary part of "catan":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "catanh":
+double: 4
+idouble: 4
+
+Function: Imaginary part of "catanh":
+float: 6
+ifloat: 6
+
+Function: "cbrt":
+double: 1
+idouble: 1
+
+Function: Real part of "ccos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "ccos":
+float: 1
+ifloat: 1
+
+Function: Real part of "ccosh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Imaginary part of "ccosh":
+float: 1
+ifloat: 1
+
+Function: Real part of "cexp":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "cexp":
+float: 1
+ifloat: 1
+
+Function: Real part of "clog":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "clog":
+float: 3
+ifloat: 3
+
+Function: Real part of "clog10":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "clog10":
+double: 1
+float: 5
+idouble: 1
+ifloat: 5
+
+Function: "cos":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
+Function: Real part of "cpow":
+double: 2
+float: 4
+idouble: 2
+ifloat: 4
+
+Function: Imaginary part of "cpow":
+double: 2
+float: 2
+idouble: 2
+ifloat: 2
+
+Function: Real part of "csinh":
+float: 1
+ifloat: 1
+
+Function: Imaginary part of "csinh":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: Real part of "csqrt":
+float: 1
+ifloat: 1
+
+Function: Real part of "ctan":
+double: 1
+idouble: 1
+
+Function: Imaginary part of "ctan":
+double: 1
+idouble: 1
+
+Function: Real part of "ctanh":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: Imaginary part of "ctanh":
+float: 1
+ifloat: 1
+
+Function: "erf":
+double: 1
+idouble: 1
+
+Function: "erfc":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "exp10":
+double: 6
+float: 2
+idouble: 6
+ifloat: 2
+
+Function: "expm1":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "hypot":
+float: 1
+ifloat: 1
+
+Function: "j0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
+Function: "j1":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "jn":
+double: 3
+float: 3
+idouble: 3
+ifloat: 3
+
+Function: "lgamma":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "log10":
+double: 1
+float: 2
+idouble: 1
+ifloat: 2
+
+Function: "log1p":
+float: 1
+ifloat: 1
+
+Function: "sincos":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "tan":
+double: 1
+idouble: 1
+
+Function: "tgamma":
+double: 1
+float: 1
+idouble: 1
+ifloat: 1
+
+Function: "y0":
+double: 2
+float: 1
+idouble: 2
+ifloat: 1
+
+Function: "y1":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+Function: "yn":
+double: 3
+float: 2
+idouble: 3
+ifloat: 2
+
+# end of automatic generation
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/Makefile glibc-2.3.2/spe/sysdeps/powerpc/fpu/Makefile
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/Makefile	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,5 @@
+ifeq ($(subdir),math)
+#cflags += -Wa,-me500
+#asm-CPPFLAGS += -Wa,-me500
+libm-support += fenv_const fe_nomask
+endif
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/s_fabsf.S glibc-2.3.2/spe/sysdeps/powerpc/fpu/s_fabsf.S
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/fpu/s_fabsf.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/fpu/s_fabsf.S	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,29 @@
+/* Floating-point absolute value.  PowerPC E500 version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+ENTRY(__fabsf)
+/* float [r3] fabsf (double [r3] x) ;  */
+	efsabs r3,r3
+	blr
+END(__fabsf)
+
+weak_alias(__fabsf,fabsf)
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/powerpc32/fpu/__longjmp.S glibc-2.3.2/spe/sysdeps/powerpc/powerpc32/fpu/__longjmp.S
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/powerpc32/fpu/__longjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/powerpc32/fpu/__longjmp.S	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,91 @@
+/* longjmp for PowerPC E500.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+#include <bp-sym.h>
+#include <bp-asm.h>
+
+ENTRY (BP_SYM (__longjmp))
+	CHECK_BOUNDS_BOTH_WIDE_LIT (r3, r8, r9, JB_SIZE)
+
+	lwz r1,(JB_GPR1*4)(r3)
+	lwz r0,(JB_LR*4)(r3)
+	/*lfd fp14,((JB_FPRS+0*2)*4)(r3)*/
+	evldd r14,((JB_FPRS+0*2)*4)(r3)
+	lwz r14,((JB_GPRS+0)*4)(r3)
+	/*lfd fp15,((JB_FPRS+1*2)*4)(r3)*/
+	evldd r15,((JB_FPRS+1*2)*4)(r3)
+	lwz r15,((JB_GPRS+1)*4)(r3)
+	/*lfd fp16,((JB_FPRS+2*2)*4)(r3)*/
+	evldd r16,((JB_FPRS+2*2)*4)(r3)
+	lwz r16,((JB_GPRS+2)*4)(r3)
+	/*lfd fp17,((JB_FPRS+3*2)*4)(r3)*/
+	evldd r17,((JB_FPRS+3*2)*4)(r3)
+	lwz r17,((JB_GPRS+3)*4)(r3)
+	/*lfd fp18,((JB_FPRS+4*2)*4)(r3)*/
+	evldd r18,((JB_FPRS+4*2)*4)(r3)
+	lwz r18,((JB_GPRS+4)*4)(r3)
+	/*lfd fp19,((JB_FPRS+5*2)*4)(r3)*/
+	evldd r19,((JB_FPRS+5*2)*4)(r3)
+	lwz r19,((JB_GPRS+5)*4)(r3)
+	/*lfd fp20,((JB_FPRS+6*2)*4)(r3)*/
+	evldd r20,((JB_FPRS+6*2)*4)(r3)
+	lwz r20,((JB_GPRS+6)*4)(r3)
+	mtlr r0
+	/*lfd fp21,((JB_FPRS+7*2)*4)(r3)*/
+	evldd r21,((JB_FPRS+7*2)*4)(r3)
+	lwz r21,((JB_GPRS+7)*4)(r3)
+	/*lfd fp22,((JB_FPRS+8*2)*4)(r3)*/
+	evldd r22,((JB_FPRS+8*2)*4)(r3)
+	lwz r22,((JB_GPRS+8)*4)(r3)
+	lwz r0,(JB_CR*4)(r3)
+	/*lfd fp23,((JB_FPRS+9*2)*4)(r3)*/
+	evldd r23,((JB_FPRS+9*2)*4)(r3)
+	lwz r23,((JB_GPRS+9)*4)(r3)
+	/*lfd fp24,((JB_FPRS+10*2)*4)(r3)*/
+	evldd r24,((JB_FPRS+10*2)*4)(r3)
+	lwz r24,((JB_GPRS+10)*4)(r3)
+	/*lfd fp25,((JB_FPRS+11*2)*4)(r3)*/
+	evldd r25,((JB_FPRS+11*2)*4)(r3)
+	lwz r25,((JB_GPRS+11)*4)(r3)
+	mtcrf 0xFF,r0
+	/*lfd fp26,((JB_FPRS+12*2)*4)(r3)*/
+	evldd r26,((JB_FPRS+12*2)*4)(r3)
+	lwz r26,((JB_GPRS+12)*4)(r3)
+	/*lfd fp27,((JB_FPRS+13*2)*4)(r3)*/
+	evldd r27,((JB_FPRS+13*2)*4)(r3)
+	lwz r27,((JB_GPRS+13)*4)(r3)
+	/*lfd fp28,((JB_FPRS+14*2)*4)(r3)*/
+	evldd r28,((JB_FPRS+14*2)*4)(r3)
+	lwz r28,((JB_GPRS+14)*4)(r3)
+	/*lfd fp29,((JB_FPRS+15*2)*4)(r3)*/
+	evldd r29,((JB_FPRS+15*2)*4)(r3)
+	lwz r29,((JB_GPRS+15)*4)(r3)
+	/*lfd fp30,((JB_FPRS+16*2)*4)(r3)*/
+	evldd r30,((JB_FPRS+16*2)*4)(r3)
+	lwz r30,((JB_GPRS+16)*4)(r3)
+	/*lfd fp31,((JB_FPRS+17*2)*4)(r3)*/
+	evldd r31,((JB_FPRS+17*2)*4)(r3)
+	lwz r31,((JB_GPRS+17)*4)(r3)
+	mr r3,r4
+	blr
+END (BP_SYM (__longjmp))
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/powerpc32/fpu/setjmp.S glibc-2.3.2/spe/sysdeps/powerpc/powerpc32/fpu/setjmp.S
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/powerpc32/fpu/setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/powerpc32/fpu/setjmp.S	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,90 @@
+/* setjmp for PowerPC E500.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+#include <bp-sym.h>
+#include <bp-asm.h>
+
+ENTRY (BP_SYM (__sigsetjmp))
+	CHECK_BOUNDS_BOTH_WIDE_LIT (r3, r8, r9, JB_SIZE)
+
+	stw  r1,(JB_GPR1*4)(3)
+	mflr r0
+	stw  r14,((JB_GPRS+0)*4)(3)
+	/*stfd fp14,((JB_FPRS+0*2)*4)(3)*/
+	evstdd r14,((JB_FPRS+0*2)*4)(3)
+	stw  r0,(JB_LR*4)(3)
+	stw  r15,((JB_GPRS+1)*4)(3)
+	/*stfd fp15,((JB_FPRS+1*2)*4)(3)*/
+	evstdd r15,((JB_FPRS+1*2)*4)(3)
+	mfcr r0
+	stw  r16,((JB_GPRS+2)*4)(3)
+	/*stfd fp16,((JB_FPRS+2*2)*4)(3)*/
+	evstdd r16,((JB_FPRS+2*2)*4)(3)
+	stw  r0,(JB_CR*4)(3)
+	stw  r17,((JB_GPRS+3)*4)(3)
+	/*stfd fp17,((JB_FPRS+3*2)*4)(3)*/
+	evstdd r17,((JB_FPRS+3*2)*4)(3)
+	stw  r18,((JB_GPRS+4)*4)(3)
+	/*stfd fp18,((JB_FPRS+4*2)*4)(3)*/
+	evstdd r18,((JB_FPRS+4*2)*4)(3)
+	stw  r19,((JB_GPRS+5)*4)(3)
+	/*stfd fp19,((JB_FPRS+5*2)*4)(3)*/
+	evstdd r19,((JB_FPRS+5*2)*4)(3)
+	stw  r20,((JB_GPRS+6)*4)(3)
+	/*stfd fp20,((JB_FPRS+6*2)*4)(3)*/
+	evstdd r20,((JB_FPRS+6*2)*4)(3)
+	stw  r21,((JB_GPRS+7)*4)(3)
+	/*stfd fp21,((JB_FPRS+7*2)*4)(3)*/
+	evstdd r21,((JB_FPRS+7*2)*4)(3)
+	stw  r22,((JB_GPRS+8)*4)(3)
+	/*stfd fp22,((JB_FPRS+8*2)*4)(3)*/
+	evstdd r22,((JB_FPRS+8*2)*4)(3)
+	stw  r23,((JB_GPRS+9)*4)(3)
+	/*stfd fp23,((JB_FPRS+9*2)*4)(3)*/
+	evstdd r23,((JB_FPRS+9*2)*4)(3)
+	stw  r24,((JB_GPRS+10)*4)(3)
+	/*stfd fp24,((JB_FPRS+10*2)*4)(3)*/
+	evstdd r24,((JB_FPRS+10*2)*4)(3)
+	stw  r25,((JB_GPRS+11)*4)(3)
+	/*stfd fp25,((JB_FPRS+11*2)*4)(3)*/
+	evstdd r25,((JB_FPRS+11*2)*4)(3)
+	stw  r26,((JB_GPRS+12)*4)(3)
+	/*stfd fp26,((JB_FPRS+12*2)*4)(3)*/
+	evstdd r26,((JB_FPRS+12*2)*4)(3)
+	stw  r27,((JB_GPRS+13)*4)(3)
+	/*stfd fp27,((JB_FPRS+13*2)*4)(3)*/
+	evstdd r27,((JB_FPRS+13*2)*4)(3)
+	stw  r28,((JB_GPRS+14)*4)(3)
+	/*stfd fp28,((JB_FPRS+14*2)*4)(3)*/
+	evstdd r28,((JB_FPRS+14*2)*4)(3)
+	stw  r29,((JB_GPRS+15)*4)(3)
+	/*stfd fp29,((JB_FPRS+15*2)*4)(3)*/
+	evstdd r29,((JB_FPRS+15*2)*4)(3)
+	stw  r30,((JB_GPRS+16)*4)(3)
+	/*stfd fp30,((JB_FPRS+16*2)*4)(3)*/
+	evstdd r30,((JB_FPRS+16*2)*4)(3)
+	stw  r31,((JB_GPRS+17)*4)(3)
+	/*stfd fp31,((JB_FPRS+17*2)*4)(3)*/
+	evstdd r31,((JB_FPRS+17*2)*4)(3)
+	b JUMPTARGET (BP_SYM (__sigjmp_save))
+END (BP_SYM (__sigsetjmp))
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/raise.c glibc-2.3.2/spe/sysdeps/powerpc/raise.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/raise.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/raise.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,68 @@
+/* Raise given exceptions.
+   Copyright (C) 1997,99,2000,01,02,04 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <bp-sym.h>
+
+int
+__FERAISEEXCEPT_INTERNAL (int excepts)
+{
+  unsigned long f;
+
+  f = fegetenv_register ();
+  f |= (excepts & FE_ALL_EXCEPT);
+  fesetenv_register (f);
+
+  /* Force the operations that cause the exceptions.  */
+  if ((FE_INVALID & excepts) != 0)
+    {
+      /* ?? Does not set sticky bit ?? */
+      /* 0 / 0 */
+      asm volatile ("efsdiv %0,%0,%1" : : "r" (0), "r" (0));
+    }
+
+  if ((FE_DIVBYZERO & excepts) != 0)
+    {
+      /* 1.0 / 0.0 */
+      asm volatile ("efsdiv %0,%0,%1" : : "r" (1.0F), "r" (0));
+    }
+
+  if ((FE_OVERFLOW & excepts) != 0)
+    {
+      /* ?? Does not set sticky bit ?? */
+      /* Largest normalized number plus itself.  */
+      asm volatile ("efsadd %0,%0,%1" : : "r" (0x7f7fffff), "r" (0x7f7fffff));
+    }
+
+  if ((FE_UNDERFLOW & excepts) != 0)
+    {
+      /* ?? Does not set sticky bit ?? */
+      /* Smallest normalized number times itself.  */
+      asm volatile ("efsmul %0,%0,%1" : : "r" (0x800000), "r" (0x800000));
+    }
+
+  if ((FE_INEXACT & excepts) != 0)
+    {
+      /* Smallest normalized minus 1.0 raises the inexact flag.  */
+      asm volatile ("efssub %0,%0,%1" : : "r" (0x00800000), "r" (1.0F));
+    }
+
+  /* Success.  */
+  return 0;
+}
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/sfp-machine.h glibc-2.3.2/spe/sysdeps/powerpc/sfp-machine.h
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/sfp-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/sfp-machine.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,60 @@
+#ifndef _SFP_MACHINE_H_
+#define _SFP_MACHINE_H_
+#include <fenv_libc.h>
+
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+
+/* Someone please check this.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)		\
+	&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))	\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+/* Exception flags.  We use the bit positions of the appropriate bits
+   in the FPEFSCR, which also correspond to the FE_* bits.  This makes
+   everything easier ;-).  */
+#define FP_EX_INEXACT         (1 << (63 - 42))
+#define FP_EX_INVALID         (1 << (63 - 43))
+#define FP_EX_DIVZERO         (1 << (63 - 44))
+#define FP_EX_UNDERFLOW       (1 << (63 - 45))
+#define FP_EX_OVERFLOW        (1 << (63 - 46))
+
+/* This will work inasmuch as FP_EX_* are the same as FE_*.  */
+#define FP_HANDLE_EXCEPTIONS  __feraiseexcept_soft (_fex)
+
+#define FP_ROUNDMODE          (fegetenv_register() & 0x3)
+#endif /* _SFP_MACHINE_H_ */
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/Dist glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/Dist
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/Dist	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/Dist	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,2 @@
+sfp-machine.h
+fraiseexcept-soft.c
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/fraiseexcept-soft.c glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/fraiseexcept-soft.c
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/fraiseexcept-soft.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/fraiseexcept-soft.c	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,25 @@
+/* Raise given exceptions.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aldy Hernandez <aldyh@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv_libc.h>
+#include <bp-sym.h>
+
+#define __FERAISEEXCEPT_INTERNAL __feraiseexcept_soft
+#include "../raise.c"
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/Makefile glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/Makefile
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/Makefile	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,4 @@
+# Double precision floating point gets emulated.
+ifeq ($(subdir),soft-fp)
+sysdep_routines += $(gcc-double-routines) fraiseexcept-soft
+endif
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/sfp-machine.h glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/sfp-machine.h
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/sfp-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/sfp-machine.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,60 @@
+#ifndef _SFP_MACHINE_H_
+#define _SFP_MACHINE_H_
+#include <fenv_libc.h>
+
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_loop(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+
+/* Someone please check this.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)		\
+	&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))	\
+      {								\
+	R##_s = Y##_s;						\
+	_FP_FRAC_COPY_##wc(R,Y);				\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+	_FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+/* Exception flags.  We use the bit positions of the appropriate bits
+   in the FPEFSCR, which also correspond to the FE_* bits.  This makes
+   everything easier ;-).  */
+#define FP_EX_INEXACT         (1 << (63 - 42))
+#define FP_EX_INVALID         (1 << (63 - 43))
+#define FP_EX_DIVZERO         (1 << (63 - 44))
+#define FP_EX_UNDERFLOW       (1 << (63 - 45))
+#define FP_EX_OVERFLOW        (1 << (63 - 46))
+
+/* This will work inasmuch as FP_EX_* are the same as FE_*.  */
+#define FP_HANDLE_EXCEPTIONS  __feraiseexcept_soft (_fex)
+
+#define FP_ROUNDMODE          (fegetenv_register() & 0x3)
+#endif /* _SFP_MACHINE_H_ */
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/Subdirs glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/Subdirs
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/Subdirs	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/Subdirs	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1 @@
+soft-fp
diff -uNr glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/Versions glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/Versions
--- glibc-2.3.2.orig/spe/sysdeps/powerpc/soft-fp/Versions	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/sysdeps/powerpc/soft-fp/Versions	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,14 @@
+libc {
+  GLIBC_2.3.3 {
+    __feraiseexcept_soft;
+    __adddf3; __truncdfsf2;
+    __divdf3; __eqdf2;
+    __extendsfdf2; __fixdfdi; __fixdfsi; __fixsfdi;
+    __fixtfdi;
+    __fixunsdfdi; __fixunsdfsi;
+    __floatdidf; __floatsidf;
+    __gedf2; __ledf2; __muldf3;
+    __negdf2; __sqrtdf2; __subdf3;
+    __truncdfsf2;
+  }
+}
diff -uNr glibc-2.3.2.orig/spe/Versions glibc-2.3.2/spe/Versions
--- glibc-2.3.2.orig/spe/Versions	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/Versions	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,8 @@
+libspe {
+  GLIBC_2.3.3 {
+    atosfix16; atosfix32; atosfix64;
+    atoufix16; atoufix32; atoufix64;
+    strtosfix16; strtosfix32; strtosfix64;
+    strtoufix16; strtoufix32; strtoufix64;
+  }
+}
diff -uNr glibc-2.3.2.orig/spe/Versions.def glibc-2.3.2/spe/Versions.def
--- glibc-2.3.2.orig/spe/Versions.def	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/Versions.def	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,3 @@
+libspe {
+  GLIBC_2.3.3
+}
diff -uNr glibc-2.3.2.orig/spe/vfieeefp.h glibc-2.3.2/spe/vfieeefp.h
--- glibc-2.3.2.orig/spe/vfieeefp.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.3.2/spe/vfieeefp.h	2005-04-18 14:08:14.000000000 +0100
@@ -0,0 +1,27 @@
+#include "ieeefp.h"
+#include <math.h>
+#include <float.h>
+#include <errno.h>
+#include "config.h"
+
+#ifndef __IEEE_BIG_ENDIAN
+#error
+#endif
+
+#define Sign_Extend(a,b)
+
+union double_union
+{
+  double d;
+  __uint32_t i[2];
+};
+
+#define word0(x) (x.i[0])
+#define word1(x) (x.i[1])
+
+#define Exp_shift  20
+#define Exp_msk1    ((__uint32_t)0x100000L)
+#define Exp_mask  ((__uint32_t)0x7ff00000L)
+#define Bias 1023
+#define Ebits 11
+#define Sign_bit ((__uint32_t)0x80000000L)
diff -uNr glibc-2.3.2.orig/stdio-common/vfprintf.c glibc-2.3.2/stdio-common/vfprintf.c
--- glibc-2.3.2.orig/stdio-common/vfprintf.c	2003-01-30 18:30:25.000000000 +0000
+++ glibc-2.3.2/stdio-common/vfprintf.c	2005-04-18 14:08:14.000000000 +0100
@@ -224,6 +224,66 @@
 				  const char *)) internal_function;
 #endif
 
+/* __SPE__ local changes.  */
+#ifndef __BIG_ENDIAN__
+#error Huh
+#endif
+
+/* Convert an unsigned fixed-point 64-bit value to a double.  */
+static double
+__ufix64tod_internal (unsigned long long value)
+{
+  union double_union {
+    double d;
+    struct {
+      unsigned int sign:1;
+      unsigned int exp:11;
+      long long unsigned int mantissa:52;
+    } s;
+  };
+  union double_union u;
+  int negexp;
+  unsigned long long tmp;
+  static const int BIAS = 0x3ff;
+
+  /* -1 has to be handled specially.  */
+  if (value == 0x8000000000000000ull)
+    return -1;
+
+  if (value == 0)
+    u.d = 0.0;
+  else
+    {
+      /* Find exponent by locating most-significant one-bit.  */
+      negexp = 1;
+      tmp = value;
+      while (negexp < 65)
+        {
+          if (tmp & 0x4000000000000000ull)
+            break;
+          ++negexp;
+          tmp <<= 1;
+        }
+
+      u.s.sign = (value & 0x8000000000000000ull) != 0;
+      u.s.exp = -negexp + BIAS;
+      /* The code below loses the least significant 12 bits because
+         doubles (and long doubles) in ppc32-linux have 52-bit
+         mantissas.  This function should be adjusted if/when long
+         doubles get greater precision.  */
+      u.s.mantissa = (value & 0x7fffffffffffffffull) >> (64 - 52 - negexp - 1);
+#if SPE_DEBUG
+      printf("ufix64toa: fixed orig = %llx\n", value);
+      printf("ufix64toa: negexp=%x\n", negexp);
+      printf("ufix64toa: u.s sign =%x\n", u.s.sign);
+      printf("ufix64toa: u.s exp  =%x\n", u.s.exp);
+      printf("ufix64toa: u.s mant =%llx\n", (long long)u.s.mantissa);
+      printf("ufix64toa: double: '%f'\n", u.d);
+#endif
+    }
+  return u.d;
+}
+/* END OF __SPE__ LOCAL CHANGES.  */
 
 /* The function itself.  */
 int
@@ -288,7 +348,7 @@
 	       0, /* 'E' */ 19, /* F */   19, /* 'G' */ 19,
 	       0, /* 'I' */ 29,            0,            0,
     /* 'L' */ 12,            0,            0,            0,
-	       0,            0,            0, /* 'S' */ 21,
+	       0,            0, /* 'R'*/  19, /* 'S' */ 21,
 	       0,            0,            0,            0,
     /* 'X' */ 18,            0, /* 'Z' */ 13,            0,
 	       0,            0,            0,            0,
@@ -296,7 +356,7 @@
     /* 'd' */ 15, /* 'e' */ 19, /* 'f' */ 19, /* 'g' */ 19,
     /* 'h' */ 10, /* 'i' */ 15, /* 'j' */ 28,            0,
     /* 'l' */ 11, /* 'm' */ 24, /* 'n' */ 23, /* 'o' */ 17,
-    /* 'p' */ 22, /* 'q' */ 12,            0, /* 's' */ 21,
+    /* 'p' */ 22, /* 'q' */ 12, /* 'r' */ 19, /* 's' */ 21,
     /* 't' */ 27, /* 'u' */ 16,            0,            0,
     /* 'x' */ 18,            0, /* 'z' */ 13
   };
@@ -804,7 +864,8 @@
 	const void *ptr;						      \
 	int function_done;						      \
 									      \
-	if (fspec == NULL)						      \
+       /* __SPE__: check for 'r' and 'R' below.  */                          \
+       if (fspec == NULL || spec == 'r' || spec == 'R')                      \
 	  {								      \
 	    struct printf_info info = { .prec = prec,			      \
 					.width = width,			      \
@@ -821,6 +882,30 @@
 					.extra = 0,			      \
 					.wide = sizeof (CHAR_T) != 1 };	      \
 									      \
+           /* __SPE__ magic for fixed point numbers.  */                      \
+            if (info.spec == 'r' || info.spec == 'R')                         \
+              {                                                               \
+                unsigned long long uquad;                                     \
+                                                                              \
+                if (is_short)                                                 \
+                  {                                                           \
+                    uquad = va_arg (ap, unsigned /*short*/);                  \
+                    uquad <<= 48;                                             \
+                  }                                                           \
+                else if (is_long)                                             \
+                  uquad = va_arg (ap, unsigned long long);                    \
+                else                                                          \
+                  {                                                           \
+                    uquad = va_arg (ap, /*unsigned*/ int);                    \
+                    uquad <<= 32;                                             \
+                  }                                                           \
+               if (info.spec == 'R')                                          \
+                 uquad >>= 1;                                                 \
+               info.spec = 'f';                                               \
+                the_arg.pa_double = __ufix64tod_internal (uquad);             \
+              }                                                               \
+            else                                                              \
+           /* END OF __SPE__ */                                               \
 	    if (is_long_double)						      \
 	      the_arg.pa_long_double = va_arg (ap, long double);	      \
 	    else							      \
diff -uNr glibc-2.3.2.orig/stdio-common/vfscanf.c glibc-2.3.2/stdio-common/vfscanf.c
--- glibc-2.3.2.orig/stdio-common/vfscanf.c	2003-01-15 23:41:19.000000000 +0000
+++ glibc-2.3.2/stdio-common/vfscanf.c	2005-04-18 14:08:14.000000000 +0100
@@ -1591,6 +1591,10 @@
 	case L_('G'):
 	case L_('a'):
 	case L_('A'):
+       /* BEGIN __SPE__ */
+       case L_('r'):
+       case L_('R'):
+       /* END __SPE__ */
 	  c = inchar ();
 	  if (c == EOF)
 	    input_error ();
@@ -1870,6 +1874,39 @@
 	scan_float:
 	  /* Convert the number.  */
 	  ADDW (L_('\0'));
+         /* BEGIN __SPE__ */
+         if (fc == L_('r') || fc == L_('R'))
+           {
+             if (flags & LONG)         /* 'l' modifier */
+               {
+                 unsigned long long d;
+                 if (fc == L_('r'))
+                   d = strtosfix64 (wp, NULL);
+                 else
+                   d = strtoufix64 (wp, NULL);
+                 *ARG (unsigned long long *) = d;
+               }
+             else if (flags & SHORT)   /* 's' modifier */
+              {
+                 unsigned short d;
+                 if (fc == L_('r'))
+                   d = strtosfix16 (wp, NULL);
+                 else
+                   d = strtoufix16 (wp, NULL);
+                 *ARG (unsigned short *) = d;
+              }
+             else                      /* no modifier */
+              {
+                 unsigned long d;
+                 if (fc == L_('r'))
+                   d = strtosfix32 (wp, NULL);
+                 else
+                   d = strtoufix32 (wp, NULL);
+                 *ARG (unsigned long *) = d;
+              }
+           }
+         else
+         /* END __SPE__ */
 	  if (flags & LONGDBL)
 	    {
 	      long double d = __strtold_internal (wp, &tw, flags & GROUP);
diff -uNr glibc-2.3.2.orig/stdlib/stdlib.h glibc-2.3.2/stdlib/stdlib.h
--- glibc-2.3.2.orig/stdlib/stdlib.h	2002-08-28 03:11:33.000000000 +0100
+++ glibc-2.3.2/stdlib/stdlib.h	2005-04-18 14:08:14.000000000 +0100
@@ -911,6 +911,21 @@
 #endif /* don't just need malloc and calloc */
 #undef __need_malloc_and_calloc
 
+/* __SPE__ local changes */
+extern unsigned long long strtoufix64 (const char *, char **);
+extern short int atosfix16 (const char *);
+extern int atosfix32 (const char *);
+extern long long atosfix64 (const char *);
+extern unsigned short atoufix16 (const char *);
+extern unsigned int atoufix32 (const char *);
+extern unsigned long long atoufix64 (const char *);
+extern short int strtosfix16 (const char *, char **);
+extern int strtosfix32 (const char *, char **);
+extern long long strtosfix64 (const char *, char **);
+extern unsigned short int strtoufix16 (const char *, char **);
+extern unsigned int strtoufix32 (const char *, char **);
+/* end of __SPE__ local changes */
+
 __END_DECLS
 
 #endif /* stdlib.h  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/bits/fenvinline.h glibc-2.3.2/sysdeps/powerpc/fpu/bits/fenvinline.h
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/bits/fenvinline.h	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/bits/fenvinline.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/* Inline floating-point environment handling functions for powerpc.
-   Copyright (C) 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#if defined __GNUC__ && !defined _SOFT_FLOAT && !defined __NO_MATH_INLINES
-
-/* Inline definition for fegetround.  */
-# define fegetround() \
-  (__extension__  ({ int __fegetround_result;				      \
-		     __asm__ ("mcrfs 7,7 ; mfcr %0"			      \
-			     : "=r"(__fegetround_result) : : "cr7");	      \
-		     __fegetround_result & 3; }))
-
-/* The weird 'i#*X' constraints on the following suppress a gcc
-   warning when __excepts is not a constant.  Otherwise, they mean the
-   same as just plain 'i'.  */
-
-/* Inline definition for feraiseexcept.  */
-# define feraiseexcept(__excepts) \
-  ((__builtin_constant_p (__excepts)					      \
-    && ((__excepts) & ((__excepts)-1)) == 0				      \
-    && (__excepts) != FE_INVALID)					      \
-   ? ((__excepts) != 0							      \
-      ? (__extension__ ({ __asm__ __volatile__				      \
-			  ("mtfsb1 %s0"					      \
-			   : : "i#*X"(__builtin_ffs (__excepts)));	      \
-			  0; }))					      \
-      : 0)								      \
-   : (feraiseexcept) (__excepts))
-
-/* Inline definition for feclearexcept.  */
-# define feclearexcept(__excepts) \
-  ((__builtin_constant_p (__excepts)					      \
-    && ((__excepts) & ((__excepts)-1)) == 0				      \
-    && (__excepts) != FE_INVALID)					      \
-   ? ((__excepts) != 0							      \
-      ? (__extension__ ({ __asm__ __volatile__				      \
-			  ("mtfsb0 %s0"					      \
-			   : : "i#*X"(__builtin_ffs (__excepts)));	      \
-			  0; }))					      \
-      : 0)								      \
-   : (feclearexcept) (__excepts))
-
-#endif /* __GNUC__ && !_SOFT_FLOAT */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/bits/mathdef.h glibc-2.3.2/sysdeps/powerpc/fpu/bits/mathdef.h
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/bits/mathdef.h	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/bits/mathdef.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#if !defined _MATH_H && !defined _COMPLEX_H
-# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
-#endif
-
-
-/* FIXME! This file describes properties of the compiler, not the machine;
-   it should not be part of libc!
-
-   FIXME! This file does not deal with the -fshort-double option of
-   gcc! */
-
-#if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
-# define _MATH_H_MATHDEF	1
-
-# ifdef __GNUC__
-#  if __STDC__ == 1
-
-/* In GNU or ANSI mode, gcc leaves `float' expressions as-is.  */
-typedef float float_t;		/* `float' expressions are evaluated as
-				   `float'.  */
-typedef double double_t;	/* `double' expressions are evaluated as
-				   `double'.  */
-
-/* Signal that types stay as they were declared.  */
-#   define FLT_EVAL_METHOD	0
-
-/* Define `INFINITY' as value of type `float'.  */
-#   define INFINITY	HUGE_VALF
-
-#  else
-
-/* For `gcc -traditional', `float' expressions are evaluated as `double'. */
-typedef double float_t;		/* `float' expressions are evaluated as
-				   `double'.  */
-typedef double double_t;	/* `double' expressions are evaluated as
-				   `double'.  */
-
-/* Define `INFINITY' as value of type `float'.  */
-#   define INFINITY	HUGE_VALF
-
-#  endif
-# else
-
-/* Wild guess at types for float_t and double_t. */
-typedef double float_t;
-typedef double double_t;
-
-/* Define `INFINITY' as value of type `float'.  */
-#  define INFINITY	HUGE_VALF
-
-# endif
-
-/* The values returned by `ilogb' for 0 and NaN respectively.  */
-# define FP_ILOGB0	(-2147483647)
-# define FP_ILOGBNAN	(2147483647)
-
-#endif	/* ISO C99 */
-
-#ifndef __NO_LONG_DOUBLE_MATH
-/* Signal that we do not really have a `long double'.  The disables the
-   declaration of all the `long double' function variants.  */
-# define __NO_LONG_DOUBLE_MATH	1
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/bits/mathinline.h glibc-2.3.2/sysdeps/powerpc/fpu/bits/mathinline.h
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/bits/mathinline.h	2002-09-21 01:28:21.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/bits/mathinline.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,101 +0,0 @@
-/* Inline math functions for powerpc.
-   Copyright (C) 1995,1996,1997,1998,1999,2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#if defined __GNUC__ && !defined _SOFT_FLOAT
-
-#ifdef __USE_ISOC99
-# if __GNUC_PREREQ (2,96)
-
-#  define isgreater(x, y) __builtin_isgreater (x, y)
-#  define isgreaterequal(x, y) __builtin_isgreaterequal (x, y)
-#  define isless(x, y) __builtin_isless (x, y)
-#  define islessequal(x, y) __builtin_islessequal (x, y)
-#  define islessgreater(x, y) __builtin_islessgreater (x, y)
-#  define isunordered(x, y) __builtin_isunordered (x, y)
-
-# else
-
-#  define __unordered_cmp(x, y) \
-  (__extension__							      \
-   ({ __typeof__(x) __x = (x); __typeof__(y) __y = (y);			      \
-      unsigned __r;							      \
-      __asm__("fcmpu 7,%1,%2 ; mfcr %0" : "=r" (__r) : "f" (__x), "f"(__y)    \
-              : "cr7");  \
-      __r; }))
-
-#  define isgreater(x, y) (__unordered_cmp (x, y) >> 2 & 1)
-#  define isgreaterequal(x, y) ((__unordered_cmp (x, y) & 6) != 0)
-#  define isless(x, y) (__unordered_cmp (x, y) >> 3 & 1)
-#  define islessequal(x, y) ((__unordered_cmp (x, y) & 0xA) != 0)
-#  define islessgreater(x, y) ((__unordered_cmp (x, y) & 0xC) != 0)
-#  define isunordered(x, y) (__unordered_cmp (x, y) & 1)
-
-# endif /* __GNUC_PREREQ (2,97) */
-#endif /* __USE_ISOC99 */
-
-#if !defined __NO_MATH_INLINES && defined __OPTIMIZE__
-
-#ifdef __cplusplus
-# define __MATH_INLINE __inline
-#else
-# define __MATH_INLINE extern __inline
-#endif  /* __cplusplus */
-
-#ifdef __USE_ISOC99
-__MATH_INLINE long int lrint (double __x) __THROW;
-__MATH_INLINE long int
-lrint (double __x) __THROW
-{
-  union {
-    double __d;   
-    int __ll[2];
-  } __u;
-  __asm__ ("fctiw %0,%1" : "=f"(__u.__d) : "f"(__x));
-  return __u.__ll[1];
-}
-
-__MATH_INLINE long int lrintf (float __x) __THROW;
-__MATH_INLINE long int
-lrintf (float __x) __THROW
-{
-  union {
-    double __d;
-    int __ll[2];
-  } __u;
-  __asm__ ("fctiw %0,%1" : "=f"(__u.__d) : "f"(__x));
-  return __u.__ll[1];
-}
-
-__MATH_INLINE double fdim (double __x, double __y) __THROW;
-__MATH_INLINE double
-fdim (double __x, double __y) __THROW
-{
-  return __x < __y ? 0 : __x - __y;
-}
-
-__MATH_INLINE float fdimf (float __x, float __y) __THROW;
-__MATH_INLINE float
-fdimf (float __x, float __y) __THROW
-{
-  return __x < __y ? 0 : __x - __y;
-}
-
-#endif /* __USE_ISOC99 */
-#endif /* !__NO_MATH_INLINES && __OPTIMIZE__ */
-#endif /* __GNUC__ && !_SOFT_FLOAT */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/Dist glibc-2.3.2/sysdeps/powerpc/fpu/Dist
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/Dist	2002-09-19 06:47:02.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-fe_nomask.c
-fenv_const.c
-fenv_libc.h
-t_sqrt.c
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/e_sqrt.c glibc-2.3.2/sysdeps/powerpc/fpu/e_sqrt.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/e_sqrt.c	1999-10-11 23:29:48.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/e_sqrt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* __ieee754_sqrt is in w_sqrt.c  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/e_sqrtf.c glibc-2.3.2/sysdeps/powerpc/fpu/e_sqrtf.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/e_sqrtf.c	1999-10-11 23:29:48.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/e_sqrtf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* __ieee754_sqrtf is in w_sqrtf.c  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fclrexcpt.c glibc-2.3.2/sysdeps/powerpc/fpu/fclrexcpt.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fclrexcpt.c	2001-12-06 00:12:11.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fclrexcpt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-/* Clear given exceptions in current floating-point environment.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-#undef feclearexcept
-int
-__feclearexcept (int excepts)
-{
-  fenv_union_t u;
-
-  /* Get the current state.  */
-  u.fenv = fegetenv_register ();
-
-  /* Clear the relevant bits.  */
-  u.l[1] = u.l[1] & ~((-(excepts >> (31 - FPSCR_VX) & 1) & FE_ALL_INVALID)
-		      | (excepts & FPSCR_STICKY_BITS));
-
-  /* Put the new state in effect.  */
-  fesetenv_register (u.fenv);
-
-  /* Success.  */
-  return 0;
-}
-
-#include <shlib-compat.h>
-#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
-strong_alias (__feclearexcept, __old_feclearexcept)
-compat_symbol (libm, __old_feclearexcept, feclearexcept, GLIBC_2_1);
-#endif
-
-versioned_symbol (libm, __feclearexcept, feclearexcept, GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fedisblxcpt.c glibc-2.3.2/sysdeps/powerpc/fpu/fedisblxcpt.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fedisblxcpt.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fedisblxcpt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/* Disable floating-point exceptions.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Geoffrey Keating <geoffk@geoffk.org>, 2000.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-int
-fedisableexcept (int excepts)
-{
-  fenv_union_t fe;
-  int result;
-
-  result = fegetexcept ();
-
-  if ((excepts & FE_ALL_INVALID) == FE_ALL_INVALID)
-    excepts = (excepts | FE_INVALID) & ~ FE_ALL_INVALID;
-
-  fe.fenv = fegetenv_register ();
-  if (excepts & FE_INEXACT)
-    fe.l[1] &= ~(1 << (31 - FPSCR_XE));
-  if (excepts & FE_DIVBYZERO)
-    fe.l[1] &= ~(1 << (31 - FPSCR_ZE));
-  if (excepts & FE_UNDERFLOW)
-    fe.l[1] &= ~(1 << (31 - FPSCR_UE));
-  if (excepts & FE_OVERFLOW)
-    fe.l[1] &= ~(1 << (31 - FPSCR_OE));
-  if (excepts & FE_INVALID)
-    fe.l[1] &= ~(1 << (31 - FPSCR_VE));
-  fesetenv_register (fe.fenv);
-
-  if ((fegetexcept () & excepts) != 0)
-    result = -1;
-  return result;
-}
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/feenablxcpt.c glibc-2.3.2/sysdeps/powerpc/fpu/feenablxcpt.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/feenablxcpt.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/feenablxcpt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/* Enable floating-point exceptions.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Geoffrey Keating <geoffk@geoffk.org>, 2000.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-int
-feenableexcept (int excepts)
-{
-  fenv_union_t fe;
-  int result, new;
-
-  result = fegetexcept ();
-
-  if ((excepts & FE_ALL_INVALID) == FE_ALL_INVALID)
-    excepts = (excepts | FE_INVALID) & ~ FE_ALL_INVALID;
-
-  fe.fenv = fegetenv_register ();
-  if (excepts & FE_INEXACT)
-    fe.l[1] |= (1 << (31 - FPSCR_XE));
-  if (excepts & FE_DIVBYZERO)
-    fe.l[1] |= (1 << (31 - FPSCR_ZE));
-  if (excepts & FE_UNDERFLOW)
-    fe.l[1] |= (1 << (31 - FPSCR_UE));
-  if (excepts & FE_OVERFLOW)
-    fe.l[1] |= (1 << (31 - FPSCR_OE));
-  if (excepts & FE_INVALID)
-    fe.l[1] |= (1 << (31 - FPSCR_VE));
-  fesetenv_register (fe.fenv);
-
-  new = fegetexcept ();
-  if (new != 0 && result == 0)
-    (void)__fe_nomask_env ();
-
-  if ((new & excepts) != excepts)
-    result = -1;
-
-  return result;
-}
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fegetenv.c glibc-2.3.2/sysdeps/powerpc/fpu/fegetenv.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fegetenv.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fegetenv.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/* Store current floating-point environment.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-#include <bp-sym.h>
-
-int
-__fegetenv (fenv_t *envp)
-{
-  *envp = fegetenv_register ();
-
-  /* Success.  */
-  return 0;
-}
-
-#include <shlib-compat.h>
-#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
-strong_alias (__fegetenv, __old_fegetenv)
-compat_symbol (libm, BP_SYM (__old_fegetenv), BP_SYM (fegetenv), GLIBC_2_1);
-#endif
-
-versioned_symbol (libm, BP_SYM (__fegetenv), BP_SYM (fegetenv), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fegetexcept.c glibc-2.3.2/sysdeps/powerpc/fpu/fegetexcept.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fegetexcept.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fegetexcept.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* Get floating-point exceptions.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Geoffrey Keating <geoffk@geoffk.org>, 2000.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-int
-fegetexcept (void)
-{
-  fenv_union_t fe;
-  int result = 0;
-
-  fe.fenv = fegetenv_register ();
- 
-  if (fe.l[1] & (1 << (31 - FPSCR_XE)))
-      result |= FE_INEXACT;
-  if (fe.l[1] & (1 << (31 - FPSCR_ZE)))
-      result |= FE_DIVBYZERO;
-  if (fe.l[1] & (1 << (31 - FPSCR_UE)))
-      result |= FE_UNDERFLOW;
-  if (fe.l[1] & (1 << (31 - FPSCR_OE)))
-      result |= FE_OVERFLOW;
-  if (fe.l[1] & (1 << (31 - FPSCR_VE)))
-      result |= FE_INVALID;
-
-  return result;
-}
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fegetround.c glibc-2.3.2/sysdeps/powerpc/fpu/fegetround.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fegetround.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fegetround.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-/* Return current rounding direction.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-#undef fegetround
-int
-fegetround (void)
-{
-  int result;
-  asm ("mcrfs 7,7 ; mfcr %0" : "=r"(result) : : "cr7"); \
-  return result & 3;
-}
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/feholdexcpt.c glibc-2.3.2/sysdeps/powerpc/fpu/feholdexcpt.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/feholdexcpt.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/feholdexcpt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/* Store current floating-point environment and clear exceptions.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-int
-feholdexcept (fenv_t *envp)
-{
-  fenv_union_t u;
-
-  /* Get the current state.  */
-  u.fenv = *envp = fegetenv_register ();
-
-  /* Clear everything except for the rounding mode and non-IEEE arithmetic
-     flag.  */
-  u.l[1] = u.l[1] & 7;
-
-  /* Put the new state in effect.  */
-  fesetenv_register (u.fenv);
-
-  return 0;
-}
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fe_nomask.c glibc-2.3.2/sysdeps/powerpc/fpu/fe_nomask.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fe_nomask.c	2001-12-06 23:41:33.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fe_nomask.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-/* Procedure definition for FE_NOMASK_ENV.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv.h>
-#include <errno.h>
-
-/* This is presently a stub, until it's decided how the kernels should
-   support this.  */
-
-const fenv_t *
-__fe_nomask_env(void)
-{
-  __set_errno (ENOSYS);
-  return FE_ENABLED_ENV;
-}
-stub_warning (__fe_nomask_env)
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fenv_const.c glibc-2.3.2/sysdeps/powerpc/fpu/fenv_const.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fenv_const.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fenv_const.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/* Constants for fenv_bits.h.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* We want to specify the bit pattern of the __fe_*_env constants, so 
-   pretend they're really `long long' instead of `double'.  */
-
-/* If the default argument is used we use this value.  */
-const unsigned long long __fe_dfl_env __attribute__ ((aligned (8))) = 
-0xfff8000000000000ULL;
-
-/* Floating-point environment where none of the exceptions are masked.  */
-const unsigned long long __fe_enabled_env __attribute__ ((aligned (8))) = 
-0xfff80000000000f8ULL;
-
-/* Floating-point environment with the NI bit set.  */
-const unsigned long long __fe_nonieee_env __attribute__ ((aligned (8))) = 
-0xfff8000000000004ULL;
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fenv_libc.h glibc-2.3.2/sysdeps/powerpc/fpu/fenv_libc.h
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fenv_libc.h	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fenv_libc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,106 +0,0 @@
-/* Internal libc stuff for floating point environment routines.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _FENV_LIBC_H
-#define _FENV_LIBC_H	1
-
-#include <fenv.h>
-
-/* The sticky bits in the FPSCR indicating exceptions have occurred.  */
-#define FPSCR_STICKY_BITS ((FE_ALL_EXCEPT | FE_ALL_INVALID) & ~FE_INVALID)
-
-/* Equivalent to fegetenv, but returns a fenv_t instead of taking a
-   pointer.  */
-#define fegetenv_register() \
-        ({ fenv_t env; asm volatile ("mffs %0" : "=f" (env)); env; })
-
-/* Equivalent to fesetenv, but takes a fenv_t instead of a pointer.  */
-#define fesetenv_register(env) \
-        ({ double d = (env); asm volatile ("mtfsf 0xff,%0" : : "f" (d)); })
-
-/* This very handy macro:
-   - Sets the rounding mode to 'round to nearest';
-   - Sets the processor into IEEE mode; and
-   - Prevents exceptions from being raised for inexact results.
-   These things happen to be exactly what you need for typical elementary
-   functions.  */
-#define relax_fenv_state() asm ("mtfsfi 7,0")
-
-/* Set/clear a particular FPSCR bit (for instance,
-   reset_fpscr_bit(FPSCR_VE);
-   prevents INVALID exceptions from being raised).  */
-#define set_fpscr_bit(x) asm volatile ("mtfsb1 %0" : : "i"(x))
-#define reset_fpscr_bit(x) asm volatile ("mtfsb0 %0" : : "i"(x))
-
-typedef union
-{
-  fenv_t fenv;
-  unsigned int l[2];
-} fenv_union_t;
-
-/* Definitions of all the FPSCR bit numbers */
-enum {
-  FPSCR_FX = 0,    /* exception summary */
-  FPSCR_FEX,       /* enabled exception summary */
-  FPSCR_VX,        /* invalid operation summary */
-  FPSCR_OX,        /* overflow */
-  FPSCR_UX,        /* underflow */
-  FPSCR_ZX,        /* zero divide */
-  FPSCR_XX,        /* inexact */
-  FPSCR_VXSNAN,    /* invalid operation for SNaN */
-  FPSCR_VXISI,     /* invalid operation for Inf-Inf */
-  FPSCR_VXIDI,     /* invalid operation for Inf/Inf */
-  FPSCR_VXZDZ,     /* invalid operation for 0/0 */
-  FPSCR_VXIMZ,     /* invalid operation for Inf*0 */
-  FPSCR_VXVC,      /* invalid operation for invalid compare */
-  FPSCR_FR,        /* fraction rounded [fraction was incremented by round] */
-  FPSCR_FI,        /* fraction inexact */
-  FPSCR_FPRF_C,    /* result class descriptor */
-  FPSCR_FPRF_FL,   /* result less than (usually, less than 0) */
-  FPSCR_FPRF_FG,   /* result greater than */
-  FPSCR_FPRF_FE,   /* result equal to */
-  FPSCR_FPRF_FU,   /* result unordered */
-  FPSCR_20,        /* reserved */
-  FPSCR_VXSOFT,    /* invalid operation set by software */
-  FPSCR_VXSQRT,    /* invalid operation for square root */
-  FPSCR_VXCVI,     /* invalid operation for invalid integer convert */
-  FPSCR_VE,        /* invalid operation exception enable */
-  FPSCR_OE,        /* overflow exception enable */
-  FPSCR_UE,        /* underflow exception enable */
-  FPSCR_ZE,        /* zero divide exception enable */
-  FPSCR_XE,        /* inexact exception enable */
-  FPSCR_NI         /* non-IEEE mode (typically, no denormalised numbers) */
-  /* the remaining two least-significant bits keep the rounding mode */
-};
-
-/* This operation (i) sets the appropriate FPSCR bits for its
-   parameter, (ii) converts SNaN to the corresponding NaN, and (iii)
-   otherwise passes its parameter through unchanged (in particular, -0
-   and +0 stay as they were).  The `obvious' way to do this is optimised
-   out by gcc.  */
-#define f_wash(x) \
-   ({ double d; asm volatile ("fmul %0,%1,%2" \
-			      : "=f"(d) \
-			      : "f" (x), "f"((float)1.0)); d; })
-#define f_washf(x) \
-   ({ float f; asm volatile ("fmuls %0,%1,%2" \
-			     : "=f"(f) \
-			     : "f" (x), "f"((float)1.0)); f; })
- 
-#endif /* fenv_libc.h */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fesetenv.c glibc-2.3.2/sysdeps/powerpc/fpu/fesetenv.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fesetenv.c	2002-09-10 01:37:31.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fesetenv.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/* Install given floating-point environment.
-   Copyright (C) 1997,99,2000,01,02 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-#include <bp-sym.h>
-
-int
-__fesetenv (const fenv_t *envp)
-{
-  fesetenv_register (*envp);
-
-  /* Success.  */
-  return 0;
-}
-
-#include <shlib-compat.h>
-#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
-strong_alias (__fesetenv, __old_fesetenv)
-compat_symbol (libm, BP_SYM (__old_fesetenv), BP_SYM (fesetenv), GLIBC_2_1);
-#endif
-
-libm_hidden_ver (__fesetenv, fesetenv)
-versioned_symbol (libm, BP_SYM (__fesetenv), BP_SYM (fesetenv), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fesetround.c glibc-2.3.2/sysdeps/powerpc/fpu/fesetround.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fesetround.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fesetround.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/* Set current rounding direction.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-int
-fesetround (int round)
-{
-  fenv_union_t u;
-
-  if ((unsigned int) round > 3)
-    return 1;
-
-  /* Get the current state.  */
-  u.fenv = fegetenv_register ();
-
-  /* Set the relevant bits.  */
-  u.l[1] = (u.l[1] & ~3)  |  (round & 3);
-
-  /* Put the new state in effect.  */
-  fesetenv_register (u.fenv);
-
-  return 0;
-}
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/feupdateenv.c glibc-2.3.2/sysdeps/powerpc/fpu/feupdateenv.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/feupdateenv.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/feupdateenv.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,49 +0,0 @@
-/* Install given floating-point environment and raise exceptions.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-#include <bp-sym.h>
-
-int
-__feupdateenv (const fenv_t *envp)
-{
-  fenv_union_t old, new;
-
-  /* Save the currently set exceptions.  */
-  new.fenv = *envp;
-  old.fenv = fegetenv_register ();
-
-  /* Copy the set exceptions from `old' to `new'.  */
-  new.l[1] = (new.l[1] & 0xE00000FF) | (old.l[1] & 0x1FFFFF00);
-
-  /* Atomically enable and raise (if appropriate) exceptions set in `new'. */
-  fesetenv_register (new.fenv);
-
-  /* Success.  */
-  return 0;
-}
-
-#include <shlib-compat.h>
-#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
-strong_alias (__feupdateenv, __old_feupdateenv)
-compat_symbol (libm, BP_SYM (__old_feupdateenv), BP_SYM (feupdateenv), GLIBC_2_1);
-#endif
-
-versioned_symbol (libm, BP_SYM (__feupdateenv), BP_SYM (feupdateenv), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fgetexcptflg.c glibc-2.3.2/sysdeps/powerpc/fpu/fgetexcptflg.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fgetexcptflg.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fgetexcptflg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/* Store current representation for exceptions.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-#include <bp-sym.h>
-
-int
-__fegetexceptflag (fexcept_t *flagp, int excepts)
-{
-  fenv_union_t u;
-
-  /* Get the current state.  */
-  u.fenv = fegetenv_register ();
-
-  /* Return (all of) it.  */
-  *flagp = u.l[1];
-
-  /* Success.  */
-  return 0;
-}
-
-#include <shlib-compat.h>
-#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
-strong_alias (__fegetexceptflag, __old_fegetexceptflag)
-compat_symbol (libm, BP_SYM (__old_fegetexceptflag), BP_SYM (fegetexceptflag), GLIBC_2_1);
-#endif
-
-versioned_symbol (libm, BP_SYM (__fegetexceptflag), BP_SYM (fegetexceptflag), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fpu_control.h glibc-2.3.2/sysdeps/powerpc/fpu/fpu_control.h
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fpu_control.h	2003-02-27 22:40:15.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fpu_control.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/* FPU control word definitions.  PowerPC version.
-   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _FPU_CONTROL_H
-#define _FPU_CONTROL_H
-
-/* rounding control */
-#define _FPU_RC_NEAREST 0x00   /* RECOMMENDED */
-#define _FPU_RC_DOWN    0x03
-#define _FPU_RC_UP      0x02
-#define _FPU_RC_ZERO    0x01
-
-#define _FPU_MASK_NI  0x04 /* non-ieee mode */
-
-/* masking of interrupts */
-#define _FPU_MASK_ZM  0x10 /* zero divide */
-#define _FPU_MASK_OM  0x40 /* overflow */
-#define _FPU_MASK_UM  0x20 /* underflow */
-#define _FPU_MASK_XM  0x08 /* inexact */
-#define _FPU_MASK_IM  0x80 /* invalid operation */
-
-#define _FPU_RESERVED 0xffffff00 /* These bits are reserved are not changed. */
-
-/* The fdlibm code requires no interrupts for exceptions.  */
-#define _FPU_DEFAULT  0x00000000 /* Default value.  */
-
-/* IEEE:  same as above, but (some) exceptions;
-   we leave the 'inexact' exception off.
- */
-#define _FPU_IEEE     0x000000f0
-
-/* Type of the control word.  */
-typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
-
-/* Macros for accessing the hardware control word.  */
-#define _FPU_GETCW(__cw) ( { \
-  union { double d; fpu_control_t cw[2]; } \
-    tmp __attribute__ ((__aligned__(8))); \
-  __asm__ ("mffs 0; stfd%U0 0,%0" : "=m" (tmp.d) : : "fr0"); \
-  (__cw)=tmp.cw[1]; \
-  tmp.cw[1]; } )
-#define _FPU_SETCW(__cw) { \
-  union { double d; fpu_control_t cw[2]; } \
-    tmp __attribute__ ((__aligned__(8))); \
-  tmp.cw[0] = 0xFFF80000; /* More-or-less arbitrary; this is a QNaN. */ \
-  tmp.cw[1] = __cw; \
-  __asm__ ("lfd%U0 0,%0; mtfsf 255,0" : : "m" (tmp.d) : "fr0"); \
-}
-
-/* Default control word set at startup.  */
-extern fpu_control_t __fpu_control;
-
-#endif /* _FPU_CONTROL_H */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fraiseexcpt.c glibc-2.3.2/sysdeps/powerpc/fpu/fraiseexcpt.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fraiseexcpt.c	2002-09-10 01:37:31.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fraiseexcpt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/* Raise given exceptions.
-   Copyright (C) 1997,99,2000,01,02 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-#include <bp-sym.h>
-
-#undef feraiseexcept
-int
-__feraiseexcept (int excepts)
-{
-  fenv_union_t u;
-
-  /* Raise exceptions represented by EXCEPTS.  It is the responsibility of
-     the OS to ensure that if multiple exceptions occur they are fed back
-     to this process in the proper way; this can happen in hardware,
-     anyway (in particular, inexact with overflow or underflow). */
-
-  /* Get the current state.  */
-  u.fenv = fegetenv_register ();
-
-  /* Add the exceptions */
-  u.l[1] = (u.l[1]
-	    | (excepts & FPSCR_STICKY_BITS)
-	    /* Turn FE_INVALID into FE_INVALID_SOFTWARE.  */
-	    | (excepts >> ((31 - FPSCR_VX) - (31 - FPSCR_VXSOFT))
-	       & FE_INVALID_SOFTWARE));
-
-  /* Store the new status word (along with the rest of the environment),
-     triggering any appropriate exceptions.  */
-  fesetenv_register (u.fenv);
-
-  if ((excepts & FE_INVALID)
-      /* For some reason, some PowerPC chips (the 601, in particular)
-	 don't have FE_INVALID_SOFTWARE implemented.  Detect this
-	 case and raise FE_INVALID_SNAN instead.  */
-      && !fetestexcept (FE_INVALID))
-    set_fpscr_bit (FPSCR_VXSNAN);
-
-  /* Success.  */
-  return 0;
-}
-
-#include <shlib-compat.h>
-#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
-strong_alias (__feraiseexcept, __old_feraiseexcept)
-compat_symbol (libm, BP_SYM (__old_feraiseexcept), BP_SYM (feraiseexcept), GLIBC_2_1);
-#endif
-
-libm_hidden_ver (__feraiseexcept, feraiseexcept)
-versioned_symbol (libm, BP_SYM (__feraiseexcept), BP_SYM (feraiseexcept), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/fsetexcptflg.c glibc-2.3.2/sysdeps/powerpc/fpu/fsetexcptflg.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/fsetexcptflg.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/fsetexcptflg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-/* Set floating-point environment exception handling.
-   Copyright (C) 1997,99,2000,01 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-#include <bp-sym.h>
-
-int
-__fesetexceptflag (const fexcept_t *flagp, int excepts)
-{
-  fenv_union_t u;
-  fexcept_t flag;
-
-  /* Get the current state.  */
-  u.fenv = fegetenv_register ();
-
-  /* Ignore exceptions not listed in 'excepts'.  */
-  flag = *flagp & excepts;
-
-  /* Replace the exception status */
-  u.l[1] = ((u.l[1] & ~(FPSCR_STICKY_BITS & excepts))
-	    | (flag & FPSCR_STICKY_BITS)
-	    | (flag >> ((31 - FPSCR_VX) - (31 - FPSCR_VXSOFT))
-	       & FE_INVALID_SOFTWARE));
-
-  /* Store the new status word (along with the rest of the environment).
-     This may cause floating-point exceptions if the restored state
-     requests it.  */
-  fesetenv_register (u.fenv);
-
-  /* Deal with FE_INVALID_SOFTWARE not being implemented on some chips.  */
-  if (flag & FE_INVALID)
-    feraiseexcept(FE_INVALID);
-
-  /* Success.  */
-  return 0;
-}
-
-#include <shlib-compat.h>
-#if SHLIB_COMPAT (libm, GLIBC_2_1, GLIBC_2_2)
-strong_alias (__fesetexceptflag, __old_fesetexceptflag)
-compat_symbol (libm, BP_SYM (__old_fesetexceptflag), BP_SYM (fesetexceptflag), GLIBC_2_1);
-#endif
-
-versioned_symbol (libm, BP_SYM (__fesetexceptflag), BP_SYM (fesetexceptflag), GLIBC_2_2);
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/ftestexcept.c glibc-2.3.2/sysdeps/powerpc/fpu/ftestexcept.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/ftestexcept.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/ftestexcept.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-/* Test exception in current environment.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <fenv_libc.h>
-
-int
-fetestexcept (int excepts)
-{
-  fenv_union_t u;
-
-  /* Get the current state.  */
-  u.fenv = fegetenv_register ();
-
-  /* The FE_INVALID bit is dealt with correctly by the hardware, so we can
-     just:  */
-  return u.l[1] & excepts;
-}
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/libm-test-ulps glibc-2.3.2/sysdeps/powerpc/fpu/libm-test-ulps
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/libm-test-ulps	2002-09-02 23:15:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/libm-test-ulps	1970-01-01 01:00:00.000000000 +0100
@@ -1,866 +0,0 @@
-# Begin of automatic generation
-
-# atan2
-Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
-float: 3
-ifloat: 3
-Test "atan2 (0.75, -1.0) == 2.49809154479650885165983415456218025":
-float: 3
-ifloat: 3
-Test "atan2 (1.390625, 0.9296875) == 0.981498387184244311516296577615519772":
-float: 1
-ifloat: 1
-
-# atanh
-Test "atanh (0.75) == 0.972955074527656652552676371721589865":
-float: 1
-ifloat: 1
-
-# cacosh
-Test "Real part of: cacosh (-2 - 3 i) == -1.9833870299165354323470769028940395 + 2.1414491111159960199416055713254211 i":
-double: 1
-float: 7
-idouble: 1
-ifloat: 7
-Test "Imaginary part of: cacosh (-2 - 3 i) == -1.9833870299165354323470769028940395 + 2.1414491111159960199416055713254211 i":
-double: 1
-float: 3
-idouble: 1
-ifloat: 3
-
-# casin
-Test "Real part of: casin (0.75 + 1.25 i) == 0.453276177638793913448921196101971749 + 1.13239363160530819522266333696834467 i":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-# casinh
-Test "Real part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
-double: 5
-float: 1
-idouble: 5
-ifloat: 1
-Test "Imaginary part of: casinh (-2 - 3 i) == -1.9686379257930962917886650952454982 - 0.96465850440760279204541105949953237 i":
-double: 3
-float: 6
-idouble: 3
-ifloat: 6
-Test "Real part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: casinh (0.75 + 1.25 i) == 1.03171853444778027336364058631006594 + 0.911738290968487636358489564316731207 i":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-# catan
-Test "Real part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
-float: 3
-ifloat: 3
-Test "Imaginary part of: catan (-2 - 3 i) == -1.4099210495965755225306193844604208 - 0.22907268296853876629588180294200276 i":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "Real part of: catan (0.75 + 1.25 i) == 1.10714871779409050301706546017853704 + 0.549306144334054845697622618461262852 i":
-float: 4
-ifloat: 4
-
-# catanh
-Test "Real part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
-double: 4
-idouble: 4
-Test "Imaginary part of: catanh (-2 - 3 i) == -0.14694666622552975204743278515471595 - 1.3389725222944935611241935759091443 i":
-float: 4
-ifloat: 4
-Test "Real part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
-double: 1
-idouble: 1
-Test "Imaginary part of: catanh (0.75 + 1.25 i) == 0.261492138795671927078652057366532140 + 0.996825126463918666098902241310446708 i":
-float: 6
-ifloat: 6
-
-# cbrt
-Test "cbrt (-27.0) == -3.0":
-double: 1
-idouble: 1
-Test "cbrt (0.9921875) == 0.997389022060725270579075195353955217":
-double: 1
-idouble: 1
-
-# ccos
-Test "Imaginary part of: ccos (-2 - 3 i) == -4.1896256909688072301 - 9.1092278937553365979 i":
-float: 1
-ifloat: 1
-Test "Real part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "Imaginary part of: ccos (0.75 + 1.25 i) == 1.38173873063425888530729933139078645 - 1.09193013555397466170919531722024128 i":
-float: 1
-ifloat: 1
-
-# ccosh
-Test "Real part of: ccosh (-2 - 3 i) == -3.7245455049153225654 + 0.5118225699873846088 i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: ccosh (-2 - 3 i) == -3.7245455049153225654 + 0.5118225699873846088 i":
-float: 1
-ifloat: 1
-Test "Real part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "Imaginary part of: ccosh (0.75 + 1.25 i) == 0.408242591877968807788852146397499084 + 0.780365930845853240391326216300863152 i":
-float: 1
-ifloat: 1
-
-# cexp
-Test "Imaginary part of: cexp (-2.0 - 3.0 i) == -0.13398091492954261346140525546115575 - 0.019098516261135196432576240858800925 i":
-float: 1
-ifloat: 1
-Test "Real part of: cexp (0.75 + 1.25 i) == 0.667537446429131586942201977015932112 + 2.00900045494094876258347228145863909 i":
-float: 1
-ifloat: 1
-
-# clog
-Test "Imaginary part of: clog (-2 - 3 i) == 1.2824746787307683680267437207826593 - 2.1587989303424641704769327722648368 i":
-float: 3
-ifloat: 3
-Test "Real part of: clog (0.75 + 1.25 i) == 0.376885901188190075998919126749298416 + 1.03037682652431246378774332703115153 i":
-float: 1
-ifloat: 1
-
-# clog10
-Test "Imaginary part of: clog10 (-0 + inf i) == inf + pi/2*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (-0 - inf i) == inf - pi/2*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (-2 - 3 i) == 0.5569716761534183846 - 0.9375544629863747085 i":
-double: 1
-float: 5
-idouble: 1
-ifloat: 5
-Test "Imaginary part of: clog10 (-3 + inf i) == inf + pi/2*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (-3 - inf i) == inf - pi/2*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (-inf + 0 i) == inf + pi*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (-inf + 1 i) == inf + pi*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (-inf - 0 i) == inf - pi*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (-inf - 1 i) == inf - pi*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (0 + inf i) == inf + pi/2*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (0 - inf i) == inf - pi/2*log10(e) i":
-float: 1
-ifloat: 1
-Test "Real part of: clog10 (0.75 + 1.25 i) == 0.163679467193165171449476605077428975 + 0.447486970040493067069984724340855636 i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (3 + inf i) == inf + pi/2*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (3 - inf i) == inf - pi/2*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (inf + inf i) == inf + pi/4*log10(e) i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: clog10 (inf - inf i) == inf - pi/4*log10(e) i":
-float: 1
-ifloat: 1
-
-# cos
-Test "cos (M_PI_6l * 2.0) == 0.5":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "cos (M_PI_6l * 4.0) == -0.5":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-Test "cos (pi/2) == 0":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-# cpow
-Test "Real part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: cpow (0.75 + 1.25 i, 0.0 + 1.0 i) == 0.331825439177608832276067945276730566 + 0.131338600281188544930936345230903032 i":
-float: 1
-ifloat: 1
-Test "Real part of: cpow (0.75 + 1.25 i, 0.75 + 1.25 i) == 0.117506293914473555420279832210420483 + 0.346552747708338676483025352060418001 i":
-double: 1
-float: 4
-idouble: 1
-ifloat: 4
-Test "Real part of: cpow (0.75 + 1.25 i, 1.0 + 1.0 i) == 0.0846958290317209430433805274189191353 + 0.513285749182902449043287190519090481 i":
-double: 2
-float: 3
-idouble: 2
-ifloat: 3
-Test "Real part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
-double: 1
-float: 4
-idouble: 1
-ifloat: 4
-Test "Imaginary part of: cpow (2 + 3 i, 4 + 0 i) == -119.0 - 120.0 i":
-float: 2
-ifloat: 2
-Test "Imaginary part of: cpow (e + 0 i, 0 + 2 * M_PIl i) == 1.0 + 0.0 i":
-double: 2
-float: 2
-idouble: 2
-ifloat: 2
-
-# csinh
-Test "Imaginary part of: csinh (-2 - 3 i) == 3.5905645899857799520 - 0.5309210862485198052 i":
-double: 1
-idouble: 1
-Test "Real part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
-float: 1
-ifloat: 1
-Test "Imaginary part of: csinh (0.75 + 1.25 i) == 0.259294854551162779153349830618433028 + 1.22863452409509552219214606515777594 i":
-float: 1
-ifloat: 1
-
-# csqrt
-Test "Real part of: csqrt (-2 + 3 i) == 0.89597747612983812471573375529004348 + 1.6741492280355400404480393008490519 i":
-float: 1
-ifloat: 1
-Test "Real part of: csqrt (-2 - 3 i) == 0.89597747612983812471573375529004348 - 1.6741492280355400404480393008490519 i":
-float: 1
-ifloat: 1
-
-# ctan
-Test "Real part of: ctan (-2 - 3 i) == 0.0037640256415042482 - 1.0032386273536098014 i":
-double: 1
-idouble: 1
-Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
-double: 1
-idouble: 1
-
-# ctanh
-Test "Real part of: ctanh (-2 - 3 i) == -0.9653858790221331242 + 0.0098843750383224937 i":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-Test "Imaginary part of: ctanh (0 + pi/4 i) == 0.0 + 1.0 i":
-float: 1
-ifloat: 1
-Test "Real part of: ctanh (0.75 + 1.25 i) == 1.37260757053378320258048606571226857 + 0.385795952609750664177596760720790220 i":
-double: 1
-idouble: 1
-
-# erf
-Test "erf (1.25) == 0.922900128256458230136523481197281140":
-double: 1
-idouble: 1
-
-# erfc
-Test "erfc (0.75) == 0.288844366346484868401062165408589223":
-float: 1
-ifloat: 1
-Test "erfc (2.0) == 0.00467773498104726583793074363274707139":
-double: 1
-idouble: 1
-Test "erfc (4.125) == 0.542340079956506600531223408575531062e-8":
-double: 1
-idouble: 1
-
-# exp10
-Test "exp10 (-1) == 0.1":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-Test "exp10 (0.75) == 5.62341325190349080394951039776481231":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "exp10 (3) == 1000":
-double: 6
-float: 2
-idouble: 6
-ifloat: 2
-
-# expm1
-Test "expm1 (0.75) == 1.11700001661267466854536981983709561":
-double: 1
-idouble: 1
-Test "expm1 (1) == M_El - 1.0":
-float: 1
-ifloat: 1
-
-# hypot
-Test "hypot (-0.7, -12.4) == 12.419742348374220601176836866763271":
-float: 1
-ifloat: 1
-Test "hypot (-0.7, 12.4) == 12.419742348374220601176836866763271":
-float: 1
-ifloat: 1
-Test "hypot (-12.4, -0.7) == 12.419742348374220601176836866763271":
-float: 1
-ifloat: 1
-Test "hypot (-12.4, 0.7) == 12.419742348374220601176836866763271":
-float: 1
-ifloat: 1
-Test "hypot (0.7, -12.4) == 12.419742348374220601176836866763271":
-float: 1
-ifloat: 1
-Test "hypot (0.7, 12.4) == 12.419742348374220601176836866763271":
-float: 1
-ifloat: 1
-Test "hypot (12.4, -0.7) == 12.419742348374220601176836866763271":
-float: 1
-ifloat: 1
-Test "hypot (12.4, 0.7) == 12.419742348374220601176836866763271":
-float: 1
-ifloat: 1
-
-# j0
-Test "j0 (-4.0) == -3.9714980986384737228659076845169804197562E-1":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "j0 (10.0) == -0.245935764451348335197760862485328754":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-Test "j0 (4.0) == -3.9714980986384737228659076845169804197562E-1":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "j0 (8.0) == 0.171650807137553906090869407851972001":
-float: 1
-ifloat: 1
-
-# j1
-Test "j1 (10.0) == 0.0434727461688614366697487680258592883":
-float: 2
-ifloat: 2
-Test "j1 (2.0) == 0.576724807756873387202448242269137087":
-double: 1
-idouble: 1
-Test "j1 (8.0) == 0.234636346853914624381276651590454612":
-double: 1
-idouble: 1
-
-# jn
-Test "jn (0, -4.0) == -3.9714980986384737228659076845169804197562E-1":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "jn (0, 10.0) == -0.245935764451348335197760862485328754":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-Test "jn (0, 4.0) == -3.9714980986384737228659076845169804197562E-1":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "jn (0, 8.0) == 0.171650807137553906090869407851972001":
-float: 1
-ifloat: 1
-Test "jn (1, 10.0) == 0.0434727461688614366697487680258592883":
-float: 2
-ifloat: 2
-Test "jn (1, 2.0) == 0.576724807756873387202448242269137087":
-double: 1
-idouble: 1
-Test "jn (1, 8.0) == 0.234636346853914624381276651590454612":
-double: 1
-idouble: 1
-Test "jn (10, 0.125) == 0.250543369809369890173993791865771547e-18":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "jn (10, 0.75) == 0.149621713117596814698712483621682835e-10":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "jn (10, 10.0) == 0.207486106633358857697278723518753428":
-float: 1
-ifloat: 1
-Test "jn (10, 2.0) == 0.251538628271673670963516093751820639e-6":
-float: 3
-ifloat: 3
-Test "jn (3, 0.125) == 0.406503832554912875023029337653442868e-4":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "jn (3, 0.75) == 0.848438342327410884392755236884386804e-2":
-double: 1
-idouble: 1
-Test "jn (3, 10.0) == 0.0583793793051868123429354784103409563":
-double: 3
-float: 1
-idouble: 3
-ifloat: 1
-Test "jn (3, 2.0) == 0.128943249474402051098793332969239835":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-# lgamma
-Test "lgamma (0.7) == 0.26086724653166651439":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "lgamma (1.2) == -0.853740900033158497197e-1":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-
-# log10
-Test "log10 (0.75) == -0.124938736608299953132449886193870744":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-Test "log10 (e) == log10(e)":
-float: 1
-ifloat: 1
-
-# log1p
-Test "log1p (-0.25) == -0.287682072451780927439219005993827432":
-float: 1
-ifloat: 1
-
-# sincos
-Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in sin_res":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "sincos (pi/2, &sin_res, &cos_res) puts 0 in cos_res":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "sincos (pi/6, &sin_res, &cos_res) puts 0.86602540378443864676372317075293616 in cos_res":
-float: 1
-ifloat: 1
-
-# tan
-Test "tan (pi/4) == 1":
-double: 1
-idouble: 1
-
-# tgamma
-Test "tgamma (-0.5) == -2 sqrt (pi)":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "tgamma (0.5) == sqrt (pi)":
-float: 1
-ifloat: 1
-Test "tgamma (0.7) == 1.29805533264755778568":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-# y0
-Test "y0 (1.0) == 0.0882569642156769579829267660235151628":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-Test "y0 (1.5) == 0.382448923797758843955068554978089862":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-Test "y0 (10.0) == 0.0556711672835993914244598774101900481":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "y0 (2.0) == 0.510375672649745119596606592727157873":
-double: 1
-idouble: 1
-Test "y0 (8.0) == 0.223521489387566220527323400498620359":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-# y1
-Test "y1 (10.0) == 0.249015424206953883923283474663222803":
-double: 3
-float: 1
-idouble: 3
-ifloat: 1
-Test "y1 (2.0) == -0.107032431540937546888370772277476637":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "y1 (8.0) == -0.158060461731247494255555266187483550":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-
-# yn
-Test "yn (0, 1.0) == 0.0882569642156769579829267660235151628":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-Test "yn (0, 1.5) == 0.382448923797758843955068554978089862":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-Test "yn (0, 10.0) == 0.0556711672835993914244598774101900481":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "yn (0, 2.0) == 0.510375672649745119596606592727157873":
-double: 1
-idouble: 1
-Test "yn (0, 8.0) == 0.223521489387566220527323400498620359":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "yn (1, 10.0) == 0.249015424206953883923283474663222803":
-double: 3
-float: 1
-idouble: 3
-ifloat: 1
-Test "yn (1, 2.0) == -0.107032431540937546888370772277476637":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "yn (1, 8.0) == -0.158060461731247494255555266187483550":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-Test "yn (10, 0.75) == -2133501638.90573424452445412893839236":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-Test "yn (10, 1.0) == -121618014.278689189288130426667971145":
-float: 2
-ifloat: 2
-Test "yn (10, 10.0) == -0.359814152183402722051986577343560609":
-double: 2
-idouble: 2
-Test "yn (10, 2.0) == -129184.542208039282635913145923304214":
-double: 3
-float: 1
-idouble: 3
-ifloat: 1
-Test "yn (3, 0.75) == -12.9877176234475433186319774484809207":
-float: 1
-ifloat: 1
-Test "yn (3, 10.0) == -0.251362657183837329779204747654240998":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-Test "yn (3, 2.0) == -1.12778377684042778608158395773179238":
-double: 1
-idouble: 1
-
-# Maximal error of functions:
-Function: "atan2":
-float: 3
-ifloat: 3
-
-Function: "atanh":
-float: 1
-ifloat: 1
-
-Function: Real part of "cacosh":
-double: 1
-float: 7
-idouble: 1
-ifloat: 7
-
-Function: Imaginary part of "cacosh":
-double: 1
-float: 3
-idouble: 1
-ifloat: 3
-
-Function: Real part of "casin":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: Real part of "casinh":
-double: 5
-float: 1
-idouble: 5
-ifloat: 1
-
-Function: Imaginary part of "casinh":
-double: 3
-float: 6
-idouble: 3
-ifloat: 6
-
-Function: Real part of "catan":
-float: 4
-ifloat: 4
-
-Function: Imaginary part of "catan":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: Real part of "catanh":
-double: 4
-idouble: 4
-
-Function: Imaginary part of "catanh":
-float: 6
-ifloat: 6
-
-Function: "cbrt":
-double: 1
-idouble: 1
-
-Function: Real part of "ccos":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: Imaginary part of "ccos":
-float: 1
-ifloat: 1
-
-Function: Real part of "ccosh":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: Imaginary part of "ccosh":
-float: 1
-ifloat: 1
-
-Function: Real part of "cexp":
-float: 1
-ifloat: 1
-
-Function: Imaginary part of "cexp":
-float: 1
-ifloat: 1
-
-Function: Real part of "clog":
-float: 1
-ifloat: 1
-
-Function: Imaginary part of "clog":
-float: 3
-ifloat: 3
-
-Function: Real part of "clog10":
-float: 1
-ifloat: 1
-
-Function: Imaginary part of "clog10":
-double: 1
-float: 5
-idouble: 1
-ifloat: 5
-
-Function: "cos":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-
-Function: Real part of "cpow":
-double: 2
-float: 4
-idouble: 2
-ifloat: 4
-
-Function: Imaginary part of "cpow":
-double: 2
-float: 2
-idouble: 2
-ifloat: 2
-
-Function: Real part of "csinh":
-float: 1
-ifloat: 1
-
-Function: Imaginary part of "csinh":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: Real part of "csqrt":
-float: 1
-ifloat: 1
-
-Function: Real part of "ctan":
-double: 1
-idouble: 1
-
-Function: Imaginary part of "ctan":
-double: 1
-idouble: 1
-
-Function: Real part of "ctanh":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-
-Function: Imaginary part of "ctanh":
-float: 1
-ifloat: 1
-
-Function: "erf":
-double: 1
-idouble: 1
-
-Function: "erfc":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: "exp10":
-double: 6
-float: 2
-idouble: 6
-ifloat: 2
-
-Function: "expm1":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: "hypot":
-float: 1
-ifloat: 1
-
-Function: "j0":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-
-Function: "j1":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-
-Function: "jn":
-double: 3
-float: 3
-idouble: 3
-ifloat: 3
-
-Function: "lgamma":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-
-Function: "log10":
-double: 1
-float: 2
-idouble: 1
-ifloat: 2
-
-Function: "log1p":
-float: 1
-ifloat: 1
-
-Function: "sincos":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: "tan":
-double: 1
-idouble: 1
-
-Function: "tgamma":
-double: 1
-float: 1
-idouble: 1
-ifloat: 1
-
-Function: "y0":
-double: 2
-float: 1
-idouble: 2
-ifloat: 1
-
-Function: "y1":
-double: 3
-float: 2
-idouble: 3
-ifloat: 2
-
-Function: "yn":
-double: 3
-float: 2
-idouble: 3
-ifloat: 2
-
-# end of automatic generation
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/Makefile glibc-2.3.2/sysdeps/powerpc/fpu/Makefile
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/Makefile	2002-09-05 10:56:27.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-ifeq ($(subdir),math)
-libm-support += fenv_const fe_nomask t_sqrt
-endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fabsf.S glibc-2.3.2/sysdeps/powerpc/fpu/s_fabsf.S
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fabsf.S	1997-08-29 01:50:47.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_fabsf.S	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* __fabsf is in s_fabs.S  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fabs.S glibc-2.3.2/sysdeps/powerpc/fpu/s_fabs.S
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fabs.S	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_fabs.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/* Floating-point absolute value.  PowerPC version.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-ENTRY(__fabs)
-/* double [f1] fabs (double [f1] x); */
-	fabs fp1,fp1
-	blr
-END(__fabs)
-
-weak_alias(__fabs,fabs)
-
-/* It turns out that it's safe to use this code even for single-precision.  */
-strong_alias(__fabs,__fabsf)
-weak_alias(__fabs,fabsf)
-
-#ifdef NO_LONG_DOUBLE
-weak_alias(__fabs,__fabsl)
-weak_alias(__fabs,fabsl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fdim.c glibc-2.3.2/sysdeps/powerpc/fpu/s_fdim.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fdim.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_fdim.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-/* Return positive difference between arguments.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-
-double
-__fdim (double x, double y)
-{
-  return x < y ? 0 : x - y;
-}
-weak_alias (__fdim, fdim)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__fdim, __fdiml)
-weak_alias (__fdim, fdiml)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fdimf.c glibc-2.3.2/sysdeps/powerpc/fpu/s_fdimf.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fdimf.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_fdimf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,27 +0,0 @@
-/* Return positive difference between arguments.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-
-float
-__fdimf (float x, float y)
-{
-  return x < y ? 0 : x - y;
-}
-weak_alias (__fdimf, fdimf)
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fmaxf.S glibc-2.3.2/sysdeps/powerpc/fpu/s_fmaxf.S
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fmaxf.S	1997-12-28 15:13:00.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_fmaxf.S	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* __fmaxf is in s_fmax.c  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fmax.S glibc-2.3.2/sysdeps/powerpc/fpu/s_fmax.S
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fmax.S	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_fmax.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* Floating-point maximum.  PowerPC version.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-ENTRY(__fmax)
-/* double [f1] fmax (double [f1] x, double [f2] y); */
-	fcmpu	cr0,fp1,fp2
-	blt	cr0,0f		/* if x < y, neither x nor y can be NaN... */
-	bnulr+	cr0
-/* x and y are unordered, so one of x or y must be a NaN... */
-	fcmpu	cr1,fp2,fp2
-	bunlr	cr1
-0:	fmr	fp1,fp2
-	blr
-END(__fmax)
-
-weak_alias(__fmax,fmax)
-
-/* It turns out that it's safe to use this code even for single-precision.  */
-strong_alias(__fmax,__fmaxf)
-weak_alias(__fmax,fmaxf)
-
-#ifdef NO_LONG_DOUBLE
-weak_alias(__fmax,__fmaxl)
-weak_alias(__fmax,fmaxl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fminf.S glibc-2.3.2/sysdeps/powerpc/fpu/s_fminf.S
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fminf.S	1997-12-28 15:13:00.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_fminf.S	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* __fminf is in s_fmin.c  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fmin.S glibc-2.3.2/sysdeps/powerpc/fpu/s_fmin.S
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_fmin.S	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_fmin.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* Floating-point minimum.  PowerPC version.
-   Copyright (C) 1997, 1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-
-ENTRY(__fmin)
-/* double [f1] fmin (double [f1] x, double [f2] y); */
-	fcmpu	cr0,fp1,fp2
-	bgt	cr0,0f		/* if x > y, neither x nor y can be NaN... */
-	bnulr+	cr0
-/* x and y are unordered, so one of x or y must be a NaN... */
-	fcmpu	cr1,fp2,fp2
-	bunlr	cr1
-0:	fmr	fp1,fp2
-	blr
-END(__fmin)
-
-weak_alias(__fmin,fmin)
-
-/* It turns out that it's safe to use this code even for single-precision.  */
-strong_alias(__fmin,__fminf)
-weak_alias(__fmin,fminf)
-
-#ifdef NO_LONG_DOUBLE
-weak_alias(__fmin,__fminl)
-weak_alias(__fmin,fminl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_isnan.c glibc-2.3.2/sysdeps/powerpc/fpu/s_isnan.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_isnan.c	2002-09-12 23:08:12.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_isnan.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-/* Return 1 if argument is a NaN, else 0.
-   Copyright (C) 1997, 2000, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* Ugly kludge to avoid declarations.  */
-#define __isnanf __Xisnanf
-#define isnanf Xisnanf
-#define __GI___isnanf __GI___Xisnanf
-
-#include "math.h"
-#include <fenv_libc.h>
-
-#undef __isnanf
-#undef isnanf
-#undef __GI___isnanf
-
-
-/* The hidden_proto in include/math.h was obscured by the macro hackery.  */
-__typeof (__isnan) __isnanf;
-hidden_proto (__isnanf)
-
-
-int
-__isnan (x)
-     double x;
-{
-  fenv_t savedstate;
-  int result;
-  savedstate = fegetenv_register ();
-  reset_fpscr_bit (FPSCR_VE);
-  result = !(x == x);
-  fesetenv_register (savedstate);
-  return result;
-}
-hidden_def (__isnan)
-weak_alias (__isnan, isnan)
-
-
-/* It turns out that the 'double' version will also always work for
-   single-precision.  */
-strong_alias (__isnan, __isnanf)
-hidden_def (__isnanf)
-weak_alias (__isnanf, isnanf)
-
-#ifdef NO_LONG_DOUBLE
-strong_alias (__isnan, __isnanl)
-weak_alias (__isnan, isnanl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_isnanf.S glibc-2.3.2/sysdeps/powerpc/fpu/s_isnanf.S
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_isnanf.S	1997-08-29 01:50:52.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_isnanf.S	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* __isnanf is in s_isnan.c  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_llrint.c glibc-2.3.2/sysdeps/powerpc/fpu/s_llrint.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_llrint.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_llrint.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-/* Round a double value to a long long in the current rounding mode.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include "math.h"
-
-long long int
-__llrint (double x)
-{
-  return (long long int) __rint (x);
-}
-weak_alias (__llrint, llrint)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__llrint, __llrintl)
-weak_alias (__llrint, llrintl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_llrintf.c glibc-2.3.2/sysdeps/powerpc/fpu/s_llrintf.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_llrintf.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_llrintf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,27 +0,0 @@
-/* Round a float value to a long long in the current rounding mode.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include "math.h"
-
-long long int
-__llrintf (float x)
-{
-  return (long long int) __rintf (x);
-}
-weak_alias (__llrintf, llrintf)
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_llround.c glibc-2.3.2/sysdeps/powerpc/fpu/s_llround.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_llround.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_llround.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/* Round double value to long long int.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-
-/* I think that what this routine is supposed to do is round a value
-   to the nearest integer, with values exactly on the boundary rounded
-   away from zero.  */
-/* This routine relies on (long long)x, when x is out of range of a long long,
-   clipping to MAX_LLONG or MIN_LLONG.  */
-
-long long int
-__llround (double x)
-{
-  double xrf;
-  long long int xr;
-  xr = (long long int) x;
-  xrf = (double) xr;
-  if (x >= 0.0)
-    if (x - xrf >= 0.5 && x - xrf < 1.0 && x+1 > 0)
-      return x+1;
-    else
-      return x;
-  else
-    if (xrf - x >= 0.5 && xrf - x < 1.0 && x-1 < 0)
-      return x-1;
-    else
-      return x;
-}
-weak_alias (__llround, llround)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__llround, __llroundl)
-weak_alias (__llround, llroundl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_llroundf.c glibc-2.3.2/sysdeps/powerpc/fpu/s_llroundf.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_llroundf.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_llroundf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-/* Round float value to long long int.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-
-/* I think that what this routine is supposed to do is round a value
-   to the nearest integer, with values exactly on the boundary rounded
-   away from zero.  */
-/* This routine relies on (long long)x, when x is out of range of a long long,
-   clipping to MAX_LLONG or MIN_LLONG.  */
-
-long long int
-__llroundf (float x)
-{
-  float xrf;
-  long long int xr;
-  xr = (long long int) x;
-  xrf = (float) xr;
-  if (x >= 0.0)
-    if (x - xrf >= 0.5 && x - xrf < 1.0 && x+1 > 0)
-      return x+1;
-    else
-      return x;
-  else
-    if (xrf - x >= 0.5 && xrf - x < 1.0 && x-1 < 0)
-      return x-1;
-    else
-      return x;
-}
-weak_alias (__llroundf, llroundf)
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_lrint.c glibc-2.3.2/sysdeps/powerpc/fpu/s_lrint.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_lrint.c	2002-09-21 01:28:21.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_lrint.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-/* Round floating-point to integer.  PowerPC version.
-   Copyright (C) 1997,2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* Kludge to avoid decls that will confuse strong_alias below.  */
-#define __lrintf XXX__lrintf
-#define __lrintl XXX__lrintl
-#define lrintf XXXlrintf
-#define lrintl XXXlrintl
-
-#include "math.h"
-
-#undef __lrintf
-#undef __lrintl
-#undef lrintf
-#undef lrintl
-
-
-long int
-__lrint (double x)
-{
-  union
-  {
-    double d;
-    int ll[2];
-  } u;
-  asm ("fctiw %0,%1" : "=f"(u.d) : "f"(x));
-  return u.ll[1];
-}
-weak_alias (__lrint, lrint)
-
-strong_alias (__lrint, __lrintf)
-weak_alias (__lrint, lrintf)
-
-#ifdef NO_LONG_DOUBLE
-strong_alias (__lrint, __lrintl)
-weak_alias (__lrint, lrintl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_lrintf.S glibc-2.3.2/sysdeps/powerpc/fpu/s_lrintf.S
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_lrintf.S	1997-12-28 15:13:00.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_lrintf.S	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* __lrintf is in s_lrint.c  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_lround.c glibc-2.3.2/sysdeps/powerpc/fpu/s_lround.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_lround.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_lround.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/* Round double value to long int.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-
-/* I think that what this routine is supposed to do is round a value
-   to the nearest integer, with values exactly on the boundary rounded
-   away from zero.  */
-/* This routine relies on (long int)x, when x is out of range of a long int,
-   clipping to MAX_LONG or MIN_LONG.  */
-
-long int
-__lround (double x)
-{
-  double xrf;
-  long int xr;
-  xr = (long int) x;
-  xrf = (double) xr;
-  if (x >= 0.0)
-    if (x - xrf >= 0.5 && x - xrf < 1.0 && x+1 > 0)
-      return x+1;
-    else
-      return x;
-  else
-    if (xrf - x >= 0.5 && xrf - x < 1.0 && x-1 < 0)
-      return x-1;
-    else
-      return x;
-}
-weak_alias (__lround, lround)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__lround, __lroundl)
-weak_alias (__lround, lroundl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_lroundf.c glibc-2.3.2/sysdeps/powerpc/fpu/s_lroundf.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_lroundf.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_lroundf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-/* Round float value to long int.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-
-/* I think that what this routine is supposed to do is round a value
-   to the nearest integer, with values exactly on the boundary rounded
-   away from zero.  */
-/* This routine relies on (long int)x, when x is out of range of a long int,
-   clipping to MAX_LONG or MIN_LONG.  */
-
-long int
-__lroundf (float x)
-{
-  float xrf;
-  long int xr;
-  xr = (long int) x;
-  xrf = (float) xr;
-  if (x >= 0.0)
-    if (x - xrf >= 0.5 && x - xrf < 1.0 && x+1 > 0)
-      return x+1;
-    else
-      return x;
-  else
-    if (xrf - x >= 0.5 && xrf - x < 1.0 && x-1 < 0)
-      return x-1;
-    else
-      return x;
-}
-weak_alias (__lroundf, lroundf)
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_rint.c glibc-2.3.2/sysdeps/powerpc/fpu/s_rint.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_rint.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_rint.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/* Round a 64-bit floating point value to the nearest integer.
-   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include "math.h"
-
-double
-__rint (double x)
-{
-  static const float TWO52 = 4503599627370496.0;
-
-  if (fabs (x) < TWO52)
-    {
-      if (x > 0.0)
-	{
-	  x += TWO52;
-	  x -= TWO52;
-	}
-      else if (x < 0.0)
-	{
-	  x = TWO52 - x;
-	  x = -(x - TWO52);
-	}
-    }
-
-  return x;
-}
-weak_alias (__rint, rint)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__rint, __rintl)
-weak_alias (__rint, rintl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_rintf.c glibc-2.3.2/sysdeps/powerpc/fpu/s_rintf.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/s_rintf.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/s_rintf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-/* Round a 32-bit floating point value to the nearest integer.
-   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include "math.h"
-
-float
-__rintf (float x)
-{
-  static const float TWO23 = 8388608.0;
-
-  if (fabsf (x) < TWO23)
-    {
-      if (x > 0.0)
-	{
-	  x += TWO23;
-	  x -= TWO23;
-	}
-      else if (x < 0.0)
-	{
-	  x = TWO23 - x;
-	  x = -(x - TWO23);
-	}
-    }
-  
-  return x;
-}
-weak_alias (__rintf, rintf)
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/t_sqrt.c glibc-2.3.2/sysdeps/powerpc/fpu/t_sqrt.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/t_sqrt.c	1997-08-10 18:49:29.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/t_sqrt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-const float __t_sqrt[1024] = {
-0.7078,0.7064, 0.7092,0.7050, 0.7106,0.7037, 0.7119,0.7023, 0.7133,0.7010,
-0.7147,0.6996, 0.7160,0.6983, 0.7174,0.6970, 0.7187,0.6957, 0.7201,0.6943,
-0.7215,0.6930, 0.7228,0.6917, 0.7242,0.6905, 0.7255,0.6892, 0.7269,0.6879,
-0.7282,0.6866, 0.7295,0.6854, 0.7309,0.6841, 0.7322,0.6829, 0.7335,0.6816,
-0.7349,0.6804, 0.7362,0.6792, 0.7375,0.6779, 0.7388,0.6767, 0.7402,0.6755,
-0.7415,0.6743, 0.7428,0.6731, 0.7441,0.6719, 0.7454,0.6708, 0.7467,0.6696,
-0.7480,0.6684, 0.7493,0.6672, 0.7507,0.6661, 0.7520,0.6649, 0.7532,0.6638,
-0.7545,0.6627, 0.7558,0.6615, 0.7571,0.6604, 0.7584,0.6593, 0.7597,0.6582,
-0.7610,0.6570, 0.7623,0.6559, 0.7635,0.6548, 0.7648,0.6537, 0.7661,0.6527,
-0.7674,0.6516, 0.7686,0.6505, 0.7699,0.6494, 0.7712,0.6484, 0.7725,0.6473,
-0.7737,0.6462, 0.7750,0.6452, 0.7762,0.6441, 0.7775,0.6431, 0.7787,0.6421,
-0.7800,0.6410, 0.7812,0.6400, 0.7825,0.6390, 0.7837,0.6380, 0.7850,0.6370,
-0.7862,0.6359, 0.7875,0.6349, 0.7887,0.6339, 0.7900,0.6330, 0.7912,0.6320,
-0.7924,0.6310, 0.7937,0.6300, 0.7949,0.6290, 0.7961,0.6281, 0.7973,0.6271,
-0.7986,0.6261, 0.7998,0.6252, 0.8010,0.6242, 0.8022,0.6233, 0.8034,0.6223,
-0.8046,0.6214, 0.8059,0.6205, 0.8071,0.6195, 0.8083,0.6186, 0.8095,0.6177,
-0.8107,0.6168, 0.8119,0.6158, 0.8131,0.6149, 0.8143,0.6140, 0.8155,0.6131,
-0.8167,0.6122, 0.8179,0.6113, 0.8191,0.6104, 0.8203,0.6096, 0.8215,0.6087,
-0.8227,0.6078, 0.8238,0.6069, 0.8250,0.6060, 0.8262,0.6052, 0.8274,0.6043,
-0.8286,0.6035, 0.8297,0.6026, 0.8309,0.6017, 0.8321,0.6009, 0.8333,0.6000,
-0.8344,0.5992, 0.8356,0.5984, 0.8368,0.5975, 0.8379,0.5967, 0.8391,0.5959,
-0.8403,0.5950, 0.8414,0.5942, 0.8426,0.5934, 0.8437,0.5926, 0.8449,0.5918,
-0.8461,0.5910, 0.8472,0.5902, 0.8484,0.5894, 0.8495,0.5886, 0.8507,0.5878,
-0.8518,0.5870, 0.8530,0.5862, 0.8541,0.5854, 0.8552,0.5846, 0.8564,0.5838,
-0.8575,0.5831, 0.8587,0.5823, 0.8598,0.5815, 0.8609,0.5808, 0.8621,0.5800,
-0.8632,0.5792, 0.8643,0.5785, 0.8655,0.5777, 0.8666,0.5770, 0.8677,0.5762,
-0.8688,0.5755, 0.8700,0.5747, 0.8711,0.5740, 0.8722,0.5733, 0.8733,0.5725,
-0.8744,0.5718, 0.8756,0.5711, 0.8767,0.5703, 0.8778,0.5696, 0.8789,0.5689,
-0.8800,0.5682, 0.8811,0.5675, 0.8822,0.5667, 0.8833,0.5660, 0.8844,0.5653,
-0.8855,0.5646, 0.8866,0.5639, 0.8877,0.5632, 0.8888,0.5625, 0.8899,0.5618,
-0.8910,0.5611, 0.8921,0.5605, 0.8932,0.5598, 0.8943,0.5591, 0.8954,0.5584,
-0.8965,0.5577, 0.8976,0.5570, 0.8987,0.5564, 0.8998,0.5557, 0.9008,0.5550,
-0.9019,0.5544, 0.9030,0.5537, 0.9041,0.5530, 0.9052,0.5524, 0.9062,0.5517,
-0.9073,0.5511, 0.9084,0.5504, 0.9095,0.5498, 0.9105,0.5491, 0.9116,0.5485,
-0.9127,0.5478, 0.9138,0.5472, 0.9148,0.5465, 0.9159,0.5459, 0.9170,0.5453,
-0.9180,0.5446, 0.9191,0.5440, 0.9202,0.5434, 0.9212,0.5428, 0.9223,0.5421,
-0.9233,0.5415, 0.9244,0.5409, 0.9254,0.5403, 0.9265,0.5397, 0.9276,0.5391,
-0.9286,0.5384, 0.9297,0.5378, 0.9307,0.5372, 0.9318,0.5366, 0.9328,0.5360,
-0.9338,0.5354, 0.9349,0.5348, 0.9359,0.5342, 0.9370,0.5336, 0.9380,0.5330,
-0.9391,0.5324, 0.9401,0.5319, 0.9411,0.5313, 0.9422,0.5307, 0.9432,0.5301,
-0.9442,0.5295, 0.9453,0.5289, 0.9463,0.5284, 0.9473,0.5278, 0.9484,0.5272,
-0.9494,0.5266, 0.9504,0.5261, 0.9515,0.5255, 0.9525,0.5249, 0.9535,0.5244,
-0.9545,0.5238, 0.9556,0.5233, 0.9566,0.5227, 0.9576,0.5221, 0.9586,0.5216,
-0.9596,0.5210, 0.9607,0.5205, 0.9617,0.5199, 0.9627,0.5194, 0.9637,0.5188,
-0.9647,0.5183, 0.9657,0.5177, 0.9667,0.5172, 0.9677,0.5167, 0.9687,0.5161,
-0.9698,0.5156, 0.9708,0.5151, 0.9718,0.5145, 0.9728,0.5140, 0.9738,0.5135,
-0.9748,0.5129, 0.9758,0.5124, 0.9768,0.5119, 0.9778,0.5114, 0.9788,0.5108,
-0.9798,0.5103, 0.9808,0.5098, 0.9818,0.5093, 0.9828,0.5088, 0.9838,0.5083,
-0.9847,0.5077, 0.9857,0.5072, 0.9867,0.5067, 0.9877,0.5062, 0.9887,0.5057,
-0.9897,0.5052, 0.9907,0.5047, 0.9917,0.5042, 0.9926,0.5037, 0.9936,0.5032,
-0.9946,0.5027, 0.9956,0.5022, 0.9966,0.5017, 0.9976,0.5012, 0.9985,0.5007,
-0.9995,0.5002, 
-1.0010,0.4995, 1.0029,0.4985, 1.0049,0.4976, 1.0068,0.4966, 1.0088,0.4957,
-1.0107,0.4947, 1.0126,0.4938, 1.0145,0.4928, 1.0165,0.4919, 1.0184,0.4910,
-1.0203,0.4901, 1.0222,0.4891, 1.0241,0.4882, 1.0260,0.4873, 1.0279,0.4864,
-1.0298,0.4855, 1.0317,0.4846, 1.0336,0.4837, 1.0355,0.4829, 1.0374,0.4820,
-1.0393,0.4811, 1.0411,0.4802, 1.0430,0.4794, 1.0449,0.4785, 1.0468,0.4777,
-1.0486,0.4768, 1.0505,0.4760, 1.0523,0.4751, 1.0542,0.4743, 1.0560,0.4735,
-1.0579,0.4726, 1.0597,0.4718, 1.0616,0.4710, 1.0634,0.4702, 1.0653,0.4694,
-1.0671,0.4686, 1.0689,0.4678, 1.0707,0.4670, 1.0726,0.4662, 1.0744,0.4654,
-1.0762,0.4646, 1.0780,0.4638, 1.0798,0.4630, 1.0816,0.4623, 1.0834,0.4615,
-1.0852,0.4607, 1.0870,0.4600, 1.0888,0.4592, 1.0906,0.4585, 1.0924,0.4577,
-1.0942,0.4570, 1.0960,0.4562, 1.0978,0.4555, 1.0995,0.4547, 1.1013,0.4540,
-1.1031,0.4533, 1.1049,0.4525, 1.1066,0.4518, 1.1084,0.4511, 1.1101,0.4504,
-1.1119,0.4497, 1.1137,0.4490, 1.1154,0.4483, 1.1172,0.4476, 1.1189,0.4469,
-1.1207,0.4462, 1.1224,0.4455, 1.1241,0.4448, 1.1259,0.4441, 1.1276,0.4434,
-1.1293,0.4427, 1.1311,0.4421, 1.1328,0.4414, 1.1345,0.4407, 1.1362,0.4401,
-1.1379,0.4394, 1.1397,0.4387, 1.1414,0.4381, 1.1431,0.4374, 1.1448,0.4368,
-1.1465,0.4361, 1.1482,0.4355, 1.1499,0.4348, 1.1516,0.4342, 1.1533,0.4335,
-1.1550,0.4329, 1.1567,0.4323, 1.1584,0.4316, 1.1600,0.4310, 1.1617,0.4304,
-1.1634,0.4298, 1.1651,0.4292, 1.1668,0.4285, 1.1684,0.4279, 1.1701,0.4273,
-1.1718,0.4267, 1.1734,0.4261, 1.1751,0.4255, 1.1768,0.4249, 1.1784,0.4243,
-1.1801,0.4237, 1.1817,0.4231, 1.1834,0.4225, 1.1850,0.4219, 1.1867,0.4213,
-1.1883,0.4208, 1.1900,0.4202, 1.1916,0.4196, 1.1932,0.4190, 1.1949,0.4185,
-1.1965,0.4179, 1.1981,0.4173, 1.1998,0.4167, 1.2014,0.4162, 1.2030,0.4156,
-1.2046,0.4151, 1.2063,0.4145, 1.2079,0.4139, 1.2095,0.4134, 1.2111,0.4128,
-1.2127,0.4123, 1.2143,0.4117, 1.2159,0.4112, 1.2175,0.4107, 1.2192,0.4101,
-1.2208,0.4096, 1.2224,0.4090, 1.2239,0.4085, 1.2255,0.4080, 1.2271,0.4075,
-1.2287,0.4069, 1.2303,0.4064, 1.2319,0.4059, 1.2335,0.4054, 1.2351,0.4048,
-1.2366,0.4043, 1.2382,0.4038, 1.2398,0.4033, 1.2414,0.4028, 1.2429,0.4023,
-1.2445,0.4018, 1.2461,0.4013, 1.2477,0.4008, 1.2492,0.4003, 1.2508,0.3998,
-1.2523,0.3993, 1.2539,0.3988, 1.2555,0.3983, 1.2570,0.3978, 1.2586,0.3973,
-1.2601,0.3968, 1.2617,0.3963, 1.2632,0.3958, 1.2648,0.3953, 1.2663,0.3949,
-1.2678,0.3944, 1.2694,0.3939, 1.2709,0.3934, 1.2725,0.3929, 1.2740,0.3925,
-1.2755,0.3920, 1.2771,0.3915, 1.2786,0.3911, 1.2801,0.3906, 1.2816,0.3901,
-1.2832,0.3897, 1.2847,0.3892, 1.2862,0.3887, 1.2877,0.3883, 1.2892,0.3878,
-1.2907,0.3874, 1.2923,0.3869, 1.2938,0.3865, 1.2953,0.3860, 1.2968,0.3856,
-1.2983,0.3851, 1.2998,0.3847, 1.3013,0.3842, 1.3028,0.3838, 1.3043,0.3834,
-1.3058,0.3829, 1.3073,0.3825, 1.3088,0.3820, 1.3103,0.3816, 1.3118,0.3812,
-1.3132,0.3807, 1.3147,0.3803, 1.3162,0.3799, 1.3177,0.3794, 1.3192,0.3790,
-1.3207,0.3786, 1.3221,0.3782, 1.3236,0.3778, 1.3251,0.3773, 1.3266,0.3769,
-1.3280,0.3765, 1.3295,0.3761, 1.3310,0.3757, 1.3324,0.3753, 1.3339,0.3748,
-1.3354,0.3744, 1.3368,0.3740, 1.3383,0.3736, 1.3397,0.3732, 1.3412,0.3728,
-1.3427,0.3724, 1.3441,0.3720, 1.3456,0.3716, 1.3470,0.3712, 1.3485,0.3708,
-1.3499,0.3704, 1.3514,0.3700, 1.3528,0.3696, 1.3542,0.3692, 1.3557,0.3688,
-1.3571,0.3684, 1.3586,0.3680, 1.3600,0.3676, 1.3614,0.3673, 1.3629,0.3669,
-1.3643,0.3665, 1.3657,0.3661, 1.3672,0.3657, 1.3686,0.3653, 1.3700,0.3650,
-1.3714,0.3646, 1.3729,0.3642, 1.3743,0.3638, 1.3757,0.3634, 1.3771,0.3631,
-1.3785,0.3627, 1.3800,0.3623, 1.3814,0.3620, 1.3828,0.3616, 1.3842,0.3612,
-1.3856,0.3609, 1.3870,0.3605, 1.3884,0.3601, 1.3898,0.3598, 1.3912,0.3594,
-1.3926,0.3590, 1.3940,0.3587, 1.3954,0.3583, 1.3968,0.3580, 1.3982,0.3576,
-1.3996,0.3572, 1.4010,0.3569, 1.4024,0.3565, 1.4038,0.3562, 1.4052,0.3558,
-1.4066,0.3555, 1.4080,0.3551, 1.4094,0.3548, 1.4108,0.3544, 1.4121,0.3541,
-1.4135,0.3537
-};
-
-
-/* Generated by: */
-#if 0
-#include <math.h>
-#include <stdio.h>
-#include <assert.h>
-
-int
-main(int argc, char **argv)
-{
-  int i, j;
-
-  printf ("const float __t_sqrt[1024] = {");
-  for (i = 0; i < 2; i++)
-    {
-      putchar('\n');
-      for (j = 0; j < 256; j++)
-	{
-	  double mval = j/512.0 + 0.5;
-	  double eval = i==0 ? 1.0 : 2.0;
-	  double ls = sqrt(mval*eval);
-	  double hs = sqrt((mval+1/512.0)*eval);
-	  double as = (ls+hs)*0.5;
-	  double lx = 1/(2.0*ls);
-	  double hx = 1/(2.0*hs);
-	  double ax = (lx+hx)*0.5;
-
-	  printf("%.4f,%.4f%s",as,ax,
-		 i*j==255 ? "\n" : j % 5 == 4 ? ",\n" : ", ");
-	  assert((hs-ls)/as < 1/256.0);
-	  assert((hx-lx)/ax < 1/256.0);
-	}
-    }
-  printf ("};\n");
-  return 0;
-}
-#endif /* 0 */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/w_sqrt.c glibc-2.3.2/sysdeps/powerpc/fpu/w_sqrt.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/w_sqrt.c	2002-05-14 21:46:17.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/w_sqrt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,146 +0,0 @@
-/* Single-precision floating point square root.
-   Copyright (C) 1997, 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-#include <math_private.h>
-#include <fenv_libc.h>
-#include <inttypes.h>
-
-static const double almost_half = 0.5000000000000001;  /* 0.5 + 2^-53 */
-static const uint32_t a_nan = 0x7fc00000;
-static const uint32_t a_inf = 0x7f800000;
-static const float two108 = 3.245185536584267269e+32;
-static const float twom54 = 5.551115123125782702e-17;
-extern const float __t_sqrt[1024];
-
-/* The method is based on a description in
-   Computation of elementary functions on the IBM RISC System/6000 processor,
-   P. W. Markstein, IBM J. Res. Develop, 34(1) 1990.
-   Basically, it consists of two interleaved Newton-Rhapson approximations,
-   one to find the actual square root, and one to find its reciprocal
-   without the expense of a division operation.   The tricky bit here
-   is the use of the POWER/PowerPC multiply-add operation to get the
-   required accuracy with high speed.
-
-   The argument reduction works by a combination of table lookup to
-   obtain the initial guesses, and some careful modification of the
-   generated guesses (which mostly runs on the integer unit, while the
-   Newton-Rhapson is running on the FPU).  */
-double
-__sqrt(double x)
-{
-  const float inf = *(const float *)&a_inf;
-  /* x = f_wash(x); *//* This ensures only one exception for SNaN. */
-  if (x > 0)
-    {
-      if (x != inf)
-	{
-	  /* Variables named starting with 's' exist in the
-	     argument-reduced space, so that 2 > sx >= 0.5,
-	     1.41... > sg >= 0.70.., 0.70.. >= sy > 0.35... .
-	     Variables named ending with 'i' are integer versions of
-	     floating-point values.  */
-	  double sx;   /* The value of which we're trying to find the
-			  square root.  */
-	  double sg,g; /* Guess of the square root of x.  */
-	  double sd,d; /* Difference between the square of the guess and x.  */
-	  double sy;   /* Estimate of 1/2g (overestimated by 1ulp).  */
-	  double sy2;  /* 2*sy */
-	  double e;    /* Difference between y*g and 1/2 (se = e * fsy).  */
-	  double shx;  /* == sx * fsg */
-	  double fsg;  /* sg*fsg == g.  */
-	  fenv_t fe;  /* Saved floating-point environment (stores rounding
-			 mode and whether the inexact exception is
-			 enabled).  */
-	  uint32_t xi0, xi1, sxi, fsgi;
-	  const float *t_sqrt;
-
-	  fe = fegetenv_register();
-	  EXTRACT_WORDS (xi0,xi1,x);
-	  relax_fenv_state();
-	  sxi = (xi0 & 0x3fffffff) | 0x3fe00000;
-	  INSERT_WORDS (sx, sxi, xi1);
-	  t_sqrt = __t_sqrt + (xi0 >> (52-32-8-1)  & 0x3fe);
-	  sg = t_sqrt[0];
-	  sy = t_sqrt[1];
-	  
-	  /* Here we have three Newton-Rhapson iterations each of a
-	     division and a square root and the remainder of the
-	     argument reduction, all interleaved.   */
-	  sd  = -(sg*sg - sx);
-	  fsgi = (xi0 + 0x40000000) >> 1 & 0x7ff00000;
-	  sy2 = sy + sy;
-	  sg  = sy*sd + sg;  /* 16-bit approximation to sqrt(sx). */
-	  INSERT_WORDS (fsg, fsgi, 0);
-	  e   = -(sy*sg - almost_half);
-	  sd  = -(sg*sg - sx);
-	  if ((xi0 & 0x7ff00000) == 0)
-	    goto denorm;
-	  sy  = sy + e*sy2;
-	  sg  = sg + sy*sd;  /* 32-bit approximation to sqrt(sx).  */
-	  sy2 = sy + sy;
-	  e   = -(sy*sg - almost_half);
-	  sd  = -(sg*sg - sx);
-	  sy  = sy + e*sy2;
-	  shx = sx * fsg;
-	  sg  = sg + sy*sd;  /* 64-bit approximation to sqrt(sx),
-				but perhaps rounded incorrectly.  */
-	  sy2 = sy + sy;
-	  g   = sg * fsg;
-	  e   = -(sy*sg - almost_half);
-	  d   = -(g*sg - shx);
-	  sy  = sy + e*sy2;
-	  fesetenv_register (fe);
-	  return g + sy*d;
-	denorm:
-	  /* For denormalised numbers, we normalise, calculate the
-	     square root, and return an adjusted result.  */
-	  fesetenv_register (fe);
-	  return __sqrt(x * two108) * twom54;
-	}
-    }
-  else if (x < 0)
-    {
-#ifdef FE_INVALID_SQRT
-      feraiseexcept (FE_INVALID_SQRT);
-      /* For some reason, some PowerPC processors don't implement
-	 FE_INVALID_SQRT.  I guess no-one ever thought they'd be
-	 used for square roots... :-) */
-      if (!fetestexcept (FE_INVALID))
-#endif
-	feraiseexcept (FE_INVALID);
-#ifndef _IEEE_LIBM
-      if (_LIB_VERSION != _IEEE_)
-	x = __kernel_standard(x,x,26);
-      else
-#endif
-      x = *(const float*)&a_nan;
-    }
-  return f_wash(x);
-}
-
-weak_alias (__sqrt, sqrt)
-/* Strictly, this is wrong, but the only places where _ieee754_sqrt is
-   used will not pass in a negative result.  */
-strong_alias(__sqrt,__ieee754_sqrt)
-
-#ifdef NO_LONG_DOUBLE
-weak_alias (__sqrt, __sqrtl)
-weak_alias (__sqrt, sqrtl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/fpu/w_sqrtf.c glibc-2.3.2/sysdeps/powerpc/fpu/w_sqrtf.c
--- glibc-2.3.2.orig/sysdeps/powerpc/fpu/w_sqrtf.c	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/fpu/w_sqrtf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,136 +0,0 @@
-/* Single-precision floating point square root.
-   Copyright (C) 1997 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <math.h>
-#include <math_private.h>
-#include <fenv_libc.h>
-#include <inttypes.h>
-
-static const float almost_half = 0.50000006;  /* 0.5 + 2^-24 */
-static const uint32_t a_nan = 0x7fc00000;
-static const uint32_t a_inf = 0x7f800000;
-static const float two48 = 281474976710656.0;
-static const float twom24 = 5.9604644775390625e-8;
-extern const float __t_sqrt[1024];
-
-/* The method is based on a description in
-   Computation of elementary functions on the IBM RISC System/6000 processor,
-   P. W. Markstein, IBM J. Res. Develop, 34(1) 1990.
-   Basically, it consists of two interleaved Newton-Rhapson approximations,
-   one to find the actual square root, and one to find its reciprocal
-   without the expense of a division operation.   The tricky bit here
-   is the use of the POWER/PowerPC multiply-add operation to get the
-   required accuracy with high speed.
-
-   The argument reduction works by a combination of table lookup to
-   obtain the initial guesses, and some careful modification of the
-   generated guesses (which mostly runs on the integer unit, while the
-   Newton-Rhapson is running on the FPU).  */
-float
-__sqrtf(float x)
-{
-  const float inf = *(const float *)&a_inf;
-  /* x = f_washf(x); *//* This ensures only one exception for SNaN. */
-  if (x > 0)
-    {
-      if (x != inf)
-	{
-	  /* Variables named starting with 's' exist in the
-	     argument-reduced space, so that 2 > sx >= 0.5,
-	     1.41... > sg >= 0.70.., 0.70.. >= sy > 0.35... .
-	     Variables named ending with 'i' are integer versions of
-	     floating-point values.  */
-	  float sx;   /* The value of which we're trying to find the square
-			 root.  */
-	  float sg,g; /* Guess of the square root of x.  */
-	  float sd,d; /* Difference between the square of the guess and x.  */
-	  float sy;   /* Estimate of 1/2g (overestimated by 1ulp).  */
-	  float sy2;  /* 2*sy */
-	  float e;    /* Difference between y*g and 1/2 (note that e==se).  */
-	  float shx;  /* == sx * fsg */
-	  float fsg;  /* sg*fsg == g.  */
-	  fenv_t fe;  /* Saved floating-point environment (stores rounding
-			 mode and whether the inexact exception is
-			 enabled).  */
-	  uint32_t xi, sxi, fsgi;
-	  const float *t_sqrt;
-
-	  GET_FLOAT_WORD (xi, x);
-	  fe = fegetenv_register ();
-	  relax_fenv_state ();
-	  sxi = (xi & 0x3fffffff) | 0x3f000000;
-	  SET_FLOAT_WORD (sx, sxi);
-	  t_sqrt = __t_sqrt + (xi >> (23-8-1)  & 0x3fe);
-	  sg = t_sqrt[0];
-	  sy = t_sqrt[1];
-	  
-	  /* Here we have three Newton-Rhapson iterations each of a
-	     division and a square root and the remainder of the
-	     argument reduction, all interleaved.   */
-	  sd  = -(sg*sg - sx);
-	  fsgi = (xi + 0x40000000) >> 1 & 0x7f800000;
-	  sy2 = sy + sy;
-	  sg  = sy*sd + sg;  /* 16-bit approximation to sqrt(sx). */
-	  e   = -(sy*sg - almost_half);
-	  SET_FLOAT_WORD (fsg, fsgi);
-	  sd  = -(sg*sg - sx);
-	  sy  = sy + e*sy2;
-	  if ((xi & 0x7f800000) == 0)
-	    goto denorm;
-	  shx = sx * fsg;
-	  sg  = sg + sy*sd;  /* 32-bit approximation to sqrt(sx),
-				but perhaps rounded incorrectly.  */
-	  sy2 = sy + sy;
-	  g   = sg * fsg;
-	  e   = -(sy*sg - almost_half);
-	  d   = -(g*sg - shx);
-	  sy  = sy + e*sy2;
-	  fesetenv_register (fe);
-	  return g + sy*d;
-	denorm:
-	  /* For denormalised numbers, we normalise, calculate the
-	     square root, and return an adjusted result.  */
-	  fesetenv_register (fe);
-	  return __sqrtf(x * two48) * twom24;
-	}
-    }
-  else if (x < 0)
-    {
-#ifdef FE_INVALID_SQRT
-      feraiseexcept (FE_INVALID_SQRT);
-      /* For some reason, some PowerPC processors don't implement
-	 FE_INVALID_SQRT.  I guess no-one ever thought they'd be
-	 used for square roots... :-) */
-      if (!fetestexcept (FE_INVALID))
-#endif
-	feraiseexcept (FE_INVALID);
-#ifndef _IEEE_LIBM
-      if (_LIB_VERSION != _IEEE_)
-	x = __kernel_standard(x,x,126);
-      else
-#endif
-      x = *(const float*)&a_nan;
-    }
-  return f_washf(x);
-}
-
-weak_alias (__sqrtf, sqrtf)
-/* Strictly, this is wrong, but the only places where _ieee754_sqrt is
-   used will not pass in a negative result.  */
-strong_alias(__sqrtf,__ieee754_sqrtf)
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/Dist glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/Dist
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/Dist	2002-09-19 06:46:16.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/Dist	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-fprrest.S
-fprsave.S
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/fprrest.S glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/fprrest.S
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/fprrest.S	2001-12-06 23:41:33.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/fprrest.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,94 +0,0 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
-    Floating Point Registers (FPRs) restore routine
-*/
-
-#include <sysdep.h>
-
-ENTRY(_restfpr_all)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf14)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_14)
-C_TEXT(_restf14):
-C_TEXT(_restfpr_14):	lfd	fp14,-144(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf15)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_15)
-C_TEXT(_restf15):
-C_TEXT(_restfpr_15):	lfd	fp15,-136(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf16)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_16)
-C_TEXT(_restf16):
-C_TEXT(_restfpr_16):	lfd	fp16,-128(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf17)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_17)
-C_TEXT(_restf17):
-C_TEXT(_restfpr_17):	lfd	fp17,-120(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf18)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_18)
-C_TEXT(_restf18):
-C_TEXT(_restfpr_18):	lfd	fp18,-112(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf19)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_19)
-C_TEXT(_restf19):
-C_TEXT(_restfpr_19):	lfd	fp19,-104(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf20)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_20)
-C_TEXT(_restf20):
-C_TEXT(_restfpr_20):	lfd	fp20,-96(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf21)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_21)
-C_TEXT(_restf21):
-C_TEXT(_restfpr_21):	lfd	fp21,-88(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf22)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_22)
-C_TEXT(_restf22):
-C_TEXT(_restfpr_22):	lfd	fp22,-80(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf23)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_23)
-C_TEXT(_restf23):
-C_TEXT(_restfpr_23):	lfd	fp23,-72(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf24)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_24)
-C_TEXT(_restf24):
-C_TEXT(_restfpr_24):	lfd	fp24,-64(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf25)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_25)
-C_TEXT(_restf25):
-C_TEXT(_restfpr_25):	lfd	fp25,-56(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf26)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_26)
-C_TEXT(_restf26):
-C_TEXT(_restfpr_26):	lfd	fp26,-48(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf27)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_27)
-C_TEXT(_restf27):
-C_TEXT(_restfpr_27):	lfd	fp27,-40(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf28)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_28)
-C_TEXT(_restf28):
-C_TEXT(_restfpr_28):	lfd	fp28,-32(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restf29)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_restfpr_29)
-C_TEXT(_restf29):
-C_TEXT(_restfpr_29):	lwz	r0,8(r1)	#get return address from frame
-			lfd	fp29,-24(r1)    #restore f29
-			mtlr	r0		#move return address to LR
-			lfd	fp30,-16(r1)	#restore f30
-			lfd	fp31,-8(r1)	#restore f31
-			blr			#return
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/fprsave.S glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/fprsave.S
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/fprsave.S	2001-12-06 23:41:33.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/fprsave.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/*
-    Floating Point Registers (FPRs) save routine
-*/
-
-#include <sysdep.h>
-
-ENTRY(_savefpr_all)
-                ASM_GLOBAL_DIRECTIVE C_TEXT(_savef14)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_14)
-C_TEXT(_savef14):
-C_TEXT(_savefpr_14):	stfd	fp14,-144(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef15)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_15)
-C_TEXT(_savef15):
-C_TEXT(_savefpr_15):	stfd	fp15,-136(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef16)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_16)
-C_TEXT(_savef16):
-C_TEXT(_savefpr_16):	stfd	fp16,-128(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef17)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_17)
-C_TEXT(_savef17):
-C_TEXT(_savefpr_17):	stfd	fp17,-120(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef18)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_18)
-C_TEXT(_savef18):
-C_TEXT(_savefpr_18):	stfd	fp18,-112(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef19)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_19)
-C_TEXT(_savef19):
-C_TEXT(_savefpr_19):	stfd	fp19,-104(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef20)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_20)
-C_TEXT(_savef20):
-C_TEXT(_savefpr_20):	stfd	fp20,-96(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef21)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_21)
-C_TEXT(_savef21):
-C_TEXT(_savefpr_21):	stfd	fp21,-88(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef22)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_22)
-C_TEXT(_savef22):
-C_TEXT(_savefpr_22):	stfd	fp22,-80(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef23)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_23)
-C_TEXT(_savef23):
-C_TEXT(_savefpr_23):	stfd	fp23,-72(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef24)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_24)
-C_TEXT(_savef24):
-C_TEXT(_savefpr_24):	stfd	fp24,-64(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef25)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_25)
-C_TEXT(_savef25):
-C_TEXT(_savefpr_25):	stfd	fp25,-56(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef26)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_26)
-C_TEXT(_savef26):
-C_TEXT(_savefpr_26):	stfd	fp26,-48(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef27)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_27)
-C_TEXT(_savef27):
-C_TEXT(_savefpr_27):	stfd	fp27,-40(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef28)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_28)
-C_TEXT(_savef28):
-C_TEXT(_savefpr_28):	stfd	fp28,-32(r1)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savef29)
-		ASM_GLOBAL_DIRECTIVE C_TEXT(_savefpr_29)
-C_TEXT(_savef29):
-C_TEXT(_savefpr_29):	stfd	fp29,-24(r1)	#save f29
-			stfd	fp30,-16(r1)	#save f30
-			stfd	fp31,-8(r1)	#save f31
-			stw	r0,8(r1)	#save LR in callers frame
-			blr			#return
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/__longjmp.S glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/__longjmp.S
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/__longjmp.S	2003-02-17 20:32:09.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/__longjmp.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/* longjmp for PowerPC.
-   Copyright (C) 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-#define _ASM
-#define _SETJMP_H
-#include <bits/setjmp.h>
-#include <bp-sym.h>
-#include <bp-asm.h>
-
-ENTRY (BP_SYM (__longjmp))
-	CHECK_BOUNDS_BOTH_WIDE_LIT (r3, r8, r9, JB_SIZE)
-
-	lwz r1,(JB_GPR1*4)(r3)
-	lwz r0,(JB_LR*4)(r3)
-	lwz r14,((JB_GPRS+0)*4)(r3)
-	lfd fp14,((JB_FPRS+0*2)*4)(r3)
-	lwz r15,((JB_GPRS+1)*4)(r3)
-	lfd fp15,((JB_FPRS+1*2)*4)(r3)
-	lwz r16,((JB_GPRS+2)*4)(r3)
-	lfd fp16,((JB_FPRS+2*2)*4)(r3)
-	lwz r17,((JB_GPRS+3)*4)(r3)
-	lfd fp17,((JB_FPRS+3*2)*4)(r3)
-	lwz r18,((JB_GPRS+4)*4)(r3)
-	lfd fp18,((JB_FPRS+4*2)*4)(r3)
-	lwz r19,((JB_GPRS+5)*4)(r3)
-	lfd fp19,((JB_FPRS+5*2)*4)(r3)
-	lwz r20,((JB_GPRS+6)*4)(r3)
-	lfd fp20,((JB_FPRS+6*2)*4)(r3)
-	mtlr r0
-	lwz r21,((JB_GPRS+7)*4)(r3)
-	lfd fp21,((JB_FPRS+7*2)*4)(r3)
-	lwz r22,((JB_GPRS+8)*4)(r3)
-	lfd fp22,((JB_FPRS+8*2)*4)(r3)
-	lwz r0,(JB_CR*4)(r3)
-	lwz r23,((JB_GPRS+9)*4)(r3)
-	lfd fp23,((JB_FPRS+9*2)*4)(r3)
-	lwz r24,((JB_GPRS+10)*4)(r3)
-	lfd fp24,((JB_FPRS+10*2)*4)(r3)
-	lwz r25,((JB_GPRS+11)*4)(r3)
-	lfd fp25,((JB_FPRS+11*2)*4)(r3)
-	mtcrf 0xFF,r0
-	lwz r26,((JB_GPRS+12)*4)(r3)
-	lfd fp26,((JB_FPRS+12*2)*4)(r3)
-	lwz r27,((JB_GPRS+13)*4)(r3)
-	lfd fp27,((JB_FPRS+13*2)*4)(r3)
-	lwz r28,((JB_GPRS+14)*4)(r3)
-	lfd fp28,((JB_FPRS+14*2)*4)(r3)
-	lwz r29,((JB_GPRS+15)*4)(r3)
-	lfd fp29,((JB_FPRS+15*2)*4)(r3)
-	lwz r30,((JB_GPRS+16)*4)(r3)
-	lfd fp30,((JB_FPRS+16*2)*4)(r3)
-	lwz r31,((JB_GPRS+17)*4)(r3)
-	lfd fp31,((JB_FPRS+17*2)*4)(r3)
-	mr r3,r4
-	blr
-END (BP_SYM (__longjmp))
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/Makefile glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/Makefile
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/Makefile	2002-09-05 10:56:42.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-ifeq ($(subdir),misc)
-sysdep_routines += fprsave fprrest
-endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/s_copysignf.S glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/s_copysignf.S
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/s_copysignf.S	1997-08-29 01:50:36.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/s_copysignf.S	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-/* __copysignf is in s_copysign.S  */
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/s_copysign.S glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/s_copysign.S
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/s_copysign.S	2001-07-07 20:21:28.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/s_copysign.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/* Copy a sign bit between floating-point values.
-   Copyright (C) 1997, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-/* This has been coded in assembler because GCC makes such a mess of it
-   when it's coded in C.  */
-
-#include <sysdep.h>
-
-ENTRY(__copysign)
-/* double [f1] copysign (double [f1] x, double [f2] y);
-   copysign(x,y) returns a value with the magnitude of x and
-   with the sign bit of y.  */
-	stwu	r1,-16(r1)
-	stfd	fp2,8(r1)
-	lwz	r3,8(r1)
-	cmpwi   r3,0
-	addi    r1,r1,16
-	blt     L(0)
-	fabs    fp1,fp1
-	blr
-L(0):	fnabs   fp1,fp1
-	blr
-	END (__copysign)
-
-weak_alias(__copysign,copysign)
-
-/* It turns out that it's safe to use this code even for single-precision.  */
-weak_alias(__copysign,copysignf)
-strong_alias(__copysign,__copysignf)
-
-#ifdef NO_LONG_DOUBLE
-weak_alias(__copysign,copysignl)
-strong_alias(__copysign,__copysignl)
-#endif
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/setjmp.S glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/setjmp.S
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/fpu/setjmp.S	2003-02-17 20:32:09.000000000 +0000
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/fpu/setjmp.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,72 +0,0 @@
-/* setjmp for PowerPC.
-   Copyright (C) 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-#define _ASM
-#define _SETJMP_H
-#include <bits/setjmp.h>
-#include <bp-sym.h>
-#include <bp-asm.h>
-
-ENTRY (BP_SYM (__sigsetjmp))
-	CHECK_BOUNDS_BOTH_WIDE_LIT (r3, r8, r9, JB_SIZE)
-
-	stw  r1,(JB_GPR1*4)(3)
-	mflr r0
-	stw  r14,((JB_GPRS+0)*4)(3)
-	stfd fp14,((JB_FPRS+0*2)*4)(3)
-	stw  r0,(JB_LR*4)(3)
-	stw  r15,((JB_GPRS+1)*4)(3)
-	stfd fp15,((JB_FPRS+1*2)*4)(3)
-	mfcr r0
-	stw  r16,((JB_GPRS+2)*4)(3)
-	stfd fp16,((JB_FPRS+2*2)*4)(3)
-	stw  r0,(JB_CR*4)(3)
-	stw  r17,((JB_GPRS+3)*4)(3)
-	stfd fp17,((JB_FPRS+3*2)*4)(3)
-	stw  r18,((JB_GPRS+4)*4)(3)
-	stfd fp18,((JB_FPRS+4*2)*4)(3)
-	stw  r19,((JB_GPRS+5)*4)(3)
-	stfd fp19,((JB_FPRS+5*2)*4)(3)
-	stw  r20,((JB_GPRS+6)*4)(3)
-	stfd fp20,((JB_FPRS+6*2)*4)(3)
-	stw  r21,((JB_GPRS+7)*4)(3)
-	stfd fp21,((JB_FPRS+7*2)*4)(3)
-	stw  r22,((JB_GPRS+8)*4)(3)
-	stfd fp22,((JB_FPRS+8*2)*4)(3)
-	stw  r23,((JB_GPRS+9)*4)(3)
-	stfd fp23,((JB_FPRS+9*2)*4)(3)
-	stw  r24,((JB_GPRS+10)*4)(3)
-	stfd fp24,((JB_FPRS+10*2)*4)(3)
-	stw  r25,((JB_GPRS+11)*4)(3)
-	stfd fp25,((JB_FPRS+11*2)*4)(3)
-	stw  r26,((JB_GPRS+12)*4)(3)
-	stfd fp26,((JB_FPRS+12*2)*4)(3)
-	stw  r27,((JB_GPRS+13)*4)(3)
-	stfd fp27,((JB_FPRS+13*2)*4)(3)
-	stw  r28,((JB_GPRS+14)*4)(3)
-	stfd fp28,((JB_FPRS+14*2)*4)(3)
-	stw  r29,((JB_GPRS+15)*4)(3)
-	stfd fp29,((JB_FPRS+15*2)*4)(3)
-	stw  r30,((JB_GPRS+16)*4)(3)
-	stfd fp30,((JB_FPRS+16*2)*4)(3)
-	stw  r31,((JB_GPRS+17)*4)(3)
-	stfd fp31,((JB_FPRS+17*2)*4)(3)
-	b JUMPTARGET (BP_SYM (__sigjmp_save))
-END (BP_SYM (__sigsetjmp))
diff -uNr glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/Makefile glibc-2.3.2/sysdeps/powerpc/powerpc32/Makefile
--- glibc-2.3.2.orig/sysdeps/powerpc/powerpc32/Makefile	2005-04-18 14:06:14.000000000 +0100
+++ glibc-2.3.2/sysdeps/powerpc/powerpc32/Makefile	2005-04-18 14:11:58.000000000 +0100
@@ -1,7 +1,10 @@
 # Powerpc32 specific build options.
 
+cflags += -Wa,-mspe
+asm-CPPFLAGS += -Wa,-mspe
+
 ifeq ($(with-fp),no)
-+cflags += -msoft-float
+cflags += -msoft-float
 sysdep-LDFLAGS += -msoft-float
 endif
 
