# libstdc++-v3/include/i586-linux-uclibc/bits/ctype_noninline.h: In constructor `std::ctype<char>::ctype(int*, const short unsigned int*, bool, size_t)':
# libstdc++-v3/include/i586-linux-uclibc/bits/ctype_noninline.h:85: error: cannot convert `const __ctype_touplow_t*' to `const int*' in assignment
#
---
# libstdc++-v3/config/locale/generic/c_locale.h |    6 ++++++
# libstdc++-v3/config/os/gnu-linux/ctype_base.h |   10 ++++++++--
# 2 files changed, 14 insertions(+), 2 deletions(-)
#
Index: gcc-4.1.2/libstdc++-v3/config/locale/generic/c_locale.h
===================================================================
--- gcc-4.1.2.orig/libstdc++-v3/config/locale/generic/c_locale.h
+++ gcc-4.1.2/libstdc++-v3/config/locale/generic/c_locale.h
@@ -41,12 +41,18 @@
 #include <clocale>
 #include <cstring>   // get std::strlen
 #include <cstdio>    // get std::snprintf or std::sprintf
+#include <features.h>
+#include <ctype.h>
 
 #define _GLIBCXX_NUM_CATEGORIES 0
 
 namespace std
 {
+#ifdef __UCLIBC__
+  typedef __ctype_touplow_t*	__c_locale;
+#else
   typedef int*			__c_locale;
+#endif
 
   // Convert numeric value of type _Tv to string and return length of
   // string.  If snprintf is available use it, otherwise fall back to
Index: gcc-4.1.2/libstdc++-v3/config/os/gnu-linux/ctype_base.h
===================================================================
--- gcc-4.1.2.orig/libstdc++-v3/config/os/gnu-linux/ctype_base.h
+++ gcc-4.1.2/libstdc++-v3/config/os/gnu-linux/ctype_base.h
@@ -31,7 +31,9 @@
 //
 // ISO C++ 14882: 22.1  Locales
 //
-  
+#include <features.h>
+#include <ctype.h>
+
 /** @file ctype_base.h
  *  This is an internal header file, included by other library headers.
  *  You should not attempt to use it directly.
@@ -43,7 +45,11 @@
   struct ctype_base
   {
     // Non-standard typedefs.
-    typedef const int* 		__to_type;
+#ifdef __UCLIBC__
+    typedef const __ctype_touplow_t*	__to_type;
+#else
+    typedef const int*			__to_type;
+#endif
 
     // NB: Offsets into ctype<char>::_M_table force a particular size
     // on the mask type. Because of this, we don't use an enum.
