#
# Submitted-By: Robert Schwebel, 2006-07-20
# Committed-By: Robert Schwebel
#
# Error:
#
# The following construction is broken:
#
# struct = *some_other_struct;
#
# For details see bugzilla entry below.
#
# Description:
#
# This is a patch against gcc-trunk which fixes the following bug from
# gcc bugzilla:
#
# http://gcc.gnu.org/bugzilla/show_bug.cgi?id=27363
#
# The patch was taken from upstream cvs for trunk and has to be adapted
# to random gcc versions. It is at least necessary until gcc 4.1.0
#
# State:
#
# fixed in upstream cvs
#

--- trunk/gcc/ChangeLog	2006/07/20 08:34:53	115613
+++ trunk/gcc/ChangeLog	2006/07/20 13:57:31	115614
@@ -1,3 +1,9 @@
+2006-07-20  Paul Brook  <paul@codesourcery.com>
+
+	PR 27363
+	* cse.c (cse_insn): Add destination addresses to hash table. Check if
+	they are invalidated by this instruction.
+
 2006-07-21  Danny Smith  <dannysmith@users.sourceforge.net>
 
 	PR target/28427
--- trunk/gcc/cse.c	2006/07/20 08:34:53	115613
+++ trunk/gcc/cse.c	2006/07/20 13:57:31	115614
@@ -4739,6 +4739,8 @@
   unsigned src_const_hash;
   /* Table entry for constant equivalent for SET_SRC, if any.  */
   struct table_elt *src_const_elt;
+  /* Table entry for the destination address.  */
+  struct table_elt *dest_addr_elt;
 };
 
 static void
@@ -5970,6 +5972,40 @@
 	 so that the destination goes into that class.  */
       sets[i].src_elt = src_eqv_elt;
 
+  /* Record destination addresses in the hash table.  This allows us to
+     check if they are invalidated by other sets.  */
+  for (i = 0; i < n_sets; i++)
+    {
+      if (sets[i].rtl)
+	{
+	  rtx x = sets[i].inner_dest;
+	  struct table_elt *elt;
+	  enum machine_mode mode;
+	  unsigned hash;
+
+	  if (MEM_P (x))
+	    {
+	      x = XEXP (x, 0);
+	      mode = GET_MODE (x);
+	      hash = HASH (x, mode);
+	      elt = lookup (x, hash, mode);
+	      if (!elt)
+		{
+		  if (insert_regs (x, NULL, 0))
+		    {
+		      rehash_using_reg (x);
+		      hash = HASH (x, mode);
+		    }
+		  elt = insert (x, NULL, hash, mode);
+		}
+
+	      sets[i].dest_addr_elt = elt;
+	    }
+	  else
+	    sets[i].dest_addr_elt = NULL;
+	}
+    }
+
   invalidate_from_clobbers (x);
 
   /* Some registers are invalidated by subroutine calls.  Memory is
@@ -6062,12 +6098,20 @@
     }
 
   /* We may have just removed some of the src_elt's from the hash table.
-     So replace each one with the current head of the same class.  */
+     So replace each one with the current head of the same class.
+     Also check if destination addresses have been removed.  */
 
   for (i = 0; i < n_sets; i++)
     if (sets[i].rtl)
       {
-	if (sets[i].src_elt && sets[i].src_elt->first_same_value == 0)
+	if (sets[i].dest_addr_elt
+	    && sets[i].dest_addr_elt->first_same_value == 0)
+	  {
+	    /* The elt was removed, which means this destination s not
+	       valid after this instruction.  */
+	    sets[i].rtl = NULL_RTX;
+	  }
+	else if (sets[i].src_elt && sets[i].src_elt->first_same_value == 0)
 	  /* If elt was removed, find current head of same class,
 	     or 0 if nothing remains of that class.  */
 	  {
/* PR27363.  CSE was breaking on the arm store multiple insn used for
   structure copies.  */
/* { dg-do run } */
/* { dg-options "-Os" } */
extern void abort (void);

struct snd_mask {
    unsigned int bits[6];
};

static int __attribute__((noinline))
snd_mask_refine(struct snd_mask *mask)
{
  struct snd_mask old;

  old = *mask;
  if (mask->bits[0]==0 && mask->bits[1]==0)
    return 1;

  return old.bits[0] != mask->bits[0];
}

int main(int argc, char *argv[])
{
  struct snd_mask mask;


  mask.bits[0] = 23;
  mask.bits[1] = 42;
  mask.bits[2] = 0;
  mask.bits[3] = 0;
  mask.bits[4] = 0; 
  mask.bits[5] = 0;


  if (snd_mask_refine(&mask))
    abort();
  return 0;
}
--- trunk/gcc/testsuite/ChangeLog	2006/07/20 08:34:53	115613
+++ trunk/gcc/testsuite/ChangeLog	2006/07/20 13:57:31	115614
@@ -1,3 +1,8 @@
+2006-07-20  Paul Brook  <paul@codesourcery.com>
+
+	PR 27363
+	* gcc.dg/pr27363.c: New test.
+
 2006-07-19  Mark Mitchell  <mark@codesourcery.com>
 
 	PR c++/28338
